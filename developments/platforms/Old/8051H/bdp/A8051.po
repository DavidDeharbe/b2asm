THEORY ProofList IS
  _f(1) & _f(2) & _f(6) & _f(36) & MOVIM.2,(_f(37) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(36) & MOVIM.1,(_f(25) => _f(31));
  _f(1) & _f(2) & _f(6) & _f(33) & MOVMI.2,(_f(35) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(33) & MOVMI.1,(_f(34) & _f(25) => _f(31));
  _f(1) & _f(2) & _f(6) & _f(30) & MOVM.2,(_f(32) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(30) & MOVM.1,(_f(25) => _f(31));
  _f(1) & _f(2) & _f(6) & _f(28) & MOVI.2,(_f(29) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(28) & MOVI.1,(_f(25) => _f(26));
  _f(1) & _f(2) & _f(6) & _f(24) & MOV.2,(_f(27) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(24) & MOV.1,(_f(25) => _f(26));
  _f(1) & _f(2) & _f(6) & _f(22) & SJMP.1,(_f(7) => _f(10));
  _f(1) & _f(2) & _f(6) & _f(18) & CJNEM.3,(_f(21) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(18) & CJNEM.2,(_f(20) & _f(7) => _f(10));
  _f(1) & _f(2) & _f(6) & _f(18) & CJNEM.1,(_f(19) & _f(7) => _f(10));
  _f(1) & _f(2) & _f(6) & _f(14) & CJNEI.3,(_f(17) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(14) & CJNEI.2,(_f(16) & _f(7) => _f(10));
  _f(1) & _f(2) & _f(6) & _f(14) & CJNEI.1,(_f(15) & _f(7) => _f(10));
  _f(1) & _f(2) & _f(6) & _f(8) & CJNE.3,(_f(12) & _f(7) => _f(13));
  _f(1) & _f(2) & _f(6) & _f(8) & CJNE.2,(_f(11) & _f(7) => _f(10));
  _f(1) & _f(2) & _f(6) & _f(8) & CJNE.1,(_f(9) & _f(7) => _f(10));
  _f(1) & _f(2) & _f(6) & INIT.1,(_f(7) => _f(5));
  _f(1) & _f(2) & Initialisation.1,(_f(3) & _f(4) => _f(5))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & parity: BYTE +-> BIT & dom(parity) = BYTE & parity = %bv.(bv: BYTE | BYTE_PAR(bv)) & half: UCHAR +-> UCHAR & dom(half) = UCHAR & half = %v1.(v1: UCHAR | v1 mod 2**4) & add: UCHAR*UCHAR*UCHAR +-> UCHAR*BIT*BIT*BIT*BIT & dom(add) = UCHAR*UCHAR*UCHAR & add = %(v1,v2,ca).(v1: UCHAR & v2: UCHAR & ca: UCHAR | (v1+v2+ca) mod 2**8,parity(uchar_byte((v1+v2+ca) mod 2**8)),bool_to_bit(bool(not(uchar_schar(v1)+uchar_schar(v2)+ca: SCHAR))),bool_to_bit(bool(2**4<=half(v1)+half(v2)+ca)),bool_to_bit(bool(not(v1+v2+ca: UCHAR)))) & sub: UCHAR*UCHAR*UCHAR +-> UCHAR*BIT*BIT*BIT*BIT & dom(sub) = UCHAR*UCHAR*UCHAR & sub = %(v1,v2,ca).(v1: UCHAR & v2: UCHAR & ca: UCHAR | bool_to_bit(bool(v1+1<=v2+ca))*256+v1-v2-ca,parity(uchar_byte(bool_to_bit(bool(v1+1<=v2+ca))*256+v1-v2-ca)),bool_to_bit(bool(not(uchar_schar(v1)-uchar_schar(v2)-ca: SCHAR))),bool_to_bit(bool(half(v1)+1<=half(v2)-ca)),bool_to_bit(bool(not(v1-v2-ca: UCHAR)))) & and: BYTE*BYTE +-> BYTE & dom(and) = BYTE*BYTE & and = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | BYTE_AND(bt1,bt2)) & ior: BYTE*BYTE +-> BYTE & dom(ior) = BYTE*BYTE & ior = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | BYTE_OR(bt1,bt2)) & xor: BYTE*BYTE +-> BYTE & dom(xor) = BYTE*BYTE & xor = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | BYTE_XOR(bt1,bt2)) & complement: BYTE +-> BYTE & dom(complement) = BYTE & complement = %bt.(bt: BYTE | BYTE_COMPLEMENT(bt)) & swap: BYTE +-> BYTE & dom(swap) = BYTE & swap = %bt.(bt: BYTE | {0|->bt(4)}\/{1|->bt(5)}\/{2|->bt(6)}\/{3|->bt(7)}\/{4|->bt(0)}\/{5|->bt(1)}\/{6|->bt(2)}\/{7|->bt(3)}) & rotateleft: BYTE +-> BYTE & dom(rotateleft) = BYTE & rotateleft = %bv.(bv: BYTE | {0|->bv(7)}\/{1|->bv(0)}\/{2|->bv(1)}\/{3|->bv(2)}\/{4|->bv(3)}\/{5|->bv(4)}\/{6|->bv(5)}\/{7|->bv(6)}) & rotateright: BYTE +-> BYTE & dom(rotateright) = BYTE & rotateright = %bv.(bv: BYTE | {0|->bv(1)}\/{1|->bv(2)}\/{2|->bv(3)}\/{3|->bv(4)}\/{4|->bv(5)}\/{5|->bv(6)}\/{6|->bv(7)}\/{7|->bv(0)}) & BIT = 0..1 & bit_not: BIT +-> BIT & dom(bit_not) = BIT & !bb.(bb: BIT => bit_not(bb) = 1-bb) & bit_and: BIT*BIT +-> BIT & dom(bit_and) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_and(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_and(b1,b2) = 1) & b2 = 1) & bit_or: BIT*BIT +-> BIT & dom(bit_or) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_or(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_or(b1,b2) = 1) or b2 = 1) & bit_xor: BIT*BIT +-> BIT & dom(bit_xor) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_xor(b1,b2) = 1 => not(b1 = b2)) & (not(b1 = b2) => bit_xor(b1,b2) = 1)) & bool_to_bit: BOOL +-> BIT & dom(bool_to_bit) = BOOL & bool_to_bit = {TRUE|->1}\/{FALSE|->0} & UCHAR_MAX: INTEGER & 0<=UCHAR_MAX & UCHAR_MAX = 2**BYTE_WIDTH-1 & UCHAR = 0..UCHAR_MAX & SCHAR_MAX: INTEGER & SCHAR_MIN: INTEGER & SCHAR_MAX = -(2**BYTE_WIDTH) & SCHAR_MIN = 2**BYTE_WIDTH-1 & SCHAR = SCHAR_MIN..SCHAR_MAX & byte_uchar: BYTE +-> UCHAR & dom(byte_uchar) = BYTE & byte_uchar = %bv.(bv: BYTE | bv(7)*128+bv(6)*64+bv(5)*32+bv(4)*16+bv(3)*8+bv(2)*4+bv(1)*2+bv(0)*1) & uchar_byte = byte_uchar~ & byte_schar: BYTE +-> SCHAR & dom(byte_schar) = BYTE & byte_schar = %bv.(bv: BYTE | (-bv(7))*128+bv(6)*64+bv(5)*32+bv(4)*16+bv(3)*8+bv(2)*4+bv(1)*2+bv(0)*1) & schar_byte = byte_schar~ & uchar_schar: UCHAR +-> SCHAR & dom(uchar_schar) = UCHAR & uchar_schar = %v1.(v1: UCHAR | v1-UCHAR_MAX*bool_to_bit(bool(SCHAR_MAX+1<=v1))) & schar_uchar = uchar_schar~);
  ("`Included,imported and extended machines properties'" & ADDR_LEN: INTEGER & 0<=ADDR_LEN & ADDR_LEN = 8 & ADDR_MAX: INTEGER & 0<=ADDR_MAX & ADDR_MAX = 2**ADDR_LEN & RAM_MAX = 127 & MEM_ADDR = 0..ADDR_MAX-1 & RAM_ADDR = 0..RAM_MAX & SFR_ADDR = RAM_MAX+1..ADDR_MAX-1 & BIT_ADDRESSABLE: POW(MEM_ADDR) & BIT_ADDRESSABLE = 32..47 & BIT_ADDRESS = BIT_ADDRESSABLE*BYTE_INDEX & INSTRUCTION_LEN: INTEGER & 0<=INSTRUCTION_LEN & INSTRUCTION_LEN = 8 & INSTRUCTION_MAX = 2**INSTRUCTION_LEN & INSTRUCTION = 0..INSTRUCTION_MAX-1 & sbuf = 153 & SP = 109 & pcon = 135 & R0 = 0 & R1 = 1 & R2 = 2 & R3 = 3 & R4 = 4 & R5 = 5 & R6 = 6 & R7 = 7 & BB = 240 & BF0: BIT_ADDRESS & BF1: BIT_ADDRESS & BF2: BIT_ADDRESS & BF3: BIT_ADDRESS & BF4: BIT_ADDRESS & BF5: BIT_ADDRESS & BF6: BIT_ADDRESS & BF7: BIT_ADDRESS & BF0 = BB|->0 & BF1 = BB|->1 & BF2 = BB|->2 & BF3 = BB|->3 & BF4 = BB|->4 & BF5 = BB|->5 & BF6 = BB|->6 & BF7 = BB|->7 & AA = 224 & ACC = 224 & BE0: BIT_ADDRESS & BE1: BIT_ADDRESS & BE2: BIT_ADDRESS & BE3: BIT_ADDRESS & BE4: BIT_ADDRESS & BE5: BIT_ADDRESS & BE6: BIT_ADDRESS & BE7: BIT_ADDRESS & BE0 = ACC|->0 & BE1 = ACC|->1 & BE2 = ACC|->2 & BE3 = ACC|->3 & BE4 = ACC|->4 & BE5 = ACC|->5 & BE6 = ACC|->6 & BE7 = ACC|->7 & P0 = 128 & P0_0: BIT_ADDRESS & P0_1: BIT_ADDRESS & P0_2: BIT_ADDRESS & P0_3: BIT_ADDRESS & P0_4: BIT_ADDRESS & P0_5: BIT_ADDRESS & P0_6: BIT_ADDRESS & P0_7: BIT_ADDRESS & B80: BIT_ADDRESS & B81: BIT_ADDRESS & B82: BIT_ADDRESS & B83: BIT_ADDRESS & B84: BIT_ADDRESS & B85: BIT_ADDRESS & B86: BIT_ADDRESS & B87: BIT_ADDRESS & P0_0 = P0|->0 & P0_1 = P0|->1 & P0_2 = P0|->2 & P0_3 = P0|->3 & P0_4 = P0|->4 & P0_5 = P0|->5 & P0_6 = P0|->6 & P0_7 = P0|->7 & B80 = P0|->0 & B81 = P0|->1 & B82 = P0|->2 & B83 = P0|->3 & B84 = P0|->4 & B85 = P0|->5 & B86 = P0|->6 & B87 = P0|->7 & P1 = 144 & P1_0: BIT_ADDRESS & P1_1: BIT_ADDRESS & P1_2: BIT_ADDRESS & P1_3: BIT_ADDRESS & P1_4: BIT_ADDRESS & P1_5: BIT_ADDRESS & P1_6: BIT_ADDRESS & P1_7: BIT_ADDRESS & B90: BIT_ADDRESS & B91: BIT_ADDRESS & B92: BIT_ADDRESS & B93: BIT_ADDRESS & B94: BIT_ADDRESS & B95: BIT_ADDRESS & B96: BIT_ADDRESS & B97: BIT_ADDRESS & P1_0 = P1|->0 & P1_1 = P1|->1 & P1_2 = P1|->2 & P1_3 = P1|->3 & P1_4 = P1|->4 & P1_5 = P1|->5 & P1_6 = P1|->6 & P1_7 = P1|->7 & B90 = P1|->0 & B91 = P1|->1 & B92 = P1|->2 & B93 = P1|->3 & B94 = P1|->4 & B95 = P1|->5 & B96 = P1|->6 & B97 = P1|->7 & P2 = 160 & P2_0: BIT_ADDRESS & P2_1: BIT_ADDRESS & P2_2: BIT_ADDRESS & P2_3: BIT_ADDRESS & P2_4: BIT_ADDRESS & P2_5: BIT_ADDRESS & P2_6: BIT_ADDRESS & P2_7: BIT_ADDRESS & BA0: BIT_ADDRESS & BA1: BIT_ADDRESS & BA2: BIT_ADDRESS & BA3: BIT_ADDRESS & BA4: BIT_ADDRESS & BA5: BIT_ADDRESS & BA6: BIT_ADDRESS & BA7: BIT_ADDRESS & P2_0 = P2|->0 & P2_1 = P2|->1 & P2_2 = P2|->2 & P2_3 = P2|->3 & P2_4 = P2|->4 & P2_5 = P2|->5 & P2_6 = P2|->6 & P2_7 = P2|->7 & BA0 = P2|->0 & BA1 = P2|->1 & BA2 = P2|->2 & BA3 = P2|->3 & BA4 = P2|->4 & BA5 = P2|->5 & BA6 = P2|->6 & BA7 = P2|->7 & P3 = 176 & P3_0: BIT_ADDRESS & P3_1: BIT_ADDRESS & P3_2: BIT_ADDRESS & P3_3: BIT_ADDRESS & P3_4: BIT_ADDRESS & P3_5: BIT_ADDRESS & P3_6: BIT_ADDRESS & P3_7: BIT_ADDRESS & BB0: BIT_ADDRESS & BB1: BIT_ADDRESS & BB2: BIT_ADDRESS & BB3: BIT_ADDRESS & BB4: BIT_ADDRESS & BB5: BIT_ADDRESS & BB6: BIT_ADDRESS & BB7: BIT_ADDRESS & P3_0 = P3|->0 & P3_1 = P3|->1 & P3_2 = P3|->2 & P3_3 = P3|->3 & P3_4 = P3|->4 & P3_5 = P3|->5 & P3_6 = P3|->6 & P3_7 = P3|->7 & BB0 = P3|->0 & BB1 = P3|->1 & BB2 = P3|->2 & BB3 = P3|->3 & BB4 = P3|->4 & BB5 = P3|->5 & BB6 = P3|->6 & BB7 = P3|->7 & SCON = 152 & B98: BIT_ADDRESS & B99: BIT_ADDRESS & B9A: BIT_ADDRESS & B9B: BIT_ADDRESS & B9C: BIT_ADDRESS & B9D: BIT_ADDRESS & B9E: BIT_ADDRESS & B9F: BIT_ADDRESS & B98 = SCON|->0 & B99 = SCON|->1 & B9A = SCON|->2 & B9B = SCON|->3 & B9C = SCON|->4 & B9D = SCON|->5 & B9E = SCON|->6 & B9F = SCON|->7 & SCON_0: BIT_ADDRESS & SCON_1: BIT_ADDRESS & SCON_2: BIT_ADDRESS & SCON_3: BIT_ADDRESS & SCON_4: BIT_ADDRESS & SCON_5: BIT_ADDRESS & SCON_6: BIT_ADDRESS & SCON_7: BIT_ADDRESS & SCON_0 = SCON|->0 & SCON_1 = SCON|->1 & SCON_2 = SCON|->2 & SCON_3 = SCON|->3 & SCON_4 = SCON|->4 & SCON_5 = SCON|->5 & SCON_6 = SCON|->6 & SCON_7 = SCON|->7 & RI: BIT_ADDRESS & TI: BIT_ADDRESS & RB8: BIT_ADDRESS & TB8: BIT_ADDRESS & REN: BIT_ADDRESS & SM2: BIT_ADDRESS & SM1: BIT_ADDRESS & SM0: BIT_ADDRESS & RI = SCON|->0 & TI = SCON|->1 & RB8 = SCON|->2 & TB8 = SCON|->3 & REN = SCON|->4 & SM2 = SCON|->5 & SM1 = SCON|->6 & SM0 = SCON|->7 & PSW = 208 & BD0: BIT_ADDRESS & BD1: BIT_ADDRESS & BD2: BIT_ADDRESS & BD3: BIT_ADDRESS & BD4: BIT_ADDRESS & BD5: BIT_ADDRESS & BD6: BIT_ADDRESS & BD7: BIT_ADDRESS & BD0 = PSW|->0 & BD1 = PSW|->1 & BD2 = PSW|->2 & BD3 = PSW|->3 & BD4 = PSW|->4 & BD5 = PSW|->5 & BD6 = PSW|->6 & BD7 = PSW|->7 & PSW_0: BIT_ADDRESS & PSW_1: BIT_ADDRESS & PSW_2: BIT_ADDRESS & PSW_3: BIT_ADDRESS & PSW_4: BIT_ADDRESS & PSW_5: BIT_ADDRESS & PSW_6: BIT_ADDRESS & PSW_7: BIT_ADDRESS & PSW_0 = PSW|->0 & PSW_1 = PSW|->1 & PSW_2 = PSW|->2 & PSW_3 = PSW|->3 & PSW_4 = PSW|->4 & PSW_5 = PSW|->5 & PSW_6 = PSW|->6 & PSW_7 = PSW|->7 & PP: BIT_ADDRESS & OV: BIT_ADDRESS & RS0: BIT_ADDRESS & RS1: BIT_ADDRESS & F0: BIT_ADDRESS & AC: BIT_ADDRESS & CY: BIT_ADDRESS & CC: BIT_ADDRESS & PP = PSW|->0 & OV = PSW|->2 & RS0 = PSW|->3 & RS1 = PSW|->4 & F0 = PSW|->5 & AC = PSW|->6 & CY = PSW|->7 & CC = PSW|->7 & INSTRUCTION_INCREMENT: INSTRUCTION*INSTRUCTION +-> INSTRUCTION & dom(INSTRUCTION_INCREMENT) = INSTRUCTION*INSTRUCTION & INSTRUCTION_INCREMENT = %(ii,jj).(ii: INSTRUCTION & jj: INSTRUCTION | (ii+jj) mod INSTRUCTION_MAX) & ADDRCHANGE: MEM_ADDR*BYTE*BYTE +-> (MEM_ADDR +-> BYTE) & dom(ADDRCHANGE) = MEM_ADDR*BYTE*BYTE & ADDRCHANGE = %(addr,data,psw).(addr: MEM_ADDR & data: BYTE & psw: BYTE & addr = ACC | {addr|->data}\/{PSW|->BYTE_SET_BIT(psw,0,BYTE_PAR(data))}) & ADDRCHANGE = %(addr,data,psw).(addr: MEM_ADDR & data: BYTE & psw: BYTE & not(addr = ACC) & not(addr = PSW) | {addr|->data}) & BITCHANGE: MEM_ADDR*BYTE*BYTE_INDEX*BIT*BYTE +-> (MEM_ADDR +-> BYTE) & dom(BITCHANGE) = MEM_ADDR*BYTE*BYTE_INDEX*BIT*BYTE & BITCHANGE = %(addr,data,ind,bit,psw).(addr: MEM_ADDR & data: BYTE & ind: BYTE_INDEX & bit: BIT & psw: BYTE & addr = ACC | ADDRCHANGE(addr,BYTE_SET_BIT(data,ind,bit),psw)) & BITCHANGE = %(addr,data,ind,bit,psw).(addr: MEM_ADDR & data: BYTE & ind: BYTE_INDEX & bit: BIT & psw: BYTE & not(addr = ACC) | {addr|->BYTE_SET_BIT(data,ind,bit)}) & "`Included,imported and extended machines invariants'" & mem: MEM_ADDR +-> BYTE & mem(PSW)(0) = BYTE_PAR(mem(ACC)) & "`Included,imported and extended machines assertions'" & not(ACC: RAM_ADDR) & RAM_ADDR: POW(MEM_ADDR) & SFR_ADDR: POW(MEM_ADDR) & RAM_ADDR\/SFR_ADDR = MEM_ADDR & "`Seen and used machines assertions'" & dom(parity) = BYTE & ran(parity): POW(BIT) & dom(add) = UCHAR*UCHAR*UCHAR & ran(add): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(sub) = UCHAR*UCHAR*UCHAR & ran(sub): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & dom(rotateleft) = BYTE & ran(rotateleft): POW(BYTE) & dom(rotateright) = BYTE & ran(rotateright): POW(BYTE) & bool_to_bit(FALSE) = 0 & bool_to_bit(TRUE) = 1 & !bb.(bb: BIT => bit_xor(bb,bb) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(bit_xor(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_xor(b1,b2) = bit_xor(b2,b1)) & bit_xor(1,1) = 0 & bit_xor(1,0) = 1 & bit_xor(0,1) = 1 & bit_xor(0,0) = 0 & !b1.(b1: BIT => bit_or(b1,0) = b1) & !b1.(b1: BIT => bit_or(b1,1) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_or(b1,bit_or(b2,b3)) = bit_or(bit_or(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_or(b1,b2) = bit_or(b2,b1)) & bit_or(1,1) = 1 & bit_or(1,0) = 0 & bit_or(0,1) = 0 & bit_or(0,0) = 0 & !b1.(b1: BIT => bit_and(b1,0) = 0) & !b1.(b1: BIT => bit_and(b1,1) = b1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_and(b1,bit_and(b2,b3)) = bit_and(bit_and(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_and(b1,b2) = bit_and(b2,b1)) & bit_and(1,1) = 1 & bit_and(1,0) = 0 & bit_and(0,1) = 0 & bit_and(0,0) = 0 & !bb.(bb: BIT => bit_not(bit_not(bb)) = bb) & bit_not(1) = 0 & bit_not(0) = 1 & dom(byte_schar) = BYTE & ran(byte_schar): POW(SCHAR) & dom(schar_byte) = SCHAR & ran(schar_byte): POW(BYTE) & dom(byte_uchar) = BYTE & ran(byte_uchar): POW(UCHAR) & dom(uchar_byte) = UCHAR & ran(uchar_byte): POW(BYTE) & dom(uchar_schar) = UCHAR & ran(uchar_schar): POW(SCHAR) & dom(schar_uchar) = SCHAR & ran(schar_uchar): POW(UCHAR));
  ("`Local hypotheses'" & mem$0: MEM_ADDR +-> BYTE & dom(mem$0) = MEM_ADDR & ran(mem$0) = BYTE & mem$0(PSW)(0) = BYTE_PAR(mem$0(ACC)));
  "`Check that the invariant (pc: INSTRUCTION) is established by the initialisation - ref 3.3'";
  (0: INSTRUCTION);
  ("`Component invariant'" & pc: INSTRUCTION);
  "`Check that the invariant (pc: INSTRUCTION) is preserved by the operation - ref 3.4'";
  ("`CJNE preconditions in this component'" & addr: MEM_ADDR & data: UCHAR & jump: INSTRUCTION);
  ("`Local hypotheses'" & not(mem(addr) = uchar_byte(data)) & byte_uchar(mem(addr))+1<=data & addr$0: MEM_ADDR & ind$0: BYTE_INDEX & addr$0,ind$0 = CY & mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,1,mem(PSW)): MEM_ADDR +-> BYTE & (mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,1,mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,1,mem(PSW)))(ACC)));
  (INSTRUCTION_INCREMENT(pc,jump+1): INSTRUCTION);
  ("`Local hypotheses'" & not(mem(addr) = uchar_byte(data)) & not(byte_uchar(mem(addr))+1<=data) & addr$0: MEM_ADDR & ind$0: BYTE_INDEX & addr$0,ind$0 = CY & mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,0,mem(PSW)): MEM_ADDR +-> BYTE & (mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,0,mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,0,mem(PSW)))(ACC)));
  ("`Local hypotheses'" & mem(addr) = uchar_byte(data));
  (INSTRUCTION_INCREMENT(pc,1): INSTRUCTION);
  ("`CJNEI preconditions in this component'" & Rn: RAM_ADDR & (Rn = R1 or Rn = R2) & data: UCHAR & jump: INSTRUCTION & byte_uchar(mem(Rn)): RAM_ADDR);
  ("`Local hypotheses'" & addr: RAM_ADDR & addr = byte_uchar(mem(Rn)) & not(mem(addr) = uchar_byte(data)) & byte_uchar(mem(addr))+1<=data & addr$0: MEM_ADDR & ind$0: BYTE_INDEX & addr$0,ind$0 = CY & mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,1,mem(PSW)): MEM_ADDR +-> BYTE & (mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,1,mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,1,mem(PSW)))(ACC)));
  ("`Local hypotheses'" & addr: RAM_ADDR & addr = byte_uchar(mem(Rn)) & not(mem(addr) = uchar_byte(data)) & not(byte_uchar(mem(addr))+1<=data) & addr$0: MEM_ADDR & ind$0: BYTE_INDEX & addr$0,ind$0 = CY & mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,0,mem(PSW)): MEM_ADDR +-> BYTE & (mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,0,mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+BITCHANGE(addr$0,mem(addr$0),ind$0,0,mem(PSW)))(ACC)));
  ("`Local hypotheses'" & addr: RAM_ADDR & addr = byte_uchar(mem(Rn)) & mem(addr) = uchar_byte(data));
  ("`CJNEM preconditions in this component'" & dest: MEM_ADDR & dest = ACC & src: MEM_ADDR & jump: INSTRUCTION);
  ("`Local hypotheses'" & not(mem(dest) = mem(src)) & byte_uchar(mem(dest))+1<=byte_uchar(mem(src)) & addr: MEM_ADDR & ind: BYTE_INDEX & addr,ind = CY & mem<+BITCHANGE(addr,mem(addr),ind,1,mem(PSW)): MEM_ADDR +-> BYTE & (mem<+BITCHANGE(addr,mem(addr),ind,1,mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+BITCHANGE(addr,mem(addr),ind,1,mem(PSW)))(ACC)));
  ("`Local hypotheses'" & not(mem(dest) = mem(src)) & not(byte_uchar(mem(dest))+1<=byte_uchar(mem(src))) & addr: MEM_ADDR & ind: BYTE_INDEX & addr,ind = CY & mem<+BITCHANGE(addr,mem(addr),ind,0,mem(PSW)): MEM_ADDR +-> BYTE & (mem<+BITCHANGE(addr,mem(addr),ind,0,mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+BITCHANGE(addr,mem(addr),ind,0,mem(PSW)))(ACC)));
  ("`Local hypotheses'" & mem(dest) = mem(src));
  ("`SJMP preconditions in this component'" & jump: INSTRUCTION);
  ("`AJMP preconditions in this component'" & jump: INSTRUCTION);
  ("`MOV preconditions in this component'" & dest: MEM_ADDR & data: UCHAR);
  "`Check preconditions of called operation, or While loop construction, or Assert predicates'";
  (uchar_byte(data): BYTE);
  ("`Local hypotheses'" & ADDRCHANGE(dest,uchar_byte(data),mem(PSW)): MEM_ADDR +-> BYTE & ADDRCHANGE(dest,uchar_byte(data),mem(PSW))(PSW)(0) = BYTE_PAR(ADDRCHANGE(dest,uchar_byte(data),mem(PSW))(ACC)));
  ("`MOVI preconditions in this component'" & Rn: RAM_ADDR & (Rn = R1 or Rn = R2) & data: UCHAR & byte_uchar(mem(Rn)): RAM_ADDR);
  ("`Local hypotheses'" & addr: RAM_ADDR & addr = byte_uchar(mem(Rn)) & mem<+ADDRCHANGE(addr,uchar_byte(data),mem(PSW)): MEM_ADDR +-> BYTE & (mem<+ADDRCHANGE(addr,uchar_byte(data),mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+ADDRCHANGE(addr,uchar_byte(data),mem(PSW)))(ACC)));
  ("`MOVM preconditions in this component'" & src: MEM_ADDR & dest: MEM_ADDR);
  (mem(src): BYTE);
  ("`Local hypotheses'" & ADDRCHANGE(dest,mem(src),mem(PSW)): MEM_ADDR +-> BYTE & ADDRCHANGE(dest,mem(src),mem(PSW))(PSW)(0) = BYTE_PAR(ADDRCHANGE(dest,mem(src),mem(PSW))(ACC)));
  ("`MOVMI preconditions in this component'" & dest: MEM_ADDR & Rn: RAM_ADDR & (Rn = R1 or Rn = R0) & byte_uchar(mem(Rn)): RAM_ADDR);
  ("`Local hypotheses'" & src: RAM_ADDR & src = byte_uchar(mem(Rn)));
  ("`Local hypotheses'" & src: RAM_ADDR & src = byte_uchar(mem(Rn)) & ADDRCHANGE(dest,mem(src),mem(PSW)): MEM_ADDR +-> BYTE & ADDRCHANGE(dest,mem(src),mem(PSW))(PSW)(0) = BYTE_PAR(ADDRCHANGE(dest,mem(src),mem(PSW))(ACC)));
  ("`MOVIM preconditions in this component'" & Rn: RAM_ADDR & src: MEM_ADDR & (Rn = R1 or Rn = R2) & byte_uchar(mem(Rn)): RAM_ADDR);
  ("`Local hypotheses'" & addr: RAM_ADDR & addr = byte_uchar(mem(Rn)) & mem<+ADDRCHANGE(addr,mem(src),mem(PSW)): MEM_ADDR +-> BYTE & (mem<+ADDRCHANGE(addr,mem(src),mem(PSW)))(PSW)(0) = BYTE_PAR((mem<+ADDRCHANGE(addr,mem(src),mem(PSW)))(ACC)))
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
