THEORY ProofList IS
  _f(1) & _f(2) & _f(8) & _f(30) & _f(83) & decrement_sp.3,(_f(36) => _f(86));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(83) & decrement_sp.2,(_f(33) => _f(85));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(83) & decrement_sp.1,(_f(33) => _f(84));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(77) & update_div.3,(_f(81) => _f(82));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(77) & update_div.2,(_f(78) => _f(80));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(77) & update_div.1,(_f(78) => _f(79));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(73) & update.3,(_f(36) => _f(76));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(73) & update.2,(_f(33) => _f(75));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(73) & update.1,(_f(33) => _f(74));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(64) & pop.6,(_f(69) & _f(36) => _f(72));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(64) & pop.5,(_f(69) & _f(33) => _f(71));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(64) & pop.4,(_f(69) & _f(33) => _f(70));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(64) & pop.3,(_f(65) & _f(36) => _f(68));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(64) & pop.2,(_f(65) & _f(33) => _f(67));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(64) & pop.1,(_f(65) & _f(33) => _f(66));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(60) & push.3,(_f(36) => _f(63));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(60) & push.2,(_f(33) => _f(62));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(60) & push.1,(_f(33) => _f(61));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(56) & push_two.3,(_f(36) => _f(59));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(56) & push_two.2,(_f(33) => _f(58));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(56) & push_two.1,(_f(33) => _f(57));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(53) & addrSetIndirect.6,(_f(55) & _f(36) => _f(46));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(53) & addrSetIndirect.5,(_f(55) & _f(33) => _f(45));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(53) & addrSetIndirect.4,(_f(55) & _f(33) => _f(44));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(53) & addrSetIndirect.3,(_f(54) & _f(36) => _f(42));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(53) & addrSetIndirect.2,(_f(54) & _f(33) => _f(41));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(53) & addrSetIndirect.1,(_f(54) & _f(33) => _f(40));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(50) & addrSetDirect.6,(_f(52) & _f(36) => _f(46));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(50) & addrSetDirect.5,(_f(52) & _f(33) => _f(45));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(50) & addrSetDirect.4,(_f(52) & _f(33) => _f(44));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(50) & addrSetDirect.3,(_f(51) & _f(36) => _f(42));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(50) & addrSetDirect.2,(_f(51) & _f(33) => _f(41));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(50) & addrSetDirect.1,(_f(51) & _f(33) => _f(40));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(47) & bitClear.6,(_f(49) & _f(36) => _f(46));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(47) & bitClear.5,(_f(49) & _f(33) => _f(45));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(47) & bitClear.4,(_f(49) & _f(33) => _f(44));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(47) & bitClear.3,(_f(48) & _f(36) => _f(42));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(47) & bitClear.2,(_f(48) & _f(33) => _f(41));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(47) & bitClear.1,(_f(48) & _f(33) => _f(40));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(38) & bitSet.6,(_f(43) & _f(36) => _f(46));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(38) & bitSet.5,(_f(43) & _f(33) => _f(45));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(38) & bitSet.4,(_f(43) & _f(33) => _f(44));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(38) & bitSet.3,(_f(39) & _f(36) => _f(42));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(38) & bitSet.2,(_f(39) & _f(33) => _f(41));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(38) & bitSet.1,(_f(39) & _f(33) => _f(40));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(31) & exChange.3,(_f(32) & _f(36) => _f(37));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(31) & exChange.2,(_f(32) & _f(33) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(30) & _f(31) & exChange.1,(_f(32) & _f(33) => _f(34));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.9,(_f(28) => _f(29));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.8,(_f(26) => _f(27));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.7,(_f(24) => _f(25));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.6,(_f(22) => _f(23));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.5,(_f(20) => _f(21));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.4,(_f(18) & _f(16) => _f(19));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.3,(_f(15) & _f(16) => _f(17));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.2,(_f(12) & _f(13) => _f(14));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.1,(_f(9) & _f(10) => _f(11));
  _f(1) & _f(2) & Initialisation.3,(_f(6) => _f(7));
  _f(1) & _f(2) & Initialisation.2,(_f(3) => _f(5));
  _f(1) & _f(2) & Initialisation.1,(_f(3) => _f(4))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & BYTE_WIDTH = 8 & BYTE_INDEX = 0..BYTE_WIDTH-1 & BYTE = SET(bt).(bt: BYTE_INDEX +-> BIT & dom(bt) = BYTE_INDEX & size(bt) = BYTE_WIDTH)-{{}} & BYTE_ZERO: BYTE & BYTE_ZERO = BYTE_INDEX*{0} & BIT = 0..1 & bit_not: BIT +-> BIT & dom(bit_not) = BIT & !bb.(bb: BIT => bit_not(bb) = 1-bb) & bit_and: BIT*BIT +-> BIT & dom(bit_and) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_and(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_and(b1,b2) = 1) & b2 = 1) & bit_or: BIT*BIT +-> BIT & dom(bit_or) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_or(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_or(b1,b2) = 1) or b2 = 1) & bit_xor: BIT*BIT +-> BIT & dom(bit_xor) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_xor(b1,b2) = 1 => not(b1 = b2)) & (not(b1 = b2) => bit_xor(b1,b2) = 1)) & bool_to_bit: BOOL +-> BIT & dom(bool_to_bit) = BOOL & bool_to_bit = {TRUE|->1}\/{FALSE|->0} & UCHAR_MAX: INTEGER & 0<=UCHAR_MAX & UCHAR_MAX = 2**BYTE_WIDTH-1 & UCHAR = 0..UCHAR_MAX & SCHAR_MAX: INTEGER & SCHAR_MIN: INTEGER & SCHAR_MAX = 2**(BYTE_WIDTH-1)-1 & SCHAR_MIN = -(2**(BYTE_WIDTH-1)) & SCHAR = SCHAR_MIN..SCHAR_MAX & USHORT_INT_MAX: INTEGER & USHORT_INT_MAX = 2**(2*BYTE_WIDTH)-1 & USHORT_INT = 0..USHORT_INT_MAX & byte_uchar: BYTE +-> UCHAR & dom(byte_uchar) = BYTE & byte_uchar = %bv.(bv: BYTE | bv_to_nat(bv)) & uchar_byte = byte_uchar~ & byte_schar: BYTE +-> SCHAR & dom(byte_schar) = BYTE & byte_schar = %bv.(bv: BYTE | (-bv(7))*128+bv(6)*64+bv(5)*32+bv(4)*16+bv(3)*8+bv(2)*4+bv(1)*2+bv(0)*1) & schar_byte = byte_schar~ & uchar_schar: UCHAR +-> SCHAR & dom(uchar_schar) = UCHAR & uchar_schar = %v1.(v1: UCHAR & v1<=SCHAR_MAX | v1)\/%v1.(v1: UCHAR & not(v1<=SCHAR_MAX) | v1-UCHAR_MAX) & schar_uchar = uchar_schar~ & bv16_usint: BV16 +-> USHORT_INT & dom(bv16_usint) = BV16 & bv16_usint = %v0.(v0: BV16 | 32768*v0(15)+16384*v0(14)+8192*v0(13)+4096*v0(12)+2048*v0(11)+1024*v0(10)+512*v0(9)+256*v0(8)+128*v0(7)+64*v0(6)+32*v0(5)+16*v0(4)+8*v0(3)+4*v0(2)+2*v0(1)+v0(0)) & usint_bv16 = bv16_usint~ & BIT_VECTOR = SET(bt).(bt: NATURAL +-> BIT)-{{}} & bv_size: BIT_VECTOR +-> NATURAL-{0} & dom(bv_size) = BIT_VECTOR & bv_size = %bv.(bv: BIT_VECTOR | size(bv)) & BV_INDX: BIT_VECTOR +-> POW(NATURAL) & dom(BV_INDX) = BIT_VECTOR & BV_INDX = %bv.(bv: BIT_VECTOR | 0..bv_size(bv)-1) & bv_catenate: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_catenate) = BIT_VECTOR*BIT_VECTOR & bv_catenate = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR | v1^v2) & bv_sub: BIT_VECTOR*NATURAL*NATURAL +-> BIT_VECTOR & dom(bv_sub) = BIT_VECTOR*NATURAL*NATURAL & bv_sub = %(bv,low,high).(bv: BIT_VECTOR & low: BV_INDX(bv) & high: BV_INDX(bv) & low<=high | low..high<|bv) & bv_zero: NATURAL-{0} +-> BIT_VECTOR & dom(bv_zero) = NATURAL-{0} & bv_zero = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (0..sz)*{0}) & bv_one: NATURAL-{0} +-> BIT_VECTOR & dom(bv_one) = NATURAL-{0} & bv_one = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (0..sz)*{1}) & bv_not: BIT_VECTOR +-> BIT_VECTOR & dom(bv_not) = BIT_VECTOR & bv_not = %v1.(v1: BIT_VECTOR | %idx.(idx: BV_INDX(v1) | bit_not(v1(idx)))) & bv_and: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_and) = BIT_VECTOR*BIT_VECTOR & bv_and = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: BV_INDX(v1) | bit_and(v1(idx),v2(idx)))) & bv_or: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_or) = BIT_VECTOR*BIT_VECTOR & bv_or = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: BV_INDX(v1) | bit_or(v1(idx),v2(idx)))) & bv_xor: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_xor) = BIT_VECTOR*BIT_VECTOR & bv_xor = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: BV_INDX(v1) | bit_xor(v1(idx),v2(idx)))) & bv_at: BIT_VECTOR*NATURAL +-> BIT & dom(bv_at) = BIT_VECTOR*NATURAL & bv_at = %(v1,idx).(v1: BIT_VECTOR & idx: BV_INDX(v1) | v1(idx)) & bv_set: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_set) = BIT_VECTOR*NATURAL & bv_set = %(v1,idx).(v1: BIT_VECTOR & idx: BV_INDX(v1) | v1<+{idx|->1}) & bv_clear: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_clear) = BIT_VECTOR*NATURAL & bv_clear = %(v1,idx).(v1: BIT_VECTOR & idx: BV_INDX(v1) | v1<+{idx|->0}) & bv_put: BIT_VECTOR*NATURAL*BIT +-> BIT_VECTOR & dom(bv_put) = BIT_VECTOR*NATURAL*BIT & bv_put = %(v1,idx,bit).(v1: BIT_VECTOR & idx: BV_INDX(v1) & bit: BIT | v1<+{idx|->bit}) & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv_par = %bv.(bv: BIT_VECTOR | size(bv|>{1}) mod 2) & BV16_WIDTH: INTEGER & 0<=BV16_WIDTH & BV16_WIDTH = 16 & BV16_INDX = 0..BV16_WIDTH-1 & BV16 = SET(bt).(bt: BV16_INDX +-> BIT & dom(bt) = BV16_INDX & size(bt) = 16)-{{}} & BV16_ZERO = BV16_INDX*{0} & bv16_byte: BV16 +-> BYTE*BYTE & dom(bv16_byte) = BV16 & bv16_byte = %bv.(bv: BV16 | {0|->bv(8)}\/{1|->bv(9)}\/{2|->bv(10)}\/{3|->bv(11)}\/{4|->bv(12)}\/{5|->bv(13)}\/{6|->bv(14)}\/{7|->bv(15)},{0|->bv(0)}\/{1|->bv(1)}\/{2|->bv(2)}\/{3|->bv(3)}\/{4|->bv(4)}\/{5|->bv(5)}\/{6|->bv(6)}\/{7|->bv(7)}) & byte_bv16 = bv16_byte~ & parity: BYTE +-> BIT & dom(parity) = BYTE & parity = %bv.(bv: BYTE | bv_par(bv)) & half: UCHAR +-> UCHAR & dom(half) = UCHAR & half = %v1.(v1: UCHAR | v1 mod 2**4) & usint_byte: USHORT_INT +-> BYTE*BYTE & dom(usint_byte) = USHORT_INT & usint_byte = %usint.(usint: USHORT_INT | bv16_byte(usint_bv16(usint))) & add: UCHAR*UCHAR*BIT +-> UCHAR*BIT*BIT*BIT*BIT & dom(add) = UCHAR*UCHAR*BIT & add = %(v1,v2,ca).(v1: UCHAR & v2: UCHAR & ca: UCHAR | (v1+v2+ca) mod (UCHAR_MAX+1),parity(uchar_byte((v1+v2+ca) mod (UCHAR_MAX+1))),bool_to_bit(bool(not(uchar_schar(v1)+uchar_schar(v2)+ca: SCHAR))),bool_to_bit(bool(2**4<=half(v1)+half(v2)+ca)),bool_to_bit(bool(not(v1+v2+ca: UCHAR)))) & sub: UCHAR*UCHAR*UCHAR +-> UCHAR*BIT*BIT*BIT*BIT & dom(sub) = UCHAR*UCHAR*UCHAR & sub = %(v1,v2,ca).(v1: UCHAR & v2: UCHAR & ca: UCHAR | bool_to_bit(bool(v1+1<=v2+ca))*256+v1-v2-ca,parity(uchar_byte(bool_to_bit(bool(v1+1<=v2+ca))*256+v1-v2-ca)),bool_to_bit(bool(not(uchar_schar(v1)-uchar_schar(v2)-ca: SCHAR))),bool_to_bit(bool(half(v1)+1<=half(v2)+ca)),bool_to_bit(bool(not(v1-v2-ca: UCHAR)))) & div: UCHAR*UCHAR +-> UCHAR*UCHAR*BIT*BIT & dom(div) = UCHAR*UCHAR & div = %(aa,bb).(aa: UCHAR & bb: UCHAR | aa/bb,aa mod bb,bool_to_bit(bool(bb = 0)),parity(uchar_byte(aa/bb))) & mult: UCHAR*UCHAR +-> BYTE*BYTE*BIT & dom(mult) = UCHAR*UCHAR & mult = %(aa,bb).(aa: UCHAR & bb: UCHAR | usint_byte(aa*bb),bool_to_bit(bool(256<=bb*aa))) & and: BYTE*BYTE +-> BYTE & dom(and) = BYTE*BYTE & and = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | bv_and(bt1,bt2)) & and_bit: BIT*BIT +-> BIT & dom(and_bit) = BIT*BIT & and_bit = %(b1,b2).(b1: BIT & b2: BIT | bit_and(b1,b2)) & ior: BYTE*BYTE +-> BYTE & dom(ior) = BYTE*BYTE & ior = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | bv_or(bt1,bt2)) & xor: BYTE*BYTE +-> BYTE & dom(xor) = BYTE*BYTE & xor = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | bv_xor(bt1,bt2)) & complement: BYTE +-> BYTE & dom(complement) = BYTE & complement = %bt.(bt: BYTE | bv_not(bt)) & swap: BYTE +-> BYTE & dom(swap) = BYTE & swap = %bt.(bt: BYTE | {0|->bt(4)}\/{1|->bt(5)}\/{2|->bt(6)}\/{3|->bt(7)}\/{4|->bt(0)}\/{5|->bt(1)}\/{6|->bt(2)}\/{7|->bt(3)}) & rotateleft: BYTE +-> BYTE & dom(rotateleft) = BYTE & rotateleft = %bv.(bv: BYTE | {0|->bv(7)}\/{1|->bv(0)}\/{2|->bv(1)}\/{3|->bv(2)}\/{4|->bv(3)}\/{5|->bv(4)}\/{6|->bv(5)}\/{7|->bv(6)}) & rotateright: BYTE +-> BYTE & dom(rotateright) = BYTE & rotateright = %bv.(bv: BYTE | {0|->bv(1)}\/{1|->bv(2)}\/{2|->bv(3)}\/{3|->bv(4)}\/{4|->bv(5)}\/{5|->bv(6)}\/{6|->bv(7)}\/{7|->bv(0)}) & bit_put: BYTE*BYTE_INDEX*BIT +-> BYTE & dom(bit_put) = BYTE*BYTE_INDEX*BIT & bit_put = %(byte,ind,bit).(byte: BYTE & ind: BYTE_INDEX & bit: BIT | bv_put(byte,ind,bit)) & "`Component properties'" & ROM_LENGTH = 4 & ROM_ADDR_MAX = ROM_LENGTH*2**10 & ROM_ADDR = 0..ROM_ADDR_MAX & MEM_ADDR = UCHAR & RAM_MIN: UCHAR & RAM_MAX: UCHAR & RAM_MIN = 0 & RAM_MAX = 127 & RAM_ADDR = RAM_MIN..RAM_MAX & RAM_BIT_ADDRESSABLE = 32..47 & R0: RAM_ADDR & R1: RAM_ADDR & R2: RAM_ADDR & R3: RAM_ADDR & R4: RAM_ADDR & R5: RAM_ADDR & R6: RAM_ADDR & R7: RAM_ADDR & R0 = 0 & R1 = 1 & R2 = 2 & R3 = 3 & R4 = 4 & R5 = 5 & R6 = 6 & R7 = 7 & SFR_MIN: UCHAR & SFR_MAX: UCHAR & SFR_MIN = RAM_MAX+1 & SFR_MAX = UCHAR_MAX & SFR_ADDR = SFR_MIN..SFR_MAX & SFR_BIT_ADDRESSABLE = SET(ba).(ba: SFR_ADDR & 128<=ba & ba<=240 & ba mod 8 = 0) & BIT_ADDRESS = MEM_ADDR*BYTE_INDEX & SBUF: SFR_ADDR & SP: SFR_ADDR & PCON: SFR_ADDR & SBUF = 153 & SP = 109 & PCON = 135 & BB: SFR_ADDR & BB = 240 & BF0: BIT_ADDRESS & BF1: BIT_ADDRESS & BF2: BIT_ADDRESS & BF3: BIT_ADDRESS & BF4: BIT_ADDRESS & BF5: BIT_ADDRESS & BF6: BIT_ADDRESS & BF7: BIT_ADDRESS & BF0 = BB|->0 & BF1 = BB|->1 & BF2 = BB|->2 & BF3 = BB|->3 & BF4 = BB|->4 & BF5 = BB|->5 & BF6 = BB|->6 & BF7 = BB|->7 & AA: SFR_ADDR & AA = 224 & ACC: SFR_ADDR & ACC = AA & BE0: BIT_ADDRESS & BE1: BIT_ADDRESS & BE2: BIT_ADDRESS & BE3: BIT_ADDRESS & BE4: BIT_ADDRESS & BE5: BIT_ADDRESS & BE6: BIT_ADDRESS & BE7: BIT_ADDRESS & BE0 = ACC|->0 & BE1 = ACC|->1 & BE2 = ACC|->2 & BE3 = ACC|->3 & BE4 = ACC|->4 & BE5 = ACC|->5 & BE6 = ACC|->6 & BE7 = ACC|->7 & P0: SFR_ADDR & P0 = 128 & P0_0: BIT_ADDRESS & P0_1: BIT_ADDRESS & P0_2: BIT_ADDRESS & P0_3: BIT_ADDRESS & P0_4: BIT_ADDRESS & P0_5: BIT_ADDRESS & P0_6: BIT_ADDRESS & P0_7: BIT_ADDRESS & B80: BIT_ADDRESS & B81: BIT_ADDRESS & B82: BIT_ADDRESS & B83: BIT_ADDRESS & B84: BIT_ADDRESS & B85: BIT_ADDRESS & B86: BIT_ADDRESS & B87: BIT_ADDRESS & P0_0 = P0|->0 & P0_1 = P0|->1 & P0_2 = P0|->2 & P0_3 = P0|->3 & P0_4 = P0|->4 & P0_5 = P0|->5 & P0_6 = P0|->6 & P0_7 = P0|->7 & B80 = P0|->0 & B81 = P0|->1 & B82 = P0|->2 & B83 = P0|->3 & B84 = P0|->4 & B85 = P0|->5 & B86 = P0|->6 & B87 = P0|->7 & P1: SFR_ADDR & P1 = 144 & P1_0: BIT_ADDRESS & P1_1: BIT_ADDRESS & P1_2: BIT_ADDRESS & P1_3: BIT_ADDRESS & P1_4: BIT_ADDRESS & P1_5: BIT_ADDRESS & P1_6: BIT_ADDRESS & P1_7: BIT_ADDRESS & B90: BIT_ADDRESS & B91: BIT_ADDRESS & B92: BIT_ADDRESS & B93: BIT_ADDRESS & B94: BIT_ADDRESS & B95: BIT_ADDRESS & B96: BIT_ADDRESS & B97: BIT_ADDRESS & P1_0 = P1|->0 & P1_1 = P1|->1 & P1_2 = P1|->2 & P1_3 = P1|->3 & P1_4 = P1|->4 & P1_5 = P1|->5 & P1_6 = P1|->6 & P1_7 = P1|->7 & B90 = P1|->0 & B91 = P1|->1 & B92 = P1|->2 & B93 = P1|->3 & B94 = P1|->4 & B95 = P1|->5 & B96 = P1|->6 & B97 = P1|->7 & P2: SFR_ADDR & P2 = 160 & P2_0: BIT_ADDRESS & P2_1: BIT_ADDRESS & P2_2: BIT_ADDRESS & P2_3: BIT_ADDRESS & P2_4: BIT_ADDRESS & P2_5: BIT_ADDRESS & P2_6: BIT_ADDRESS & P2_7: BIT_ADDRESS & BA0: BIT_ADDRESS & BA1: BIT_ADDRESS & BA2: BIT_ADDRESS & BA3: BIT_ADDRESS & BA4: BIT_ADDRESS & BA5: BIT_ADDRESS & BA6: BIT_ADDRESS & BA7: BIT_ADDRESS & P2_0 = P2|->0 & P2_1 = P2|->1 & P2_2 = P2|->2 & P2_3 = P2|->3 & P2_4 = P2|->4 & P2_5 = P2|->5 & P2_6 = P2|->6 & P2_7 = P2|->7 & BA0 = P2|->0 & BA1 = P2|->1 & BA2 = P2|->2 & BA3 = P2|->3 & BA4 = P2|->4 & BA5 = P2|->5 & BA6 = P2|->6 & BA7 = P2|->7 & P3: SFR_ADDR & P3 = 176 & P3_0: BIT_ADDRESS & P3_1: BIT_ADDRESS & P3_2: BIT_ADDRESS & P3_3: BIT_ADDRESS & P3_4: BIT_ADDRESS & P3_5: BIT_ADDRESS & P3_6: BIT_ADDRESS & P3_7: BIT_ADDRESS & BB0: BIT_ADDRESS & BB1: BIT_ADDRESS & BB2: BIT_ADDRESS & BB3: BIT_ADDRESS & BB4: BIT_ADDRESS & BB5: BIT_ADDRESS & BB6: BIT_ADDRESS & BB7: BIT_ADDRESS & P3_0 = P3|->0 & P3_1 = P3|->1 & P3_2 = P3|->2 & P3_3 = P3|->3 & P3_4 = P3|->4 & P3_5 = P3|->5 & P3_6 = P3|->6 & P3_7 = P3|->7 & BB0 = P3|->0 & BB1 = P3|->1 & BB2 = P3|->2 & BB3 = P3|->3 & BB4 = P3|->4 & BB5 = P3|->5 & BB6 = P3|->6 & BB7 = P3|->7 & SCON: SFR_ADDR & SCON = 152 & B98: BIT_ADDRESS & B99: BIT_ADDRESS & B9A: BIT_ADDRESS & B9B: BIT_ADDRESS & B9C: BIT_ADDRESS & B9D: BIT_ADDRESS & B9E: BIT_ADDRESS & B9F: BIT_ADDRESS & B98 = SCON|->0 & B99 = SCON|->1 & B9A = SCON|->2 & B9B = SCON|->3 & B9C = SCON|->4 & B9D = SCON|->5 & B9E = SCON|->6 & B9F = SCON|->7 & SCON_0: BIT_ADDRESS & SCON_1: BIT_ADDRESS & SCON_2: BIT_ADDRESS & SCON_3: BIT_ADDRESS & SCON_4: BIT_ADDRESS & SCON_5: BIT_ADDRESS & SCON_6: BIT_ADDRESS & SCON_7: BIT_ADDRESS & SCON_0 = SCON|->0 & SCON_1 = SCON|->1 & SCON_2 = SCON|->2 & SCON_3 = SCON|->3 & SCON_4 = SCON|->4 & SCON_5 = SCON|->5 & SCON_6 = SCON|->6 & SCON_7 = SCON|->7 & RI: BIT_ADDRESS & TI: BIT_ADDRESS & RB8: BIT_ADDRESS & TB8: BIT_ADDRESS & REN: BIT_ADDRESS & SM2: BIT_ADDRESS & SM1: BIT_ADDRESS & SM0: BIT_ADDRESS & RI = SCON|->0 & TI = SCON|->1 & RB8 = SCON|->2 & TB8 = SCON|->3 & REN = SCON|->4 & SM2 = SCON|->5 & SM1 = SCON|->6 & SM0 = SCON|->7 & PSW: SFR_ADDR & PSW = 208 & PP: BIT_ADDRESS & OV: BIT_ADDRESS & RS0: BIT_ADDRESS & RS1: BIT_ADDRESS & F0: BIT_ADDRESS & AC: BIT_ADDRESS & CY: BIT_ADDRESS & CC: BIT_ADDRESS & BD0: BIT_ADDRESS & BD1: BIT_ADDRESS & BD2: BIT_ADDRESS & BD3: BIT_ADDRESS & BD4: BIT_ADDRESS & BD5: BIT_ADDRESS & BD6: BIT_ADDRESS & BD7: BIT_ADDRESS & BD0 = PSW|->0 & BD1 = PSW|->1 & BD2 = PSW|->2 & BD3 = PSW|->3 & BD4 = PSW|->4 & BD5 = PSW|->5 & BD6 = PSW|->6 & BD7 = PSW|->7 & PSW_0: BIT_ADDRESS & PSW_1: BIT_ADDRESS & PSW_2: BIT_ADDRESS & PSW_3: BIT_ADDRESS & PSW_4: BIT_ADDRESS & PSW_5: BIT_ADDRESS & PSW_6: BIT_ADDRESS & PSW_7: BIT_ADDRESS & PSW_0 = PSW|->0 & PSW_1 = PSW|->1 & PSW_2 = PSW|->2 & PSW_3 = PSW|->3 & PSW_4 = PSW|->4 & PSW_5 = PSW|->5 & PSW_6 = PSW|->6 & PSW_7 = PSW|->7 & PP = PSW|->0 & OV = PSW|->2 & RS0 = PSW|->3 & RS1 = PSW|->4 & F0 = PSW|->5 & AC = PSW|->6 & CY = PSW|->7 & CC = PSW|->7 & STACK_MAX: RAM_ADDR & STACK_MAX = RAM_MAX & PC_INCREMENT: ROM_ADDR*ROM_ADDR +-> ROM_ADDR & dom(PC_INCREMENT) = ROM_ADDR*ROM_ADDR & PC_INCREMENT = %(ii,jj).(ii: ROM_ADDR & jj: ROM_ADDR | (ii+jj) mod (ROM_ADDR_MAX+1)) & ACC_CHANGE: BYTE*BYTE +-> (MEM_ADDR +-> BYTE) & dom(ACC_CHANGE) = BYTE*BYTE & ACC_CHANGE = %(data,psw).(data: BYTE & psw: BYTE | {ACC|->data}\/{PSW|->bit_put(psw,0,parity(data))}) & SP_INCREMENT: BYTE*RAM_ADDR +-> RAM_ADDR & dom(SP_INCREMENT) = BYTE*RAM_ADDR & SP_INCREMENT = %(sp,inc).(sp: BYTE & inc: RAM_ADDR | (byte_uchar(sp)+inc) mod STACK_MAX) & SP_DECREMENT: BYTE*RAM_ADDR +-> RAM_ADDR & dom(SP_DECREMENT) = BYTE*RAM_ADDR & SP_DECREMENT = %(sp,dec).(sp: BYTE & dec: RAM_ADDR & not(1<=byte_uchar(sp)-dec) | bool_to_bit(bool(byte_uchar(sp)-dec+1<=0))*STACK_MAX-(byte_uchar(sp)-dec)) & PSWUPDATE: BYTE*BIT*BIT*BIT*BIT +-> BYTE & dom(PSWUPDATE) = BYTE*BIT*BIT*BIT*BIT & PSWUPDATE = %(psw,Pa,Ov,Ac,Cy).(psw: BYTE & Pa: BIT & Ov: BIT & Ac: BIT & Cy: BIT | bit_put(bit_put(bit_put(bit_put(psw,0,Pa),2,Ov),6,Ac),7,Cy)) & BIT_GET: BIT_ADDRESS*(MEM_ADDR --> BYTE) +-> BIT & dom(BIT_GET) = BIT_ADDRESS*(MEM_ADDR --> BYTE) & BIT_GET = %(addr,ind,memory).(addr,ind: BIT_ADDRESS & (memory: MEM_ADDR +-> BYTE & dom(memory) = MEM_ADDR) | memory(addr)(ind)) & GET_RET: MEM_ADDR*MEM_ADDR*(MEM_ADDR --> BYTE) +-> BV16 & dom(GET_RET) = MEM_ADDR*MEM_ADDR*(MEM_ADDR --> BYTE) & GET_RET = %(addr1,addr2,mem).(addr1: RAM_ADDR & addr2: RAM_ADDR & (mem: MEM_ADDR +-> BYTE & dom(mem) = MEM_ADDR) | byte_bv16(mem(addr1),mem(addr2))));
  ("`Seen and used machines assertions'" & !bt.(bt: BYTE => size(bt) = 8) & size(BYTE_ZERO) = 8 & BYTE: POW(BIT_VECTOR) & BYTE_ZERO: BIT_VECTOR & first(BYTE_ZERO) = 0 & bit_not(0) = 1 & bit_not(1) = 0 & !bb.(bb: BIT => bit_not(bit_not(bb)) = bb) & bit_and(0,0) = 0 & bit_and(0,1) = 0 & bit_and(1,0) = 0 & bit_and(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_and(b1,b2) = bit_and(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 1 => bit_and(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 0 => bit_and(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_and(b1,bit_and(b2,b3)) = bit_and(bit_and(b1,b2),b3)) & !b1.(b1: BIT => bit_and(b1,1) = b1) & !b1.(b1: BIT => bit_and(b1,0) = 0) & bit_or(0,0) = 0 & bit_or(0,1) = 1 & bit_or(1,0) = 1 & bit_or(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_or(b1,b2) = bit_or(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 1 => bit_or(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 0 => bit_or(b2,b1) = 0) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 1 => b1 = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 0 => b1 = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_or(b1,bit_or(b2,b3)) = bit_or(bit_or(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = bit_or(1,b3)) & !b1.(b1: BIT => bit_or(b1,1) = 1) & !b1.(b1: BIT => bit_or(b1,0) = b1) & !b1.(b1: BIT => bit_or(1,b1) = 1) & !b1.(b1: BIT => bit_or(0,b1) = b1) & bit_xor(0,0) = 0 & bit_xor(0,1) = 1 & bit_xor(1,0) = 1 & bit_xor(1,1) = 0 & !(b1,b2).(b1: BIT & b2: BIT => bit_xor(b1,b2) = bit_xor(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 1 => bit_xor(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 0 => bit_xor(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(bit_xor(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(1,b3)) & !bb.(bb: BIT => bit_xor(bb,bb) = 0) & bool_to_bit(TRUE) = 1 & bool_to_bit(FALSE) = 0 & !bb.(bb: BIT => bb = 0 or bb = 1) & !bb.(bb: BIT & not(bb = 0) => bb = 1) & !bb.(bb: BIT & not(bb = 1) => bb = 0) & dom(byte_schar) = BYTE & ran(byte_schar): POW(SCHAR) & dom(schar_byte) = SCHAR & ran(schar_byte): POW(BYTE) & dom(byte_uchar) = BYTE & ran(byte_uchar): POW(UCHAR) & dom(uchar_byte) = UCHAR & ran(uchar_byte): POW(BYTE) & dom(uchar_schar) = UCHAR & ran(uchar_schar): POW(SCHAR) & dom(schar_uchar) = SCHAR & ran(schar_uchar): POW(UCHAR) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_xor(bv,bv)(indx) = bv_zero(bv_size(bv))(indx)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: BV_INDX(v1) => bv_xor(v1,v2)(indx) = bv_xor(v2,v1)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v2)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v1)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_or(bv,bv_zero(bv_size(bv)))(indx) = bv(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_or(bv,bv_one(bv_size(bv)))(indx) = bv_one(bv_size(bv))(indx)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) & indx: BV_INDX(v1) => bv_or(v1,bv_or(v2,v3))(indx) = bv_or(bv_or(v1,v2),v3)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v2)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: BV_INDX(v1) => bv_or(v1,v2)(indx) = bv_or(v2,v1)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v1)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_and(bv,bv_one(bv_size(bv)))(indx) = bv(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_and(bv,bv_zero(bv_size(bv)))(indx) = bv_zero(bv_size(bv))(indx)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) & indx: BV_INDX(v1) => bv_and(v1,bv_and(v2,v3))(indx) = bv_and(bv_and(v1,v2),v3)(indx)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: BV_INDX(v1) => bv_and(v1,v2)(indx) = bv_and(v2,v1)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_and(v1,v2)) = bv_size(v2)) & !(bv,low,high).(bv: BIT_VECTOR & low: BV_INDX(bv) & high: BV_INDX(bv) & low<=high => bv_size(bv_sub(bv,low,high)) = high-low) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR => bv_size(bv_catenate(v1,v2)) = bv_size(v1)+bv_size(v2)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_not(bv_not(bv))(indx) = bv(indx)) & !bv.(bv: BIT_VECTOR => bv_size(bv_not(bv)) = bv_size(bv)) & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_to_nat(bv_zero(ss)) = 0) & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_par(bv_zero(ss)) = 0) & 2**16 = 65536 & 2**15 = 32768 & 2**14 = 16384 & 2**13 = 8192 & 2**12 = 4096 & 2**11 = 2048 & 2**10 = 1024 & 2**9 = 512 & 2**8 = 256 & 2**7 = 128 & 2**6 = 64 & 2**5 = 32 & 2**4 = 16 & 2**3 = 8 & 2**2 = 4 & 2**1 = 2 & 2**0 = 1 & BV16_ZERO: BV16 & BV16: POW(BIT_VECTOR) & BV16_ZERO: BIT_VECTOR & dom(parity) = BYTE & ran(parity): POW(BIT) & dom(add) = UCHAR*UCHAR*UCHAR & ran(add): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(sub) = UCHAR*UCHAR*UCHAR & ran(sub): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & dom(rotateleft) = BYTE & ran(rotateleft): POW(BYTE) & dom(rotateright) = BYTE & ran(rotateright): POW(BYTE));
  "`Check that the invariant (mem: MEM_ADDR --> BYTE) is established by the initialisation - ref 3.3'";
  (MEM_ADDR*{BYTE_ZERO}: MEM_ADDR +-> BYTE);
  (dom(MEM_ADDR*{BYTE_ZERO}) = MEM_ADDR);
  "`Check that the invariant (mem(PSW)(0) = parity(mem(ACC))) is established by the initialisation - ref 3.3'";
  ((MEM_ADDR*{BYTE_ZERO})(PSW)(0) = parity((MEM_ADDR*{BYTE_ZERO})(ACC)));
  ("`Component invariant'" & mem: MEM_ADDR +-> BYTE & dom(mem) = MEM_ADDR & mem(PSW)(0) = parity(mem(ACC)));
  ("`Local hypotheses'" & xx: BYTE);
  "`Check assertion (!xx.(xx: BYTE => not(SP_INCREMENT(xx,1) = SP_INCREMENT(xx,2)))) deduction - ref 3.2, 4.2, 5.3'";
  (not(SP_INCREMENT(xx,1) = SP_INCREMENT(xx,2)));
  ("`Local hypotheses'" & mem$0: MEM_ADDR +-> BYTE & dom(mem$0) = MEM_ADDR & data$0: BYTE & psw$0: BYTE & (mem$0<+{ACC|->data$0})(ACC) = data$0 & (mem$0<+{PSW|->psw$0})(PSW)(0) = parity(data$0));
  "`Check assertion (!(mem,data,psw).(mem: MEM_ADDR --> BYTE & data: BYTE & psw: BYTE & (mem<+{ACC|->data})(ACC) = data & (mem<+{PSW|->psw})(PSW)(0) = parity(data) => (mem<+ACC_CHANGE(data,psw))(PSW)(0) = parity((mem<+ACC_CHANGE(data,psw))(ACC)))) deduction - ref 3.2, 4.2, 5.3'";
  ((mem$0<+ACC_CHANGE(data$0,psw$0))(PSW)(0) = parity((mem$0<+ACC_CHANGE(data$0,psw$0))(ACC)));
  ("`Local hypotheses'" & xx: ROM_ADDR & yy: ROM_ADDR & ROM_ADDR_MAX+1<=xx+yy);
  "`Check assertion (!(xx,yy).(xx: ROM_ADDR & yy: ROM_ADDR => (xx+yy>ROM_ADDR_MAX => PC_INCREMENT(xx,yy) = xx+yy-(ROM_ADDR_MAX+1)) & (not(xx+yy>ROM_ADDR_MAX) => PC_INCREMENT(xx,yy) = xx+yy))) deduction - ref 3.2, 4.2, 5.3'";
  (PC_INCREMENT(xx,yy) = xx+yy-(ROM_ADDR_MAX+1));
  ("`Local hypotheses'" & xx: ROM_ADDR & yy: ROM_ADDR & not(ROM_ADDR_MAX+1<=xx+yy));
  (PC_INCREMENT(xx,yy) = xx+yy);
  "`Check assertion (ROM_ADDR <: USHORT_INT) deduction - ref 3.2, 4.2, 5.3'";
  (ROM_ADDR: POW(USHORT_INT));
  "`Check assertion (RAM_ADDR\/SFR_ADDR = MEM_ADDR) deduction - ref 3.2, 4.2, 5.3'";
  (RAM_ADDR\/SFR_ADDR = MEM_ADDR);
  "`Check assertion (SFR_ADDR <: MEM_ADDR) deduction - ref 3.2, 4.2, 5.3'";
  (SFR_ADDR: POW(MEM_ADDR));
  "`Check assertion (RAM_ADDR <: MEM_ADDR) deduction - ref 3.2, 4.2, 5.3'";
  (RAM_ADDR: POW(MEM_ADDR));
  "`Check assertion (ACC/:RAM_ADDR) deduction - ref 3.2, 4.2, 5.3'";
  (not(ACC: RAM_ADDR));
  ("`Component assertions'" & not(ACC: RAM_ADDR) & RAM_ADDR: POW(MEM_ADDR) & SFR_ADDR: POW(MEM_ADDR) & RAM_ADDR\/SFR_ADDR = MEM_ADDR & ROM_ADDR: POW(USHORT_INT) & !(xx,yy).(xx: ROM_ADDR & yy: ROM_ADDR => (ROM_ADDR_MAX+1<=xx+yy => PC_INCREMENT(xx,yy) = xx+yy-(ROM_ADDR_MAX+1)) & (not(ROM_ADDR_MAX+1<=xx+yy) => PC_INCREMENT(xx,yy) = xx+yy)) & !(mem,data,psw).(mem: MEM_ADDR +-> BYTE & dom(mem) = MEM_ADDR & data: BYTE & psw: BYTE & (mem<+{ACC|->data})(ACC) = data & (mem<+{PSW|->psw})(PSW)(0) = parity(data) => (mem<+ACC_CHANGE(data,psw))(PSW)(0) = parity((mem<+ACC_CHANGE(data,psw))(ACC))) & !xx.(xx: BYTE => not(SP_INCREMENT(xx,1) = SP_INCREMENT(xx,2))));
  ("`exChange preconditions in this component'" & acc: SFR_ADDR & acc = ACC & addr: MEM_ADDR & not(addr = PSW));
  ("`Local hypotheses'" & not(addr = acc));
  "`Check that the invariant (mem: MEM_ADDR --> BYTE) is preserved by the operation - ref 3.4'";
  (mem<+{addr|->mem(ACC)}: MEM_ADDR +-> BYTE);
  (dom(mem<+{addr|->mem(ACC)}) = MEM_ADDR);
  "`Check that the invariant (mem(PSW)(0) = parity(mem(ACC))) is preserved by the operation - ref 3.4'";
  ((mem<+{addr|->mem(ACC)})(PSW)(0) = parity((mem<+{addr|->mem(ACC)})(ACC)));
  ("`bitSet preconditions in this component'" & addr: MEM_ADDR & ind: BYTE_INDEX & not(addr = PSW));
  ("`Local hypotheses'" & data: BYTE & data = bit_put(mem(ACC),ind,1) & addr = ACC);
  (mem<+ACC_CHANGE(data,mem(PSW)): MEM_ADDR +-> BYTE);
  (dom(mem<+ACC_CHANGE(data,mem(PSW))) = MEM_ADDR);
  ((mem<+ACC_CHANGE(data,mem(PSW)))(PSW)(0) = parity((mem<+ACC_CHANGE(data,mem(PSW)))(ACC)));
  ("`Local hypotheses'" & data: BYTE & data = bit_put(mem(ACC),ind,1) & not(addr = ACC));
  (mem<+{addr|->data}: MEM_ADDR +-> BYTE);
  (dom(mem<+{addr|->data}) = MEM_ADDR);
  ((mem<+{addr|->data})(PSW)(0) = parity((mem<+{addr|->data})(ACC)));
  ("`bitClear preconditions in this component'" & addr: MEM_ADDR & ind: BYTE_INDEX & not(addr = PSW));
  ("`Local hypotheses'" & data: BYTE & data = bit_put(mem(ACC),ind,0) & addr = ACC);
  ("`Local hypotheses'" & data: BYTE & data = bit_put(mem(ACC),ind,0) & not(addr = ACC));
  ("`addrSetDirect preconditions in this component'" & addr: MEM_ADDR & data: BYTE & not(addr = PSW));
  ("`Local hypotheses'" & addr = ACC);
  ("`Local hypotheses'" & not(addr = ACC));
  ("`addrSetIndirect preconditions in this component'" & Rn: RAM_ADDR & (Rn = R1 or Rn = R2) & data: BYTE & byte_uchar(mem(Rn)): RAM_ADDR);
  ("`Local hypotheses'" & addr: RAM_ADDR & addr = byte_uchar(mem(Rn)) & addr = ACC);
  ("`Local hypotheses'" & addr: RAM_ADDR & addr = byte_uchar(mem(Rn)) & not(addr = ACC));
  ("`push_two preconditions in this component'" & data1: BYTE & data2: BYTE & mem(SP): BYTE);
  (mem<+({SP_INCREMENT(mem(SP),1)|->data1}\/{SP_INCREMENT(mem(SP),2)|->data2}\/{SP|->uchar_byte(SP_INCREMENT(mem(SP),2))}): MEM_ADDR +-> BYTE);
  (dom(mem<+({SP_INCREMENT(mem(SP),1)|->data1}\/{SP_INCREMENT(mem(SP),2)|->data2}\/{SP|->uchar_byte(SP_INCREMENT(mem(SP),2))})) = MEM_ADDR);
  ((mem<+({SP_INCREMENT(mem(SP),1)|->data1}\/{SP_INCREMENT(mem(SP),2)|->data2}\/{SP|->uchar_byte(SP_INCREMENT(mem(SP),2))}))(PSW)(0) = parity((mem<+({SP_INCREMENT(mem(SP),1)|->data1}\/{SP_INCREMENT(mem(SP),2)|->data2}\/{SP|->uchar_byte(SP_INCREMENT(mem(SP),2))}))(ACC)));
  ("`push preconditions in this component'" & data: BYTE);
  (mem<+{SP_INCREMENT(mem(SP),1)|->data}: MEM_ADDR +-> BYTE);
  (dom(mem<+{SP_INCREMENT(mem(SP),1)|->data}) = MEM_ADDR);
  ((mem<+{SP_INCREMENT(mem(SP),1)|->data})(PSW)(0) = parity((mem<+{SP_INCREMENT(mem(SP),1)|->data})(ACC)));
  ("`pop preconditions in this component'" & addr: MEM_ADDR & not(addr = PSW) & not(addr = SP) & byte_uchar(mem(SP)): RAM_ADDR);
  ("`Local hypotheses'" & data: BYTE & data = mem(SP) & addr = ACC);
  (mem<+ACC_CHANGE(data,mem(PSW))<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))}: MEM_ADDR +-> BYTE);
  (dom(mem<+ACC_CHANGE(data,mem(PSW))<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))}) = MEM_ADDR);
  ((mem<+ACC_CHANGE(data,mem(PSW))<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))})(PSW)(0) = parity((mem<+ACC_CHANGE(data,mem(PSW))<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))})(ACC)));
  ("`Local hypotheses'" & data: BYTE & data = mem(SP) & not(addr = ACC));
  (mem<+{addr|->mem(PSW)}<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))}: MEM_ADDR +-> BYTE);
  (dom(mem<+{addr|->mem(PSW)}<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))}) = MEM_ADDR);
  ((mem<+{addr|->mem(PSW)}<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))})(PSW)(0) = parity((mem<+{addr|->mem(PSW)}<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),1))})(ACC)));
  ("`update preconditions in this component'" & acc: UCHAR & Pa: BIT & Ov: BIT & Ac: BIT & Cy: BIT & Pa = parity(uchar_byte(acc)));
  (mem<+({ACC|->uchar_byte(acc)}\/{PSW|->PSWUPDATE(mem(PSW),Pa,Ov,Ac,Cy)}): MEM_ADDR +-> BYTE);
  (dom(mem<+({ACC|->uchar_byte(acc)}\/{PSW|->PSWUPDATE(mem(PSW),Pa,Ov,Ac,Cy)})) = MEM_ADDR);
  ((mem<+({ACC|->uchar_byte(acc)}\/{PSW|->PSWUPDATE(mem(PSW),Pa,Ov,Ac,Cy)}))(PSW)(0) = parity((mem<+({ACC|->uchar_byte(acc)}\/{PSW|->PSWUPDATE(mem(PSW),Pa,Ov,Ac,Cy)}))(ACC)));
  ("`update_div preconditions in this component'" & acc: BYTE & Pa: BIT & Ov: BIT & bb: BYTE & Pa = parity(acc));
  "`Check that the invariant (mem: MEM_ADDR --> BYTE) is preserved by the operation - ref 3.4'";
  (mem<+{ACC|->acc}<+({PSW|->PSWUPDATE(mem(PSW),Pa,Ov,BIT_GET(AC,mem),0)}\/{BB|->bb}): MEM_ADDR +-> BYTE);
  (dom(mem<+{ACC|->acc}<+({PSW|->PSWUPDATE(mem(PSW),Pa,Ov,BIT_GET(AC,mem),0)}\/{BB|->bb})) = MEM_ADDR);
  "`Check that the invariant (mem(PSW)(0) = parity(mem(ACC))) is preserved by the operation - ref 3.4'";
  ((mem<+{ACC|->acc}<+({PSW|->PSWUPDATE(mem(PSW),Pa,Ov,BIT_GET(AC,mem),0)}\/{BB|->bb}))(PSW)(0) = parity((mem<+{ACC|->acc}<+({PSW|->PSWUPDATE(mem(PSW),Pa,Ov,BIT_GET(AC,mem),0)}\/{BB|->bb}))(ACC)));
  ("`decrement_sp preconditions in this component'" & addr: RAM_ADDR);
  (mem<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),addr))}: MEM_ADDR +-> BYTE);
  (dom(mem<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),addr))}) = MEM_ADDR);
  ((mem<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),addr))})(PSW)(0) = parity((mem<+{SP|->uchar_byte(SP_DECREMENT(mem(SP),addr))})(ACC)))
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(genOPO == KO, genDivergencePO == KO, local_op == OK)
END
