THEORY ProofList IS
  _f(1) & _f(2) & AssertionLemmas.11,(_f(23) => _f(24));
  _f(1) & _f(2) & AssertionLemmas.10,(_f(21) => _f(22));
  _f(1) & _f(2) & AssertionLemmas.9,(_f(19) => _f(20));
  _f(1) & _f(2) & AssertionLemmas.8,(_f(17) => _f(18));
  _f(1) & _f(2) & AssertionLemmas.7,(_f(15) => _f(16));
  _f(1) & _f(2) & AssertionLemmas.6,(_f(13) => _f(14));
  _f(1) & _f(2) & AssertionLemmas.5,(_f(11) => _f(12));
  _f(1) & _f(2) & AssertionLemmas.4,(_f(9) => _f(10));
  _f(1) & _f(2) & AssertionLemmas.3,(_f(7) => _f(8));
  _f(1) & _f(2) & AssertionLemmas.2,(_f(5) => _f(6));
  _f(1) & _f(2) & AssertionLemmas.1,(_f(3) => _f(4))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & UCHAR_MAX: INTEGER & 0<=UCHAR_MAX & UCHAR_MAX = 2**BYTE_WIDTH-1 & UCHAR = 0..UCHAR_MAX & SCHAR_MAX: INTEGER & SCHAR_MIN: INTEGER & SCHAR_MAX = 2**(BYTE_WIDTH-1)-1 & SCHAR_MIN = -(2**(BYTE_WIDTH-1)) & SCHAR = SCHAR_MIN..SCHAR_MAX & USHORT_INT_MAX: INTEGER & USHORT_INT_MAX = 2**(2*BYTE_WIDTH)-1 & USHORT_INT = 0..USHORT_INT_MAX & byte_uchar: BYTE +-> UCHAR & dom(byte_uchar) = BYTE & byte_uchar = %bv.(bv: BYTE | bv_to_nat(bv)) & uchar_byte = byte_uchar~ & byte_schar: BYTE +-> SCHAR & dom(byte_schar) = BYTE & byte_schar = %bv.(bv: BYTE | (-bv(7))*128+bv(6)*64+bv(5)*32+bv(4)*16+bv(3)*8+bv(2)*4+bv(1)*2+bv(0)*1) & schar_byte = byte_schar~ & uchar_schar: UCHAR +-> SCHAR & dom(uchar_schar) = UCHAR & uchar_schar = %v1.(v1: UCHAR & v1<=SCHAR_MAX | v1) & uchar_schar = %v1.(v1: UCHAR & not(v1<=SCHAR_MAX) | v1-UCHAR_MAX) & schar_uchar = uchar_schar~ & bv16_usint: BV16 +-> USHORT_INT & dom(bv16_usint) = BV16 & bv16_usint = %v0.(v0: BV16 | 32768*v0(15)+16384*v0(14)+8192*v0(13)+4096*v0(12)+2048*v0(11)+1024*v0(10)+512*v0(9)+256*v0(8)+128*v0(7)+64*v0(6)+32*v0(5)+16*v0(4)+8*v0(3)+4*v0(2)+2*v0(1)+v0(0)) & usint_bv16 = bv16_usint~ & BIT = 0..1 & bit_not: BIT +-> BIT & dom(bit_not) = BIT & !bb.(bb: BIT => bit_not(bb) = 1-bb) & bit_and: BIT*BIT +-> BIT & dom(bit_and) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_and(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_and(b1,b2) = 1) & b2 = 1) & bit_or: BIT*BIT +-> BIT & dom(bit_or) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_or(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_or(b1,b2) = 1) or b2 = 1) & bit_xor: BIT*BIT +-> BIT & dom(bit_xor) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_xor(b1,b2) = 1 => not(b1 = b2)) & (not(b1 = b2) => bit_xor(b1,b2) = 1)) & bool_to_bit: BOOL +-> BIT & dom(bool_to_bit) = BOOL & bool_to_bit = {TRUE|->1}\/{FALSE|->0} & BIT_VECTOR = SET(bt).(bt: NATURAL +-> BIT)-{{}} & bv_size: BIT_VECTOR +-> NATURAL-{0} & dom(bv_size) = BIT_VECTOR & bv_size = %bv.(bv: BIT_VECTOR | size(bv)) & BV_INDX: BIT_VECTOR +-> POW(NATURAL) & dom(BV_INDX) = BIT_VECTOR & BV_INDX = %bv.(bv: BIT_VECTOR | 0..bv_size(bv)-1) & bv_catenate: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_catenate) = BIT_VECTOR*BIT_VECTOR & bv_catenate = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR | v1^v2) & bv_sub: BIT_VECTOR*NATURAL*NATURAL +-> BIT_VECTOR & dom(bv_sub) = BIT_VECTOR*NATURAL*NATURAL & bv_sub = %(bv,low,high).(bv: BIT_VECTOR & low: BV_INDX(bv) & high: BV_INDX(bv) & low<=high | low..high<|bv) & bv_zero: NATURAL-{0} +-> BIT_VECTOR & dom(bv_zero) = NATURAL-{0} & bv_zero = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (0..sz)*{0}) & bv_one: NATURAL-{0} +-> BIT_VECTOR & dom(bv_one) = NATURAL-{0} & bv_one = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (0..sz)*{1}) & bv_not: BIT_VECTOR +-> BIT_VECTOR & dom(bv_not) = BIT_VECTOR & bv_not = %v1.(v1: BIT_VECTOR | %idx.(idx: BV_INDX(v1) | bit_not(v1(idx)))) & bv_and: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_and) = BIT_VECTOR*BIT_VECTOR & bv_and = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: BV_INDX(v1) | bit_and(v1(idx),v2(idx)))) & bv_or: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_or) = BIT_VECTOR*BIT_VECTOR & bv_or = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: BV_INDX(v1) | bit_or(v1(idx),v2(idx)))) & bv_xor: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_xor) = BIT_VECTOR*BIT_VECTOR & bv_xor = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: BV_INDX(v1) | bit_xor(v1(idx),v2(idx)))) & bv_at: BIT_VECTOR*NATURAL +-> BIT & dom(bv_at) = BIT_VECTOR*NATURAL & bv_at = %(v1,idx).(v1: BIT_VECTOR & idx: BV_INDX(v1) | v1(idx)) & bv_set: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_set) = BIT_VECTOR*NATURAL & bv_set = %(v1,idx).(v1: BIT_VECTOR & idx: BV_INDX(v1) | v1<+{idx|->1}) & bv_clear: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_clear) = BIT_VECTOR*NATURAL & bv_clear = %(v1,idx).(v1: BIT_VECTOR & idx: BV_INDX(v1) | v1<+{idx|->0}) & bv_put: BIT_VECTOR*NATURAL*BIT +-> BIT_VECTOR & dom(bv_put) = BIT_VECTOR*NATURAL*BIT & bv_put = %(v1,idx,bit).(v1: BIT_VECTOR & idx: BV_INDX(v1) & bit: BIT | v1<+{idx|->bit}) & BYTE_WIDTH = 8 & BYTE_INDEX = 0..BYTE_WIDTH-1 & BYTE = SET(bt).(bt: BYTE_INDEX +-> BIT & dom(bt) = BYTE_INDEX & size(bt) = BYTE_WIDTH)-{{}} & BYTE_ZERO: BYTE & BYTE_ZERO = BYTE_INDEX*{0} & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv_par = %bv.(bv: BIT_VECTOR | size(bv|>{1}) mod 2) & BV16_WIDTH: INTEGER & 0<=BV16_WIDTH & BV16_WIDTH = 16 & BV16_INDX = 0..BV16_WIDTH-1 & BV16 = SET(bt).(bt: BV16_INDX +-> BIT & dom(bt) = BV16_INDX & size(bt) = 16)-{{}} & BV16_ZERO = BV16_INDX*{0} & bv16_byte: BV16 +-> BYTE*BYTE & dom(bv16_byte) = BV16 & bv16_byte = %bv.(bv: BV16 | {0|->bv(8)}\/{1|->bv(9)}\/{2|->bv(10)}\/{3|->bv(11)}\/{4|->bv(12)}\/{5|->bv(13)}\/{6|->bv(14)}\/{7|->bv(15)},{0|->bv(0)}\/{1|->bv(1)}\/{2|->bv(2)}\/{3|->bv(3)}\/{4|->bv(4)}\/{5|->bv(5)}\/{6|->bv(6)}\/{7|->bv(7)}) & "`Component properties'" & parity: BYTE +-> BIT & dom(parity) = BYTE & parity = %bv.(bv: BYTE | bv_par(bv)) & half: UCHAR +-> UCHAR & dom(half) = UCHAR & half = %v1.(v1: UCHAR | v1 mod 2**4) & add: UCHAR*UCHAR*BIT +-> UCHAR*BIT*BIT*BIT*BIT & dom(add) = UCHAR*UCHAR*BIT & add = %(v1,v2,ca).(v1: UCHAR & v2: UCHAR & ca: UCHAR | (v1+v2+ca) mod (UCHAR_MAX+1),parity(uchar_byte((v1+v2+ca) mod (UCHAR_MAX+1))),bool_to_bit(bool(not(uchar_schar(v1)+uchar_schar(v2)+ca: SCHAR))),bool_to_bit(bool(2**4<=half(v1)+half(v2)+ca)),bool_to_bit(bool(not(v1+v2+ca: UCHAR)))) & sub: UCHAR*UCHAR*UCHAR +-> UCHAR*BIT*BIT*BIT*BIT & dom(sub) = UCHAR*UCHAR*UCHAR & sub = %(v1,v2,ca).(v1: UCHAR & v2: UCHAR & ca: UCHAR | bool_to_bit(bool(v1+1<=v2+ca))*256+v1-v2-ca,parity(uchar_byte(bool_to_bit(bool(v1+1<=v2+ca))*256+v1-v2-ca)),bool_to_bit(bool(not(uchar_schar(v1)-uchar_schar(v2)-ca: SCHAR))),bool_to_bit(bool(half(v1)+1<=half(v2)+ca)),bool_to_bit(bool(not(v1-v2-ca: UCHAR)))) & and: BYTE*BYTE +-> BYTE & dom(and) = BYTE*BYTE & and = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | bv_and(bt1,bt2)) & and_bit: BIT*BIT +-> BIT & dom(and_bit) = BIT*BIT & and_bit = %(b1,b2).(b1: BIT & b2: BIT | bit_and(b1,b2)) & ior: BYTE*BYTE +-> BYTE & dom(ior) = BYTE*BYTE & ior = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | bv_or(bt1,bt2)) & xor: BYTE*BYTE +-> BYTE & dom(xor) = BYTE*BYTE & xor = %(bt1,bt2).(bt1: BYTE & bt2: BYTE | bv_xor(bt1,bt2)) & complement: BYTE +-> BYTE & dom(complement) = BYTE & complement = %bt.(bt: BYTE | bv_not(bt)) & swap: BYTE +-> BYTE & dom(swap) = BYTE & swap = %bt.(bt: BYTE | {0|->bt(4)}\/{1|->bt(5)}\/{2|->bt(6)}\/{3|->bt(7)}\/{4|->bt(0)}\/{5|->bt(1)}\/{6|->bt(2)}\/{7|->bt(3)}) & rotateleft: BYTE +-> BYTE & dom(rotateleft) = BYTE & rotateleft = %bv.(bv: BYTE | {0|->bv(7)}\/{1|->bv(0)}\/{2|->bv(1)}\/{3|->bv(2)}\/{4|->bv(3)}\/{5|->bv(4)}\/{6|->bv(5)}\/{7|->bv(6)}) & rotateright: BYTE +-> BYTE & dom(rotateright) = BYTE & rotateright = %bv.(bv: BYTE | {0|->bv(1)}\/{1|->bv(2)}\/{2|->bv(3)}\/{3|->bv(4)}\/{4|->bv(5)}\/{5|->bv(6)}\/{6|->bv(7)}\/{7|->bv(0)}) & usint_byte: USHORT_INT +-> BYTE*BYTE & dom(usint_byte) = USHORT_INT & usint_byte = %usint.(usint: USHORT_INT | bv16_byte(usint_bv16(usint))));
  ("`Seen and used machines assertions'" & dom(byte_schar) = BYTE & ran(byte_schar): POW(SCHAR) & dom(schar_byte) = SCHAR & ran(schar_byte): POW(BYTE) & dom(byte_uchar) = BYTE & ran(byte_uchar): POW(UCHAR) & dom(uchar_byte) = UCHAR & ran(uchar_byte): POW(BYTE) & dom(uchar_schar) = UCHAR & ran(uchar_schar): POW(SCHAR) & dom(schar_uchar) = SCHAR & ran(schar_uchar): POW(UCHAR) & bit_not(0) = 1 & bit_not(1) = 0 & !bb.(bb: BIT => bit_not(bit_not(bb)) = bb) & bit_and(0,0) = 0 & bit_and(0,1) = 0 & bit_and(1,0) = 0 & bit_and(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_and(b1,b2) = bit_and(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 1 => bit_and(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 0 => bit_and(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_and(b1,bit_and(b2,b3)) = bit_and(bit_and(b1,b2),b3)) & !b1.(b1: BIT => bit_and(b1,1) = b1) & !b1.(b1: BIT => bit_and(b1,0) = 0) & bit_or(0,0) = 0 & bit_or(0,1) = 1 & bit_or(1,0) = 1 & bit_or(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_or(b1,b2) = bit_or(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 1 => bit_or(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 0 => bit_or(b2,b1) = 0) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 1 => b1 = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 0 => b1 = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_or(b1,bit_or(b2,b3)) = bit_or(bit_or(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = bit_or(1,b3)) & !b1.(b1: BIT => bit_or(b1,1) = 1) & !b1.(b1: BIT => bit_or(b1,0) = b1) & !b1.(b1: BIT => bit_or(1,b1) = 1) & !b1.(b1: BIT => bit_or(0,b1) = b1) & bit_xor(0,0) = 0 & bit_xor(0,1) = 1 & bit_xor(1,0) = 1 & bit_xor(1,1) = 0 & !(b1,b2).(b1: BIT & b2: BIT => bit_xor(b1,b2) = bit_xor(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 1 => bit_xor(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 0 => bit_xor(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(bit_xor(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(1,b3)) & !bb.(bb: BIT => bit_xor(bb,bb) = 0) & bool_to_bit(TRUE) = 1 & bool_to_bit(FALSE) = 0 & !bb.(bb: BIT => bb = 0 or bb = 1) & !bb.(bb: BIT & not(bb = 0) => bb = 1) & !bb.(bb: BIT & not(bb = 1) => bb = 0) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_xor(bv,bv)(indx) = bv_zero(bv_size(bv))(indx)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: BV_INDX(v1) => bv_xor(v1,v2)(indx) = bv_xor(v2,v1)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v2)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v1)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_or(bv,bv_zero(bv_size(bv)))(indx) = bv(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_or(bv,bv_one(bv_size(bv)))(indx) = bv_one(bv_size(bv))(indx)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) & indx: BV_INDX(v1) => bv_or(v1,bv_or(v2,v3))(indx) = bv_or(bv_or(v1,v2),v3)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v2)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: BV_INDX(v1) => bv_or(v1,v2)(indx) = bv_or(v2,v1)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v1)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_and(bv,bv_one(bv_size(bv)))(indx) = bv(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_and(bv,bv_zero(bv_size(bv)))(indx) = bv_zero(bv_size(bv))(indx)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) & indx: BV_INDX(v1) => bv_and(v1,bv_and(v2,v3))(indx) = bv_and(bv_and(v1,v2),v3)(indx)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: BV_INDX(v1) => bv_and(v1,v2)(indx) = bv_and(v2,v1)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_and(v1,v2)) = bv_size(v2)) & !(bv,low,high).(bv: BIT_VECTOR & low: BV_INDX(bv) & high: BV_INDX(bv) & low<=high => bv_size(bv_sub(bv,low,high)) = high-low) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR => bv_size(bv_catenate(v1,v2)) = bv_size(v1)+bv_size(v2)) & !(bv,indx).(bv: BIT_VECTOR & indx: BV_INDX(bv) => bv_not(bv_not(bv))(indx) = bv(indx)) & !bv.(bv: BIT_VECTOR => bv_size(bv_not(bv)) = bv_size(bv)) & !bt.(bt: BYTE => size(bt) = 8) & size(BYTE_ZERO) = 8 & BYTE: POW(BIT_VECTOR) & BYTE_ZERO: BIT_VECTOR & first(BYTE_ZERO) = 0 & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_to_nat(bv_zero(ss)) = 0) & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_par(bv_zero(ss)) = 0) & BV16_ZERO: BV16 & BV16: POW(BIT_VECTOR) & BV16_ZERO: BIT_VECTOR);
  "`Check assertion (ran(rotateright) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(rotateright): POW(BYTE));
  "`Check assertion (ran(rotateleft) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(rotateleft): POW(BYTE));
  "`Check assertion (ran(swap) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(swap): POW(BYTE));
  "`Check assertion (ran(complement) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(complement): POW(BYTE));
  "`Check assertion (ran(xor) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(xor): POW(BYTE));
  "`Check assertion (ran(ior) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(ior): POW(BYTE));
  "`Check assertion (ran(and) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(and): POW(BYTE));
  "`Check assertion (ran(sub) <: UCHAR*BIT*BIT*BIT*BIT) deduction - ref 3.2, 4.2, 5.3'";
  (ran(sub): POW(UCHAR*BIT*BIT*BIT*BIT));
  "`Check assertion (ran(add) <: UCHAR*BIT*BIT*BIT*BIT) deduction - ref 3.2, 4.2, 5.3'";
  (ran(add): POW(UCHAR*BIT*BIT*BIT*BIT));
  "`Check assertion (dom(add) = UCHAR*UCHAR*UCHAR) deduction - ref 3.2, 4.2, 5.3'";
  (dom(add) = UCHAR*UCHAR*UCHAR);
  "`Check assertion (ran(parity) <: BIT) deduction - ref 3.2, 4.2, 5.3'";
  (ran(parity): POW(BIT));
  ("`Component assertions'" & dom(parity) = BYTE & ran(parity): POW(BIT) & dom(add) = UCHAR*UCHAR*UCHAR & ran(add): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(sub) = UCHAR*UCHAR*UCHAR & ran(sub): POW(UCHAR*BIT*BIT*BIT*BIT) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & dom(rotateleft) = BYTE & ran(rotateleft): POW(BYTE) & dom(rotateright) = BYTE & ran(rotateright): POW(BYTE))
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(genOPO == KO, local_op == OK)
END
