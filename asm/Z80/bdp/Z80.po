THEORY ProofList IS
  _f(1) & _f(2) & _f(3) & _f(30) & _f(74) & GOTO.1,(_f(48) => _f(36));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(72) & RES_b_HL.3,(_f(73) & _f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(72) & RES_b_HL.2,(_f(73) & _f(58) => _f(71));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(72) & RES_b_HL.1,(_f(73) & _f(58) => _f(70));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(68) & SET_b_HL.3,(_f(69) & _f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(68) & SET_b_HL.2,(_f(69) & _f(58) => _f(71));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(68) & SET_b_HL.1,(_f(69) & _f(58) => _f(70));
  _f(1) & _f(2) & _f(3) & _f(30) & JP_z_e.2,(_f(66) & _f(48) => _f(67));
  _f(1) & _f(2) & _f(3) & _f(30) & JP_z_e.1,(_f(65) & _f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(61) & BIT_b_HL.3,(_f(62) & _f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(61) & BIT_b_HL.2,(_f(62) & _f(45) => _f(64));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(61) & BIT_b_HL.1,(_f(62) & _f(45) => _f(63));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(57) & LD_HL_r.3,(_f(54) & _f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(57) & LD_HL_r.2,(_f(54) & _f(58) => _f(60));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(57) & LD_HL_r.1,(_f(54) & _f(58) => _f(59));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(53) & LD_r_HL.3,(_f(54) & _f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(53) & LD_r_HL.2,(_f(54) & _f(45) => _f(56));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(53) & LD_r_HL.1,(_f(54) & _f(45) => _f(55));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(50) & LD_r_n_.3,(_f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(50) & LD_r_n_.2,(_f(45) => _f(52));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(50) & LD_r_n_.1,(_f(45) => _f(51));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(44) & LD_r_r_.3,(_f(48) => _f(49));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(44) & LD_r_r_.2,(_f(45) => _f(47));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(44) & LD_r_r_.1,(_f(45) => _f(46));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(39) & RETURN.4,(_f(37) => _f(43));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(39) & RETURN.3,(_f(35) => _f(42));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(39) & RETURN.2,(_f(32) => _f(41));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(39) & RETURN.1,(_f(32) => _f(40));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(31) & CALL.4,(_f(37) => _f(38));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(31) & CALL.3,(_f(35) => _f(36));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(31) & CALL.2,(_f(32) => _f(34));
  _f(1) & _f(2) & _f(3) & _f(30) & _f(31) & CALL.1,(_f(32) => _f(33));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.13,(_f(28) => _f(29));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.12,(_f(26) => _f(27));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.11,(_f(24) => _f(25));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.10,(_f(22) => _f(23));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.9,(_f(20) => _f(21));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.8,(_f(18) => _f(19));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.7,(_f(16) => _f(17));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.6,(_f(14) => _f(15));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.5,(_f(12) => _f(13));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.4,(_f(10) => _f(11));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.3,(_f(8) => _f(9));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.2,(_f(6) => _f(7));
  _f(1) & _f(2) & _f(3) & AssertionLemmas.1,(_f(4) => _f(5))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & WORD16_LENGTH : INTEGER & 0<=WORD16_LENGTH & WORD16_LENGTH = 16 & NB_WORD16S : INTEGER & 0<=NB_WORD16S & NB_WORD16S = 2**WORD16_LENGTH & WORD16 = 0..NB_WORD16S-1 & WORD16_POSITION = 0..WORD16_LENGTH-1 & WORD8_LENGTH : INTEGER & 0<=WORD8_LENGTH & WORD8_LENGTH = 8 & NB_WORD8S : INTEGER & 0<=NB_WORD8S & NB_WORD8S = 2**WORD8_LENGTH & WORD8 = 0..NB_WORD8S-1 & WORD8_POSITION = 0..WORD8_LENGTH-1 & NB_INSTRUCTIONS : INTEGER & 0<=NB_INSTRUCTIONS & INST_SZ : INTEGER & 0<=INST_SZ & NB_INSTRUCTIONS = 2**INST_SZ & INSTRUCTION_MAX = NB_INSTRUCTIONS-1 & INSTRUCTION = 0..INSTRUCTION_MAX & INSTRUCTION_NEXT : INSTRUCTION +-> INSTRUCTION & dom(INSTRUCTION_NEXT) = INSTRUCTION & INSTRUCTION_NEXT = SET(p,q).(p : INSTRUCTION & q : INSTRUCTION & 0<=p & p+1<=NB_INSTRUCTIONS-1 & q = p+1)\/{NB_INSTRUCTIONS-1|->0} & BV8_TO_WORD8 : BV8 +-> WORD8 & dom(BV8_TO_WORD8) = BV8 & BV8_TO_WORD8 = %v.(v : BV8 | 128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0)) & WORD8_TO_BV8 : WORD8 +-> BV8 & dom(WORD8_TO_BV8) = WORD8 & WORD8_TO_BV8 = BV8_TO_WORD8~ & BV16_TO_WORD16 : BV16 +-> WORD16 & dom(BV16_TO_WORD16) = BV16 & BV16_TO_WORD16 = %v.(v : BV16 | 32768*v(15)+16384*v(14)+8192*v(13)+4096*v(12)+2048*v(11)+1024*v(10)+512*v(9)+256*v(8)+128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0)) & WORD16_TO_BV16 : WORD16 +-> BV16 & dom(WORD16_TO_BV16) = WORD16 & WORD16_TO_BV16 = BV16_TO_WORD16~ & BV8_TO_BV16 : BV8*BV8 +-> BV16 & dom(BV8_TO_BV16) = BV8*BV8 & BV8_TO_BV16 = %(v1,v2).(v1 : BV8 & v2 : BV8 | {0|->v1(0)}\/{1|->v1(1)}\/{2|->v1(2)}\/{3|->v1(3)}\/{4|->v1(4)}\/{5|->v1(5)}\/{6|->v1(6)}\/{7|->v1(7)}\/{8|->v2(0)}\/{9|->v2(1)}\/{10|->v2(2)}\/{11|->v2(3)}\/{12|->v2(4)}\/{13|->v2(5)}\/{14|->v2(6)}\/{15|->v2(7)}) & WORD8_TO_WORD16 : WORD8*WORD8 +-> WORD16 & dom(WORD8_TO_WORD16) = WORD8*WORD8 & WORD8_TO_WORD16 = %(w1,w2).(w1 : WORD8 & w2 : WORD8 | BV16_TO_WORD16(BV8_TO_BV16(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2)))) & WORD16_TO_WORD8 : WORD16 +-> WORD8*WORD8 & dom(WORD16_TO_WORD8) = WORD16 & WORD16_TO_WORD8 = WORD8_TO_WORD16~ & BIT = 0..1 & BIT_FLIP : BIT +-> BIT & dom(BIT_FLIP) = BIT & !b.(b : BIT => BIT_FLIP(b) = 1-b) & BIT_AND : BIT*BIT +-> BIT & dom(BIT_AND) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_AND(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_AND(b1,b2) = 1) & b2 = 1) & BIT_IOR : BIT*BIT +-> BIT & dom(BIT_IOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_IOR(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_IOR(b1,b2) = 1) or b2 = 1) & BIT_XOR : BIT*BIT +-> BIT & dom(BIT_XOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_XOR(b1,b2) = 1 => b1 = 1 & b2 = 0 or (b1 = 0 & b2 = 1)) & ((b1 = 1 & b2 = 0 => BIT_XOR(b1,b2) = 1) & (b1 = 0 & b2 = 1 => BIT_XOR(b1,b2) = 1))) & BV8_INDEX = 0..7 & BV8 = BV8_INDEX --> BIT & BV8_SET_BIT : BV8*BV8_INDEX*BIT +-> BV8 & dom(BV8_SET_BIT) = BV8*BV8_INDEX*BIT & !(v,i,j,b).(v : BV8 & i : BV8_INDEX & j : BV8_INDEX & b : BIT & not(i = j) => BV8_SET_BIT(v,i,b)(j) = v(j)) & !(v,i,b).(v : BV8 & i : BV8_INDEX & b : BIT => BV8_SET_BIT(v,i,b)(i) = b) & BV8_COMPLEMENT : BV8 +-> BV8 & dom(BV8_COMPLEMENT) = BV8 & !(v,i).(v : BV8 & i : BV8_INDEX => BV8_COMPLEMENT(v)(i) = BIT_FLIP(v(i))) & BV8_ALL_ZEROES : BV8 & !i.(i : BV8_INDEX => BV8_ALL_ZEROES(i) = 0) & BV8_AND : BV8*BV8 +-> BV8 & dom(BV8_AND) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_AND(v1,v2)(i) = BIT_AND(v1(i),v2(i))) & BV8_IOR : BV8*BV8 +-> BV8 & dom(BV8_IOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_IOR(v1,v2)(i) = BIT_IOR(v1(i),v2(i))) & BV8_XOR : BV8*BV8 +-> BV8 & dom(BV8_XOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_XOR(v1,v2)(i) = BIT_XOR(v1(i),v2(i))) & BV16_INDEX = 0..15 & BV16 = BV16_INDEX --> BIT & BV16_SET_BIT : BV16*BV16_INDEX*BIT +-> BV16 & dom(BV16_SET_BIT) = BV16*BV16_INDEX*BIT & !(v,i,j,b).(v : BV16 & i : BV16_INDEX & j : BV16_INDEX & b : BIT & not(i = j) => BV16_SET_BIT(v,i,b)(j) = v(j)) & !(v,i,b).(v : BV16 & i : BV16_INDEX & b : BIT => BV16_SET_BIT(v,i,b)(i) = b) & BV16_COMPLEMENT : BV16 +-> BV16 & dom(BV16_COMPLEMENT) = BV16 & !(v,i).(v : BV16 & i : BV16_INDEX => BV16_COMPLEMENT(v)(i) = BIT_FLIP(v(i))) & BV16_ALL_ZEROES : BV16 & !i.(i : BV16_INDEX => BV16_ALL_ZEROES(i) = 0) & BV16_AND : BV16*BV16 +-> BV16 & dom(BV16_AND) = BV16*BV16 & !(v1,v2,i).(v1 : BV16 & v2 : BV16 & i : BV16_INDEX => BV16_AND(v1,v2)(i) = BIT_AND(v1(i),v2(i))) & BV16_IOR : BV16*BV16 +-> BV16 & dom(BV16_IOR) = BV16*BV16 & !(v1,v2,i).(v1 : BV16 & v2 : BV16 & i : BV16_INDEX => BV16_IOR(v1,v2)(i) = BIT_IOR(v1(i),v2(i))) & BV16_XOR : BV16*BV16 +-> BV16 & dom(BV16_XOR) = BV16*BV16 & !(v1,v2,i).(v1 : BV16 & v2 : BV16 & i : BV16_INDEX => BV16_XOR(v1,v2)(i) = BIT_XOR(v1(i),v2(i))) & add : WORD8*WORD8 +-> WORD8*BOOL*BOOL & dom(add) = WORD8*WORD8 & !(w1,w2).(w1 : WORD8 & w2 : WORD8 & (w1+w2 : INTEGER & 0<=w1+w2) => (w1+w2<=255 => add(w1,w2) = (w1+w2,bool(w1+w2 = 0))|->FALSE) & (256<=w1+w2 => add(w1,w2) = (w1+w2-256,bool(w1+w2 = 256))|->TRUE)) & substract : WORD8*WORD8 +-> WORD8*BOOL*BOOL & dom(substract) = WORD8*WORD8 & !(w1,w2).(w1 : WORD8 & w2 : WORD8 & w1-w2 : INTEGER => (w1-w2+1<=0 => substract(w1,w2) = (w1-w2+256,FALSE)|->TRUE) & (0<=w1-w2 => substract(w1,w2) = (w1-w2,bool(w1-w2 = 0))|->FALSE)) & and : WORD8*WORD8 +-> WORD8*BOOL & dom(and) = WORD8*WORD8 & !(w1,w2).(w1 : WORD8 & w2 : WORD8 & BV8_TO_WORD8(BV8_AND(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2))) : WORD8 => and(w1,w2) = BV8_TO_WORD8(BV8_AND(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2)))|->bool(BV8_TO_WORD8(BV8_AND(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2))) = 0)) & ior : WORD8*WORD8 +-> WORD8*BOOL & dom(ior) = WORD8*WORD8 & !(w1,w2).(w1 : WORD8 & w2 : WORD8 & BV8_TO_WORD8(BV8_IOR(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2))) : WORD8 => ior(w1,w2) = BV8_TO_WORD8(BV8_IOR(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2)))|->bool(BV8_TO_WORD8(BV8_IOR(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2))) = 0)) & xor : WORD8*WORD8 +-> WORD8*BOOL & dom(xor) = WORD8*WORD8 & !(w1,w2).(w1 : WORD8 & w2 : WORD8 & BV8_TO_WORD8(BV8_XOR(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2))) : WORD8 => xor(w1,w2) = BV8_TO_WORD8(BV8_XOR(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2)))|->bool(BV8_TO_WORD8(BV8_XOR(WORD8_TO_BV8(w1),WORD8_TO_BV8(w2))) = 0)) & bitget : WORD8*WORD8_POSITION +-> BIT & dom(bitget) = WORD8*WORD8_POSITION & !(w,i).(w : WORD8 & i : WORD8_POSITION => bitget(w,i) = WORD8_TO_BV8(w)(i)) & bitset : WORD8*WORD8_POSITION +-> WORD8 & dom(bitset) = WORD8*WORD8_POSITION & !(w,i).(w : WORD8 & i : WORD8_POSITION => bitset(w,i) = BV8_TO_WORD8(BV8_SET_BIT(WORD8_TO_BV8(w),i,1))) & bitclear : WORD8*WORD8_POSITION +-> WORD8 & dom(bitclear) = WORD8*WORD8_POSITION & !(w,i,b).(w : WORD8 & i : WORD8_POSITION & b : BIT => bitclear(w,i) = BV8_TO_WORD8(BV8_SET_BIT(WORD8_TO_BV8(w),i,0))) & complement : WORD8 +-> WORD8 & dom(complement) = WORD8 & !w.(w : WORD8 => complement(w) = BV8_TO_WORD8(BV8_COMPLEMENT(WORD8_TO_BV8(w)))) & swap : WORD8 +-> WORD8 & dom(swap) = WORD8 & !w.(w : WORD8 & WORD8_TO_BV8(w) : BV8 => swap(w) = BV8_TO_WORD8({0|->WORD8_TO_BV8(w)(4)}\/{1|->WORD8_TO_BV8(w)(5)}\/{2|->WORD8_TO_BV8(w)(6)}\/{3|->WORD8_TO_BV8(w)(7)}\/{4|->WORD8_TO_BV8(w)(0)}\/{5|->WORD8_TO_BV8(w)(1)}\/{6|->WORD8_TO_BV8(w)(2)}\/{7|->WORD8_TO_BV8(w)(3)})) & rotateleft : WORD8 +-> WORD8*BOOL & dom(rotateleft) = WORD8 & !w.(w : WORD8 & WORD8_TO_BV8(w) : BV8 => rotateleft(w) = BV8_TO_WORD8({0|->WORD8_TO_BV8(w)(7)}\/{1|->WORD8_TO_BV8(w)(0)}\/{2|->WORD8_TO_BV8(w)(1)}\/{3|->WORD8_TO_BV8(w)(2)}\/{4|->WORD8_TO_BV8(w)(3)}\/{5|->WORD8_TO_BV8(w)(4)}\/{6|->WORD8_TO_BV8(w)(5)}\/{7|->WORD8_TO_BV8(w)(6)})|->bool(WORD8_TO_BV8(w)(7) = 1)) & rotateright : WORD8 +-> WORD8*BOOL & dom(rotateright) = WORD8 & !w.(w : WORD8 & WORD8_TO_BV8(w) : BV8 => rotateright(w) = BV8_TO_WORD8({0|->WORD8_TO_BV8(w)(1)}\/{1|->WORD8_TO_BV8(w)(2)}\/{2|->WORD8_TO_BV8(w)(3)}\/{3|->WORD8_TO_BV8(w)(4)}\/{4|->WORD8_TO_BV8(w)(5)}\/{5|->WORD8_TO_BV8(w)(6)}\/{6|->WORD8_TO_BV8(w)(7)}\/{7|->WORD8_TO_BV8(w)(0)})|->bool(WORD8_TO_BV8(w)(0) = 1)) & "`Component properties'" & not((1..18)*{id_register8} = {}));
  ("`Seen and used machines assertions'" & NB_WORD8S = 256 & !n.(n : WORD8 => 0<=n) & !n.(n : WORD8 => n<=255) & WORD8_POSITION = BV8_INDEX & BIT_FLIP(0) = 1 & BIT_FLIP(1) = 0 & BIT_AND(0,0) = 0 & BIT_AND(0,1) = 0 & BIT_AND(1,0) = 0 & BIT_AND(1,1) = 1 & BIT_IOR(0,0) = 0 & BIT_IOR(0,1) = 0 & BIT_IOR(1,0) = 0 & BIT_IOR(1,1) = 1 & BIT_XOR(0,0) = 0 & BIT_XOR(0,1) = 1 & BIT_XOR(1,0) = 1 & BIT_XOR(1,1) = 0 & dom(add) = WORD8*WORD8 & ran(add) : POW(WORD8*BOOL*BOOL) & dom(substract) = WORD8*WORD8 & ran(substract) : POW(WORD8*BOOL*BOOL) & dom(and) = WORD8*WORD8 & ran(and) : POW(WORD8*BOOL) & dom(ior) = WORD8*WORD8 & ran(ior) : POW(WORD8*BOOL) & dom(xor) = WORD8*WORD8 & ran(xor) : POW(WORD8*BOOL) & dom(bitclear) = WORD8*WORD8_POSITION & ran(bitclear) : POW(WORD8) & dom(bitset) = WORD8*WORD8_POSITION & ran(bitset) : POW(WORD8) & dom(bitget) = WORD8*WORD8_POSITION & ran(bitget) : POW(BIT) & dom(complement) = WORD8 & ran(complement) : POW(WORD8) & dom(swap) = WORD8 & ran(swap) : POW(WORD8) & ran(rotateleft) : POW(WORD8*BOOL) & dom(rotateleft) = WORD8 & dom(rotateright) = WORD8 & ran(rotateright) : POW(WORD8*BOOL));
  ("`Component invariant'" & stack : WORD16 +-> WORD16 & dom(stack) = WORD16 & rgs8 : (1..18)*{id_register8} +-> WORD8 & dom(rgs8) = (1..18)*{id_register8} & mem : WORD16 +-> WORD8 & dom(mem) = WORD16 & pc : WORD16 & sp : WORD16 & ix : WORD16 & iy : WORD16);
  "`Check assertion (INSTRUCTION_NEXT(9) = 10) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(9) = 10);
  "`Check assertion (INSTRUCTION_NEXT(8) = 9) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(8) = 9);
  "`Check assertion (INSTRUCTION_NEXT(7) = 8) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(7) = 8);
  "`Check assertion (INSTRUCTION_NEXT(6) = 7) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(6) = 7);
  "`Check assertion (INSTRUCTION_NEXT(5) = 6) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(5) = 6);
  "`Check assertion (INSTRUCTION_NEXT(4) = 5) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(4) = 5);
  "`Check assertion (INSTRUCTION_NEXT(3) = 4) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(3) = 4);
  "`Check assertion (INSTRUCTION_NEXT(2) = 3) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(2) = 3);
  "`Check assertion (INSTRUCTION_NEXT(1) = 2) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(1) = 2);
  "`Check assertion (INSTRUCTION_NEXT(0) = 1) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(0) = 1);
  "`Check assertion (ran(rgs8) <: WORD8) deduction - ref 3.2, 4.2, 5.3'";
  (ran(rgs8) : POW(WORD8));
  "`Check assertion (ran(mem) <: WORD8) deduction - ref 3.2, 4.2, 5.3'";
  (ran(mem) : POW(WORD8));
  "`Check assertion (ran(stack) <: WORD16) deduction - ref 3.2, 4.2, 5.3'";
  (ran(stack) : POW(WORD16));
  ("`Component assertions'" & dom(stack) = WORD16 & ran(stack) : POW(WORD16) & ran(mem) : POW(WORD8) & dom(mem) = WORD16 & ran(rgs8) : POW(WORD8) & dom(rgs8) = (1..18)*{id_register8} & INSTRUCTION_NEXT(0) = 1 & INSTRUCTION_NEXT(1) = 2 & INSTRUCTION_NEXT(2) = 3 & INSTRUCTION_NEXT(3) = 4 & INSTRUCTION_NEXT(4) = 5 & INSTRUCTION_NEXT(5) = 6 & INSTRUCTION_NEXT(6) = 7 & INSTRUCTION_NEXT(7) = 8 & INSTRUCTION_NEXT(8) = 9 & INSTRUCTION_NEXT(9) = 10);
  ("`CALL preconditions in this component'" & k : INSTRUCTION);
  "`Check that the invariant (stack : WORD16 --> WORD16) is preserved by the operation - ref 3.4'";
  (stack<+{sp|->INSTRUCTION_NEXT(pc)} : WORD16 +-> WORD16);
  (dom(stack<+{sp|->INSTRUCTION_NEXT(pc)}) = WORD16);
  "`Check that the invariant (pc : WORD16) is preserved by the operation - ref 3.4'";
  (k : WORD16);
  "`Check that the invariant (sp : WORD16) is preserved by the operation - ref 3.4'";
  (sp+1 : WORD16);
  ("`RETURN preconditions in this component'" & 1<=sp);
  ({sp-1}<<|stack : WORD16 +-> WORD16);
  (dom({sp-1}<<|stack) = WORD16);
  (stack(sp-1) : WORD16);
  (sp-1 : WORD16);
  ("`LD_r_r_ preconditions in this component'" & rr : (1..18)*{id_register8} & rr_ : (1..18)*{id_register8});
  "`Check that the invariant (rgs8 : id_register8 --> WORD8) is preserved by the operation - ref 3.4'";
  (rgs8<+{rr|->rgs8(rr_)} : (1..18)*{id_register8} +-> WORD8);
  (dom(rgs8<+{rr|->rgs8(rr_)}) = (1..18)*{id_register8});
  "`Check that the invariant (pc : WORD16) is preserved by the operation - ref 3.4'";
  (INSTRUCTION_NEXT(pc) : WORD16);
  ("`LD_r_n_ preconditions in this component'" & rr : (1..18)*{id_register8} & n : WORD8);
  (rgs8<+{rr|->n} : (1..18)*{id_register8} +-> WORD8);
  (dom(rgs8<+{rr|->n}) = (1..18)*{id_register8});
  ("`LD_r_HL preconditions in this component'" & rr : (1..18)*{id_register8});
  ("`Local hypotheses'" & address : WORD16 & address = WORD8_TO_WORD16(rgs8(13|->id_register8),rgs8(14|->id_register8)));
  (rgs8<+{rr|->mem(address)} : (1..18)*{id_register8} +-> WORD8);
  (dom(rgs8<+{rr|->mem(address)}) = (1..18)*{id_register8});
  ("`LD_HL_r preconditions in this component'" & rr : (1..18)*{id_register8});
  "`Check that the invariant (mem : WORD16 --> WORD8) is preserved by the operation - ref 3.4'";
  (mem<+{address|->rgs8(rr)} : WORD16 +-> WORD8);
  (dom(mem<+{address|->rgs8(rr)}) = WORD16);
  ("`BIT_b_HL preconditions in this component'" & bb : 0..WORD8_LENGTH-1);
  ("`Local hypotheses'" & address : WORD16 & ib : BIT & nw8 : BV8 & address = WORD8_TO_WORD16(rgs8(13|->id_register8),rgs8(14|->id_register8)) & ib = WORD8_TO_BV8(mem(address))(bb) & nw8 = BV8_SET_BIT(WORD8_TO_BV8(rgs8(3|->id_register8)),6,ib));
  (rgs8<+{3|->id_register8|->BV8_TO_WORD8(nw8)} : (1..18)*{id_register8} +-> WORD8);
  (dom(rgs8<+{3|->id_register8|->BV8_TO_WORD8(nw8)}) = (1..18)*{id_register8});
  ("`Local hypotheses'" & WORD8_TO_BV8(rgs8(3|->id_register8))(6) = 0);
  ("`Local hypotheses'" & not(WORD8_TO_BV8(rgs8(3|->id_register8))(6) = 0));
  (INSTRUCTION_NEXT(INSTRUCTION_NEXT(pc)) : WORD16);
  ("`SET_b_HL preconditions in this component'" & bb : 0..WORD8_LENGTH-1);
  ("`Local hypotheses'" & address : WORD16 & nw8 : BV8 & address = WORD8_TO_WORD16(rgs8(13|->id_register8),rgs8(14|->id_register8)) & nw8 = BV8_SET_BIT(WORD8_TO_BV8(mem(address)),bb,1));
  (mem<+{address|->BV8_TO_WORD8(nw8)} : WORD16 +-> WORD8);
  (dom(mem<+{address|->BV8_TO_WORD8(nw8)}) = WORD16);
  ("`RES_b_HL preconditions in this component'" & bb : 0..WORD8_LENGTH-1);
  ("`Local hypotheses'" & address : WORD16 & nw8 : BV8 & address = WORD8_TO_WORD16(rgs8(13|->id_register8),rgs8(14|->id_register8)) & nw8 = BV8_SET_BIT(WORD8_TO_BV8(mem(address)),bb,0));
  ("`GOTO preconditions in this component'" & k : INSTRUCTION)
END
&
THEORY EnumerateX IS
  id_register8 == {a,f,f_,a_,b,c,b_,c_,d,e,d_,e_,h,l,h_,l_,i,r}
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
