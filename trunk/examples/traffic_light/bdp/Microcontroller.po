THEORY ProofList IS
  _f(6) & _f(57) & dec.1,(_f(8) => _f(58));
  _f(6) & _f(55) & inc.1,(_f(8) => _f(56));
  _f(6) & _f(53) & set_data.4,(_f(16) => _f(18));
  _f(6) & _f(53) & set_data.3,(_f(16) => _f(17));
  _f(6) & _f(53) & set_data.2,(_f(8) => _f(54));
  _f(6) & _f(53) & set_data.1,(_f(8) => _f(9));
  _f(6) & _f(50) & reset.2,(_f(8) => _f(52));
  _f(6) & _f(50) & reset.1,(_f(8) => _f(51));
  _f(6) & _f(46) & move_m_w.2,(_f(47) => _f(49));
  _f(6) & _f(46) & move_m_w.1,(_f(47) => _f(48));
  _f(6) & _f(43) & move_w_m.2,(_f(8) => _f(45));
  _f(6) & _f(43) & move_w_m.1,(_f(8) => _f(44));
  _f(6) & _f(40) & move.2,(_f(8) => _f(42));
  _f(6) & _f(40) & move.1,(_f(8) => _f(41));
  _f(6) & _f(33) & isequal.6,(_f(36) & _f(22) => _f(39));
  _f(6) & _f(33) & isequal.5,(_f(36) & _f(16) => _f(38));
  _f(6) & _f(33) & isequal.4,(_f(36) & _f(16) => _f(37));
  _f(6) & _f(33) & isequal.3,(_f(34) & _f(22) => _f(35));
  _f(6) & _f(33) & isequal.2,(_f(34) & _f(16) => _f(18));
  _f(6) & _f(33) & isequal.1,(_f(34) & _f(16) => _f(17));
  _f(6) & _f(29) & nop.2,(_f(30) => _f(18));
  _f(6) & _f(29) & nop.1,(_f(30) => _f(17));
  _f(6) & _f(24) & pop_2.1,(_f(12) => _f(25));
  _f(6) & _f(19) & pop_1.3,(_f(22) => _f(23));
  _f(6) & _f(19) & pop_1.2,(_f(16) => _f(21));
  _f(6) & _f(19) & pop_1.1,(_f(16) => _f(20));
  _f(6) & _f(11) & push.4,(_f(16) => _f(18));
  _f(6) & _f(11) & push.3,(_f(16) => _f(17));
  _f(6) & _f(11) & push.2,(_f(14) => _f(15));
  _f(6) & _f(11) & push.1,(_f(12) => _f(13));
  _f(6) & _f(7) & init_data.1,(_f(8) => _f(9));
  Initialisation.2,(_f(1) & _f(4) => _f(5));
  Initialisation.1,(_f(1) & _f(2) => _f(3))
END
&
THEORY Formulas IS
  ("`Local hypotheses'" & memory_data$0 : NATURAL +-> NATURAL & dom(memory_data$0) = NATURAL);
  "`Check that the invariant (stack : 1..8 +-> NATURAL) is established by the initialisation - ref 3.3'";
  ({1|->0}\/{2|->0}\/{3|->0}\/{4|->0}\/{5|->0}\/{6|->0}\/{7|->0}\/{8|->0} : 1..8 +-> NATURAL);
  "`Check that the invariant (card(stack)<=8) is established by the initialisation - ref 3.3'";
  (card({1|->0}\/{2|->0}\/{3|->0}\/{4|->0}\/{5|->0}\/{6|->0}\/{7|->0}\/{8|->0})<=8);
  ("`Component invariant'" & memory_data : NATURAL +-> NATURAL & dom(memory_data) = NATURAL & stack : 1..8 +-> NATURAL & card(stack)<=8 & w : INTEGER & 0<=w & pc : INTEGER & 0<=pc & end : INTEGER & 0<=end & pc<=end);
  ("`init_data preconditions in this component'" & address : INTEGER & 0<=address & value : INTEGER & 0<=value & dom(memory_data<+{address|->value}) = NATURAL);
  "`Check that the invariant (memory_data : NATURAL --> NATURAL) is preserved by the operation - ref 3.4'";
  (memory_data<+{address|->value} : NATURAL +-> NATURAL);
  ("`init preconditions in this component'" & pc_ : INTEGER & 0<=pc_ & end_ : INTEGER & 0<=end_ & pc_<=end_);
  ("`push preconditions in this component'" & card(stack)+1<=8 & stack<+{card(stack)+1|->pc} : 0..7 +-> NATURAL & pc+1<=end & card(dom(stack))+1<=8);
  "`Check that the invariant (stack : 1..8 +-> NATURAL) is preserved by the operation - ref 3.4'";
  (stack<+{card(stack)+1|->pc} : 1..8 +-> NATURAL);
  "`Check that the invariant (card(stack)<=8) is preserved by the operation - ref 3.4'";
  (card(stack<+{card(stack)+1|->pc})<=8);
  "`Check that the invariant (pc : NATURAL) is preserved by the operation - ref 3.4'";
  (pc+1 : INTEGER);
  (0<=pc+1);
  ("`pop_1 preconditions in this component'" & stack(card(stack))+1<=end);
  (stack(card(stack)) : INTEGER);
  (0<=stack(card(stack)));
  "`Check that the invariant (pc<=end) is preserved by the operation - ref 3.4'";
  (stack(card(stack))<=end);
  ("`pop_2 preconditions in this component'" & card({card(stack)}<<|stack)<=8 & 1<=card(stack));
  ({card(stack)}<<|stack : 1..8 +-> NATURAL);
  ("`get_data preconditions in this component'" & address : INTEGER & 0<=address);
  ("`set_end preconditions in this component'" & value : INTEGER & 0<=value & pc<=value);
  ("`set_w preconditions in this component'" & value : INTEGER & 0<=value);
  ("`nop preconditions in this component'" & pc+1<=end);
  "`Check that the invariant (pc : NATURAL) is preserved by the operation - ref 3.4'";
  ("`goto preconditions in this component'" & value : INTEGER & 0<=value & value<=end);
  ("`iszero preconditions in this component'" & address : INTEGER & 0<=address & (memory_data(address) = 0 => pc+1 : INTEGER & 0<=pc+1 & pc+1<=end) & (not(memory_data(address) = 0) => pc+2 : INTEGER & 0<=pc+2 & pc+2<=end));
  ("`isequal preconditions in this component'" & address_1 : INTEGER & 0<=address_1 & value : INTEGER & 0<=value & pc+2+1<=end);
  ("`Local hypotheses'" & memory_data(address_1) = value);
  (pc+1<=end);
  ("`Local hypotheses'" & not(memory_data(address_1) = value));
  (pc+2 : INTEGER);
  (0<=pc+2);
  (pc+2<=end);
  ("`move preconditions in this component'" & address_s : INTEGER & 0<=address_s & address_t : INTEGER & 0<=address_t & pc+1<=end & pc+1 : INTEGER & 0<=pc+1);
  (memory_data<+{address_t|->memory_data(address_s)} : NATURAL +-> NATURAL);
  (dom(memory_data<+{address_t|->memory_data(address_s)}) = NATURAL);
  ("`move_w_m preconditions in this component'" & address : INTEGER & 0<=address & pc+1<=end & pc+1 : INTEGER & 0<=pc+1);
  (memory_data<+{address|->w} : NATURAL +-> NATURAL);
  (dom(memory_data<+{address|->w}) = NATURAL);
  ("`move_m_w preconditions in this component'" & address : INTEGER & 0<=address & pc+1<=end & pc+1 : INTEGER & 0<=pc+1);
  "`Check that the invariant (w : NATURAL) is preserved by the operation - ref 3.4'";
  (memory_data(address) : INTEGER);
  (0<=memory_data(address));
  ("`reset preconditions in this component'" & address : INTEGER & 0<=address & memory_data(address) : INTEGER & 0<=memory_data(address) & pc+1<=end & pc+1 : INTEGER & 0<=pc+1);
  (memory_data<+{address|->0} : NATURAL +-> NATURAL);
  (dom(memory_data<+{address|->0}) = NATURAL);
  ("`set_data preconditions in this component'" & address : INTEGER & 0<=address & value : INTEGER & 0<=value & pc+1<=end);
  (dom(memory_data<+{address|->value}) = NATURAL);
  ("`inc preconditions in this component'" & address : INTEGER & 0<=address & memory_data(address)+1 : INTEGER & 0<=memory_data(address)+1 & pc+1 : INTEGER & 0<=pc+1 & pc+1<=end & dom(memory_data<+{address|->memory_data(address)+1}) = NATURAL);
  (memory_data<+{address|->memory_data(address)+1} : NATURAL +-> NATURAL);
  ("`dec preconditions in this component'" & address : INTEGER & 0<=address & memory_data(address)-1 : INTEGER & 0<=memory_data(address)-1 & pc+1 : INTEGER & 0<=pc+1 & pc+1<=end & dom(memory_data<+{address|->memory_data(address)-1}) = NATURAL);
  (memory_data<+{address|->memory_data(address)-1} : NATURAL +-> NATURAL);
  ("`add preconditions in this component'" & address1 : INTEGER & 0<=address1 & address2 : INTEGER & 0<=address2 & memory_data(address1)+memory_data(address2) : INTEGER & 0<=memory_data(address1)+memory_data(address2));
  ("`sub preconditions in this component'" & address1 : INTEGER & 0<=address1 & address2 : INTEGER & 0<=address2 & memory_data(address1)-memory_data(address2) : INTEGER & 0<=memory_data(address1)-memory_data(address2));
  ("`mul preconditions in this component'" & address1 : INTEGER & 0<=address1 & address2 : INTEGER & 0<=address2 & memory_data(address1)*memory_data(address2) : INTEGER & 0<=memory_data(address1)*memory_data(address2));
  ("`div preconditions in this component'" & address1 : INTEGER & 0<=address1 & address2 : INTEGER & 0<=address2 & memory_data(address1)/memory_data(address2) : INTEGER & 0<=memory_data(address1)/memory_data(address2))
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
