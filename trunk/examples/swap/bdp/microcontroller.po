THEORY ProofList IS
  _f(1) & _f(28) & inc.4,(_f(10) => _f(12));
  _f(1) & _f(28) & inc.3,(_f(10) => _f(11));
  _f(1) & _f(28) & inc.2,(_f(3) => _f(30));
  _f(1) & _f(28) & inc.1,(_f(3) => _f(29));
  _f(1) & _f(27) & set_data.4,(_f(10) => _f(12));
  _f(1) & _f(27) & set_data.3,(_f(10) => _f(11));
  _f(1) & _f(27) & set_data.2,(_f(3) => _f(5));
  _f(1) & _f(27) & set_data.1,(_f(3) => _f(4));
  _f(1) & _f(24) & move.4,(_f(10) => _f(12));
  _f(1) & _f(24) & move.3,(_f(10) => _f(11));
  _f(1) & _f(24) & move.2,(_f(3) => _f(26));
  _f(1) & _f(24) & move.1,(_f(3) => _f(25));
  _f(1) & _f(21) & testeq.4,(_f(23) & _f(10) => _f(18));
  _f(1) & _f(21) & testeq.3,(_f(23) & _f(10) => _f(17));
  _f(1) & _f(21) & testeq.2,(_f(22) & _f(10) => _f(12));
  _f(1) & _f(21) & testeq.1,(_f(22) & _f(10) => _f(11));
  _f(1) & _f(14) & testgt.5,(_f(16) & _f(19) => _f(20));
  _f(1) & _f(14) & testgt.4,(_f(16) & _f(10) => _f(18));
  _f(1) & _f(14) & testgt.3,(_f(16) & _f(10) => _f(17));
  _f(1) & _f(14) & testgt.2,(_f(15) & _f(10) => _f(12));
  _f(1) & _f(14) & testgt.1,(_f(15) & _f(10) => _f(11));
  _f(1) & _f(9) & nop.2,(_f(10) => _f(12));
  _f(1) & _f(9) & nop.1,(_f(10) => _f(11));
  _f(1) & _f(2) & init_data.2,(_f(3) => _f(5));
  _f(1) & _f(2) & init_data.1,(_f(3) => _f(4))
END
&
THEORY Formulas IS
  ("`Component invariant'" & mem : NATURAL +-> NATURAL & dom(mem) = NATURAL & pc : INTEGER & 0<=pc & end : INTEGER & 0<=end & pc<=end);
  ("`init_data preconditions in this component'" & address : INTEGER & 0<=address & value : INTEGER & 0<=value);
  "`Check that the invariant (mem : NATURAL --> NATURAL) is preserved by the operation - ref 3.4'";
  (mem<+{address|->value} : NATURAL +-> NATURAL);
  (dom(mem<+{address|->value}) = NATURAL);
  ("`init preconditions in this component'" & pc_ : INTEGER & 0<=pc_ & end_ : INTEGER & 0<=end_ & pc_<=end_);
  ("`get_data preconditions in this component'" & address : INTEGER & 0<=address);
  ("`set_end preconditions in this component'" & value : INTEGER & 0<=value & pc<=value);
  ("`nop preconditions in this component'" & pc+1<=end);
  "`Check that the invariant (pc : NATURAL) is preserved by the operation - ref 3.4'";
  (pc+1 : INTEGER);
  (0<=pc+1);
  ("`goto preconditions in this component'" & value : INTEGER & 0<=value & value<=end);
  ("`testgt preconditions in this component'" & address1 : INTEGER & 0<=address1 & address2 : INTEGER & 0<=address2 & (mem(address2)+1<=mem(address1) => pc+1<=end) & (mem(address1)<=mem(address2) => pc+2<=end));
  ("`Local hypotheses'" & mem(address2)+1<=mem(address1));
  ("`Local hypotheses'" & not(mem(address2)+1<=mem(address1)));
  (pc+2 : INTEGER);
  (0<=pc+2);
  "`Check that the invariant (pc<=end) is preserved by the operation - ref 3.4'";
  (pc+2<=end);
  ("`testeq preconditions in this component'" & address1 : INTEGER & 0<=address1 & address2 : INTEGER & 0<=address2 & (mem(address1) = mem(address2) => pc+1<=end) & (not(mem(address1) = mem(address2)) => pc+2<=end));
  ("`Local hypotheses'" & mem(address1) = mem(address2));
  ("`Local hypotheses'" & not(mem(address1) = mem(address2)));
  ("`move preconditions in this component'" & address_s : INTEGER & 0<=address_s & address_t : INTEGER & 0<=address_t & pc+1<=end);
  (mem<+{address_t|->mem(address_s)} : NATURAL +-> NATURAL);
  (dom(mem<+{address_t|->mem(address_s)}) = NATURAL);
  ("`set_data preconditions in this component'" & address : INTEGER & 0<=address & value : INTEGER & 0<=value & pc+1<=end);
  ("`inc preconditions in this component'" & address : INTEGER & 0<=address & pc+1<=end);
  (mem<+{address|->mem(address)+1} : NATURAL +-> NATURAL);
  (dom(mem<+{address|->mem(address)+1}) = NATURAL)
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
