\documentclass{llncs}

\usepackage{graphicx,array}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}


\include{comandos}
\include{SymbolsB_AtelierB} 


%
\begin{document}

\title{Formal Verification of Real Models from Platforms Using The B-method }


\author{B. Dantas \inst{1}, David D\'{e}harbe\inst{1}, Val\'{e}rio Medeiros Jr\inst{1} }

\institute{Federal University of Rio Grande do Norte, Natal RN 59078-970, Brazil}

\maketitle

\begin{abstract}
This paper describes an approach to model the microcontroller platforms. More specifically, it shows details about
the Z80 model. The model is created using the B method; it applies math and logic concepts to describe the
characteristics from platforms. Therefore, this model can be used in platforms projects to document, build
simulators, verify properties about the model and verify the software in assembly level. The verification in
assembly is the feature more important, because this allow the developing software faithful to the algorithm
language. Finally, this paper show some relevant techniques used in models and to describe several details.
\end{abstract}
%
%\keywords{Fomal Methods, Microprocessor Verification, Hardware}

\section{Introduction}

The B method allows the construction of safety computacional systems by proofs verification and generation
that guarantees the compatibility among modelling steps and that the system desirable state allways be
true.Therefore, a initial abstract model of the system is defined and refined until the implementation
level. B still allows the code generation from implementation, but this fase isn't verified.

In\cite{Dantas_Report08} is presented a approach to complement the B method until the codify level:
extension of the B method until the assembly level. In this approach, the system construct beggining from
the abstract level and it is formally refined until the target plataform assembly. Therefore, the first
step of this approach is the target plataform modelling, the microprocessor, in B. Using the
responsability division mechanism provide by B basic modules was developted to be used as elementary
library to constructing generic microprocessor, in which bit data type, bit arrays and others are
specified together with its operations\cite{Medeiros}. The resulting processor B machine  will be used as
library in which its operations are used in the modelling of the systems. The use of this library occurs
at the B implementation level of the system. 

The processor modelling can be used in plataforms project documentation, simulators construction,
consistency verification and software verification at assembly level. The verification at assembly level
is more interesting utility because allows the developtment of trustworth software by construction, that
is extremaly desirable in embedded critical software.

In this paper we introduced the modelling of Z80 processor\cite{Z80}, since elementary library until
assembly instructions. The paper is structured as follows. Section\ref{B Notation} provides a general introduction
to the B method.Section\ref{General definitions for hardware models} presents the elementary library of
microprocessors basic concepts. Section\ref{Description of the B model from Z80} presents the Z80 B
modelling. Section\ref{} TERMINAR

% Explica o contexto geral do artigo
%  Porque modelar os microcontroladores. \footnote{The interested reader in details from full specification or in
% other study case is invited to visit the repository from authors at \url{http://b2asm.googlecode.com}.
%    Porque podemos verificar várias propriedades em tempo de projeto, documentar, simulacao através das ferramentas de suporte do método B...
%    Porque permite verificar software em nível de assemblagem.[citar trabalho de BHDL]
%    Porque utilizamos o método B puro  - [citar proposta do ALEMAO do ProB]
%  Contextualizacao com grande desafio da verificao formal em nivel de assemblagem[citar grande challenge] 
%  Conclusão da introducao.
%  Organizacao do paper
%  Basear-se no Relatorio técnico e no ERMAC
%
% - Citar o Atelierb



[I need to Review this below text and to answer some questions]
%  What the objectives from this models ?
%  The objectives from this models are: supply a documentation that help the
%  directly in the development and guarantees a series of properties. This
%  properties are about hardware and software that run in this platform. The
%  properties verification about software allow to verify software in the
%  assembly level and It`s provide a high level of security, cause the mains
%  levels of representation of software are verified, according to
%  \cite{DANTAS08_SBMF}.

% Why don´t we use a language based in events, how Event-B or CSP? 
%  Because, we want to prover importants properties about the software and 	
%  the B-method is more appropriate and don´t lost the capacity of verification
%  about hardware level.

% What are the advantages to use the B method ? The biggest advantage is the
% formal verification on assembly level.  

% Once established the model of the platform, so I could check something on VHDL?
% Or generate VHDL?



\section{B Notation}

[One page]


\subsubsection{Desing components B }
[half page]
[Explicar como as coias são modeladas]
% Use the tech report


\section{General definitions for hardware models}

We think that We find it convenient to provide a set of basic definitions to model hardware concepts. These
definitions are grouped in a library that we named $\mathit{HARDWARE\_LIBRARY}$ and arrange through four modules:
$\mathit{BIT\_DEFINITION}$, $\mathit{BIT\_VECTOR\_DEFINITION}$, $\mathit{BYTE\_DEFINITION}$ and
$\mathit{BIT\_VECTOR\_ARITHMETICS}$.

[[Explain better the figure]]

The dependency graph between these modules is depicted in
Figure~\ref{fig:hardware-definition-graph}.


\begin{figure}[h]
\centering
\includegraphics[width=.7\textwidth]{diagramaEstrutural.jpg}
\caption{Dependencies between modules of $\mathit{HARDWARE\_LIBRARY}$ and
platform model.}
\label{fig:hardware-definition-graph}

\end{figure}

Now, We will explain each of these modules and present them in detail.

\subsection{Definitions to represent and manipulate bits}

The entities defined in the module $\mathit{BIT\_DEFINITION}$ are the
type for bits, logical operations on bits (negation, conjunction,
disjunction, exclusive disjunction), as well as a conversion function
from booleans to bits.

First, bits are modeled as the set of integers $\{0, 1\}$:\\

$
\begin{array}{l}
\mathit{BIT} = \mathit{0..1} \\ 
\end{array}
$

The negation is a unary function on bits and it is defined as:

$
\begin{array}{l}
\mathit{bit\_not}  \in  \mathit{BIT}  \fun  \mathit{BIT}  \land \\
\forall ( \mathit{bb}). (\mathit{bb} \in \mathit{BIT} \implies \mathit{bit\_not}(\mathit{bb}) =
1-\mathit{bb})\\
\end{array}
$

The module also provides lemmas on negation that may be useful for the users of the library to develop proofs:

$
\begin{array}{l}
 \mathit{bit\_not}(0) = 1;  \mathit{bit\_not}(1) = 0; \\
\forall (\mathit{bb}).(\mathit{bb} \in \mathit{BIT} \implies \mathit{bit\_not}(\mathit{bit\_not}(\mathit{bb})) = \mathit{bb});
\end{array}
$

Conjunction is a unary function on bits and it is defined as:

$
\begin{array}{l}
\mathit{bit\_and} \in \mathit{BIT} \times \mathit{BIT} \fun \mathit{BIT} \land \\
\forall (\mathit{b1}, \mathit{b2}).(\mathit{b1}  \in \mathit{BIT}  \land \mathit{b2} \in \mathit{BIT} \implies \\
\quad ((\mathit{bit\_and}(\mathit{b1}, \mathit{b2}) = 1) \iff (\mathit{b1} = 1)  \land  (\mathit{b2} = 1)))
\end{array}
$

The module provides the following lemmas for conjunction, either:

$
\begin{array}{l}
 \mathit{bit\_and}(0,0) = 0;  \mathit{bit\_and}(0,1) = 0; \\
 \mathit{bit\_and}(1,0) = 0;  \mathit{bit\_and}(1,1) = 1; \\
\forall (\mathit{b1},\mathit{b2}).(\mathit{b1} \in \mathit{BIT} \land \mathit{b2} \in \mathit{BIT} \implies \\
\quad (\mathit{bit\_and}(\mathit{b1}, \mathit{b2}) = \mathit{bit\_and}(\mathit{b2},\mathit{b1}))); \\
\forall (\mathit{b1},\mathit{b2},\mathit{b3}).(\mathit{b1} \in \mathit{BIT} \land  \mathit{b2} \in \mathit{BIT} \land \mathit{b3} \in \mathit{BIT} \implies \\
\quad (\mathit{bit\_and}(\mathit{b1}, \mathit{bit\_and}(\mathit{b2},\mathit{b3})) = \mathit{bit\_and}(\mathit{bit\_and}(\mathit{b1},\mathit{b2}),\mathit{b3}))); \\
\forall (\mathit{b1}).(\mathit{b1} \in \mathit{BIT} \implies (\mathit{bit\_and}(\mathit{b1}, 1) = \mathit{b1})); \\
\forall (\mathit{b1}).(\mathit{b1} \in \mathit{BIT} \implies (\mathit{bit\_and}(\mathit{b1}, 0) = 0));
\end{array}
$

The module provides definitions of $\mathit{bit\_or}$ (disjunction) and $\mathit{bit\_xor}$ (exclusive disjunction),
as well as lemmas on those operators. These are standard and their expression in B is similar as for$\mathit{bit\_and}$, they are thus omitted.

Finally, the conversion from booleans to bits is simply defined as:

$
\begin{array}{l}
\mathit{bool\_to\_bit} \in \BOOL \fun \mathit{BIT} \land \mathit{bool\_to\_bit} = \{ \TRUE \mapsto 1, \FALSE \mapsto 0 \} \\
\end{array}
$

Observe that all the lemmas that are provided in this module have been
mechanically proved by the theorem prover included with our B
development environment. None of these proofs requires human insight.


\subsection{Representation and manipulation of bit vectors}

Sequences are pre-defined in B, as functions whose the domain is an integer range with lower bound 1 (one). Indices
in bit vectors usually range from 0 (zero) upwards and the model we propose obeys this convention by making an
one-position shift where necessary.  We thus define bit vectors as non-empty sequences of bits, and
$\mathit{BIT\_VECTOR}$ is the set of all such sequences:

$
\begin{array}{l}
\mathit{BIT\_VECTOR} = \seq (\mathit{BIT})
\end{array}
$

The function $\mathit{bv\_size}$ returns the size of a given bit vector. It is basically a wrapper for the
predefined function $\mathbf{size}$ that applies to sequences.

$
\begin{array}{l}
\mathit{bv\_size} \in \mathit{BIT\_VECTOR} \fun \nat_1 \land \\
\mathit{bv\_size} = \lambda bv \bullet (bv \in \mathit{BIT\_VECTOR} \mid \mathbf{size}(bv))
\end{array}
$

We also define two functions $\mathit{bv\_set}$ and $\mathit{bv\_clear}$ that, given a bit vector, and a position of
the bit vector, return the bit vector resulting from setting the corresponding position to 0 or to 1, and a function
$\mathit{bv\_get}$ that, given a bit vector, and a valid position, each one returns the value of the bit at that
position. Only the first definition is shown here:

$
\begin{array}{l}
\mathit{bv\_set} \in \mathit{BIT\_VECTOR} \times \nat \fun \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_set} = \lambda v, n \bullet (v \in \mathit{BIT\_VECTOR} \land 0 \in \nat \land n < \mathit{bv\_size}(v) \mid v \ovr \{ n+1 \mapsto 1 \})
\end{array}
$

The function $bv\_catenate$ takes as parameters two bit vectors $v$ and $w$, and returns the result of the
concatenation of $v$ and $w$, such that $v$ constitutes the most significant part of the result.

% $
% \begin{array}{l}
% \mathit{bv\_catenate} \in \mathit{BIT\_VECTOR} \times \mathit{BIT\_VECTOR} \fun \mathit{BIT\_VECTOR} \land \\
% \mathit{bv\_catenate} = \lambda v, w \bullet (v \in \mathit{ BIT\_VECTOR} \land w \in \mathit{ BIT\_VECTOR}  \mid v 
% %\conc
%   w)
% \end{array}
% $


\hspace*{0.00in} \it bv\_catenate  $\in$  \it BIT\_VECTOR  $\times$  \it BIT\_VECTOR  $\fun$ \it BIT\_VECTOR $\land$ 

\hspace*{0.00in} \it bv\_catenate \rm =  $\lambda$  v\rm ,\it w \rm . \rm (\it v  $\in$  \it BIT\_VECTOR $\land$ \it w $\in$  \it BIT\_VECTOR  $\mid$  \it v $\cat$ \it w\rm )




We also define a function $\mathit{bv\_zero}$ that, given a positive
integer $n$, return a bit vector of size $n$, with all bits set to 0.
A similar function, called $\mathit{bv\_one}$, with all bits set to 1
is also defined but not presented here.

$
\begin{array}{l}
\mathit{bv\_zero} \in \nat_1 \fun \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_zero} = \lambda n \bullet (n \in \nat_1 \mid 1..n \times \{0\}) 
\end{array}
$

Additionally, the module provides definitions for the classical
logical combinations of bit vectors: $\mathit{bit\_not}$,
$\mathit{bit\_and}$, $\mathit{bit\_or}$ and $\mathit{bit\_xor}$. Only
the first two are presented here. Observe that the domain of the
binary operators is restricted to pairs of bit vectors of the same
length:

$
\begin{array}{l}
\mathit{bv\_not} \in \mathit{BIT\_VECTOR} \fun \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_not} = \lambda v \bullet (v \in \mathit{BIT\_VECTOR} \mid \\
\quad \lambda i \bullet 0 .. \mathit{bv\_size}(v)-1 \mid \mathit{bit\_not}(v(i))) \land \\
\mathit{bv\_and} \in \mathit{BIT\_VECTOR} \times \mathit{BIT\_VECTOR} \fun \mathit{BIT\_VECTOR} \land \\
\mathit{bv\_and} = \lambda v_1, v_2 \bullet (v_1 \in \mathit{BIT\_VECTOR} \land v_2 \in \mathit{BIT\_VECTOR} \land \\
\quad \mathit{bv\_size}(v_1) = \mathit{bv\_size}(v_2) \mid \lambda i \bullet 0 .. \mathit{bv\_size}(v_1)-1 \mid \mathit{bit\_and}(v_1(i), v_2(i)))
\end{array}
$

We provide several lemmas on bit vector operations. These lemmas
express properties on the size of the result of the operations
as well as classical algebraic properties such as associativity
and commutativity. For example:

$
\begin{array}{l}
\forall v \bullet (v \in \mathit{BIT\_VECTOR} \implies \mathit{bv\_size}(\mathit{bv\_not}(v)) = \mathit{bv\_size}(v)) \\

\forall v \bullet (v \in \mathit{BIT\_VECTOR} \implies \mathit{bv\_not}(\mathit{bv\_not}(v)) = v) \\

\forall v_1, v_2 \bullet (\{v_1, v_2\} \subseteq \mathit{BIT\_VECTOR} \land \mathit{bv\_size}(v_1) = \mathit{bv\_size}(v_2) \implies \\
\quad \mathit{bv\_size}(\mathit{bv\_and}(v_1, v_2)) = \mathit{bv\_size}(v_1)) \\

\forall v_1, v_2 \bullet (\{v_1, v_2\} \subseteq \mathit{BIT\_VECTOR} \land \mathit{bv\_size}(v_1) = \mathit{bv\_size}(v_2) \implies \\
\quad \mathit{bv\_size}(\mathit{bv\_and}(v_1, v_2)) = \mathit{bv\_size}(v_2)) \\

\forall v_1, v_2 \bullet (\{v_1, v_2\} \subseteq \mathit{BIT\_VECTOR} \land \mathit{bv\_size}(v_1) = \mathit{bv\_size}(v_2) \implies \\
\quad \mathit{bv\_size}(\mathit{bv\_and}(v_1, v_2)) = \mathit{bv\_and}(v_2, v_1)) \\

\forall v_1, v_2, v_3 \bullet (\{v_1, v_2, v_3\} \subseteq \mathit{BIT\_VECTOR}
\land \mathit{bv\_size}(v_1) = \mathit{bv\_size}(v_2) \land \\
\quad \mathit{bv\_size}(v_1) = \mathit{bv\_size}(v_3) \implies \\ 
\quad \mathit{bv\_and}(\mathit{bv\_and}(v_1, v_2), v_3) = \mathit{bv\_and}(v_1,
\mathit{bv\_and}(v_2, v_3))) \\

\forall v \bullet (v \in \mathit{BIT\_VECTOR} \implies \\
\quad \mathit{bv\_and}(v, \mathit{bv\_zero}(\mathit{bv\_size}(v))) = \mathit{bv\_zero}(\mathit{bv\_size}(v))) \\

\forall v \bullet (v \in \mathit{BIT\_VECTOR} \implies \\
\quad \mathit{bv\_and}(v, \mathit{bv\_one}(\mathit{bv\_size}(v))) = v) \\

\end{array}
$

\subsection{Modelling bytes and bit vector of length 16}[I need review the english]

Bit vectors of length 8 are bytes. They form a common entity in
hardware design. We provide the following definitions:

% $
% \begin{array}{l}
% \mathit{BYTE\_WIDTH} = 8 \land \mathit{BYTE\_INDEX} = 0..(\mathit{BYTE\_WIDTH}-1) \land \\
% \mathit{BYTE} \subseteq \mathit{BIT\_VECTOR} \land \mathit{BYTE} = \{ v \in \mathit{BIT\_VECTOR} \land \mathit{bv\_size}(v) = \mathit{BYTE\_WIDTH}\} \land \\
% \mathit{BYTE\_ZERO} \in \mathit{BYTE} \land \mathit{BYTE} = \mathit{BYTE\_INDEX} \times \{0\}
% \end{array}
% $
% Version 2

\hspace*{0.0in}

\hspace*{0.0in}\it BYTE\_WIDTH \rm = 8 $\land$ \it BYTE\_INDEX \rm = 1 $\upto$ \rm (\it BYTE\_WIDTH\rm )$\land$

\hspace*{0.0in}\it PHYS\_BYTE\_INDEX \rm = \rm 0 $\upto$ \rm (\it BYTE\_WIDTH\rm -\rm 1\rm )\hspace*{0.10in} $\land$ 

\hspace*{0.0in}\it BYTE \rm = \rm \{ \it bt  $\mid$  \it bt $\in$ \it BIT\_VECTOR  $\land$  \it bv\_size\rm (\it bt\rm )\rm =\it BYTE\_WIDTH\rm \}\hspace*{0.10in} $\land$ 

\hspace*{0.0in}\it BYTE\_ZERO  $\in$  \it BYTE  $\land$ 

\hspace*{0.0in}\it BYTE\_ZERO \rm = \it BYTE\_INDEX  $\times$  \rm \{\rm 0\rm \}  

\hspace*{0.0in}

The $\mathit{BYTE\_INDEX}$ is domain of byte modeled. it start at 1 to  obey a definition of sequences from B
method. However, the functions from byte encapsulate the acces and these functions use the
$\mathit{PHYS\_BYTE\_INDEX}$. The $\mathit{BYTE}$ type is a specializated type from $\mathit{BIT\_VECTOR}$, but it
has a size limit. Some other more specific definitions are created to help the developer. For example the constant
$\mathit{BYTE\_ZERO}$ and some below functions. 

\begin{itemize}
  \item \it is\_zero $\in$ BYTE  $\fun$   BIT \rm - It returns 1 if the received byte is zero, otherwise
  returns 0.
  
  \item \it rotateright  $\in$  \it BYTE  $\fun$  \it BYTE \rm - It receives a byte and returns its rotated to
  right. There is a similar function named $\mathit{rotateleft}$.  

\end{itemize}

By the very similar way, the type $\mathit{BV16}$ is created.

\subsection{Bit vector arithmetics}

Bit vectors are used to represent and combine numbers: integer ranges
(signed or unsigned) and floating point numbers.

Our library defines a function $\mathit{bv\_to\_nat}$ that maps bit
vectors to natural numbers:

$
\begin{array}{l}
\mathit{bv\_to\_nat} \in \mathit{BIT\_VECTOR} \fun \nat \land \\
\mathit{bv\_to\_nat} = \lambda v \bullet (v \in \mathit{BIT\_VECTOR} \mid \sum i \bullet (i \in \dom(v) \bullet v(i) \times 2^i))
\end{array}
$

We provide the following lemma:

$
\begin{array}{l}
\forall n \bullet (n \in \nat_1 \implies \mathit{bv\_to\_nat}(\mathit{bv\_zero}(n)) = 0)
\end{array}
$

\subsection{Basics data types}

There are data types commonly used in the microcontrollers. They are placed in
the project Types Librarys and define functions to manipulate data on levels of
basic types from hardware. However, in general is needed to detail or redefines
the types and its functions for each platform. Then, the specific concepts are
defined in the project's own platform.

There are six common basics data types, see details in table below.

\begin{tabular}{|p{3.5cm}|c|c|c|}\hline
 $Type\ Name$ & $Range$ & $Physical\ Size $\\ 
\hline
 UCHAR& 0..255 & 1 byte\\ \hline SCHAR& -128..127 & 1 byte\\ \hline BYTE & -- & 1
 byte\\ \hline USHORTINT & 0..65.535 & 2 byte\\ \hline SSHORTINT &
 -32.768..32.767 & 2 byte\\ \hline BV16 & -- & 2 byte\\ \hline
\end{tabular} 


There is, for example, the function $\mathit{bv\_to\_nat}$ that is specialized
to $\mathit{byte\_uchar}$. How the set $\mathit{BYTE}$ is a subset of the
$\mathit{BIT\_VECTOR}$, then this function can defined as follows:

$
\begin{array}{l}
\mathit{byte\_uchar} = \lambda (v) \bullet ( v \in BYTE | bv\_nat(v) )
\end{array}
$

Usually, the definitions of the functions of the module $\mathit{TYPES}$ are the
re-used from the basic functions of the hardware library. This provides greater
confidence and facilitates the process of proof, because the prover can use the
defined previous lemma.

A more specific model of $\mathit{byte\_uchar}$ functions is:

$
\begin{array}{l}
\mathit{byte\_uchar} \in \mathit{BYTE}  \fun  \mathit{UCHAR}  \land \\
   \mathit{byte\_uchar} =  \lambda ( v0 )  \bullet  
   ( v0 \in \mathit{BYTE} |  2^{7}* bv\_get( v0 ,7 ) + 2^{6} * bv\_get( v0 ,6 ) + 2^{5}* bv\_get( v0 , 5   )\\ 
   + 2^{4}* bv\_get( v0 , 4 ) + 2^{3}*bv\_get( v0 , 3 ) + 2^{2}* bv\_get( v0 , 2 ) + 2 * bv\_get( v0 , 1 ) +  bv\_get( v0 ,0) )
   
\end{array}
$

The inverse function is easily defined as $\mathit{uchar\_byte}$.

$
\begin{array}{l}
\mathit{uchar\_byte} \in \mathit{UCHAR}  \fun  \mathit{BYTE}  \land \\
   \mathit{uchar\_byte} = \  ^{-1}(\mathit{byte\_uchar}
   )
\end{array}
$ 

We also created the following lemmas:
 
$
\begin{array}{l}
 \forall (val) \bullet (val \in \mathit{UCHAR} |
 \mathit{byte\_uchar}(\mathit{uchar\_byte}(val)) = val) \land\\
 \forall (by) \bullet (by \in \mathit{BYTE} |
 \mathit{uchar\_byte}(\mathit{byte\_uchar}(by)) = by)
\end{array}
$ 

Similarly, several other functions and lemmas were created for all other
data types.
		


\section{Description of the B model from Z80}
\label{sec:z80}

The \textit{Z80} is an important microcontroller developed in 1976 by \textit{Zilog}. In this time, It got a great
acceptance because suported all set instruction of \textit{8080}, one of the predecessors of the \textit{Pentium}
from \textit{Intel Corporation}. Then, the Z80 has the set instructions similar to the x86 architecture, it helps 
to build the model of x86 and it provides good features.


The main module includes a instance of memory module and accesses the definitions from: basic data types modules,
\textit{ALU} and \textit{Power2} \footnote{The \textit{Power2} module has the basics definitions to help the
theorems prover about calculus of power.}.

\begin{sloppypar}

\bf MACHINE

\hspace*{0.15in}\it Z80

\bf INCLUDES

\hspace*{0.10in}\it MEMORY

\bf SEES

\hspace*{0.10in}\it ALU, \it BIT\_DEFINITION, \it BIT\_VECTOR\_DEFINITION,

\hspace*{0.10in}\it BYTE\_DEFINITION, \it BV16\_DEFINITION, 

\hspace*{0.10in}\it UCHAR\_DEFINITION, \it SCHAR\_DEFINITION,

\hspace*{0.10in}\it SSHORT\_DEFINITION ,\it USHORT\_DEFINITION, \it POWER2
\end{sloppypar}


% Chacteristics of microcontroller
The \textit{Z80} supports 158 differents instructions including all the 78 from
\textit{8080}.The instructions are classified into these categories: load and exchange;
block transfer and search; arithmetic and logical; rotate and shift; bit
manipulation (set, reset, test); jump, call and return; input/output; and basic
cpu control. Each instruction and external action at model is represented by B
operations. By default, all parameters from operations are or pre-defined elements
in the model or integers values in the decimal representation.

The internal registers contain 208 bits of reading/writing memory. It includes two sets of six general purpose
registers which may be used individually as  8-bits registers or as 16-bits register pairs.  The work registers are
represented by variable $\mathit{rgs8}$. The domain of $\mathit{rgs8}$ ($\mathit{id\_regs8}$) is a set formed by
identifiers of registers of 8 bits. These registers can be accessed in pairs, forming 16-bits, resulting in other
set of identifiers of 16-bits registers, named $\mathit{id\_reg16}$. The main work register of Z80 is the
accumulator ($\mathit{rgs8(a0)}$) used for arithmetic, logic, input/output and loading/storing operations.


\begin{sloppypar}
\bf SETS

\hspace*{0.10in}\it id\_reg\_8 \rm = \rm \{ \it a0 \rm , \it f0 \rm , \it f\_0 \rm , \it a\_0 \rm ,

\hspace*{1.0 in}\it b0 \rm , \it c0 \rm , \it b\_0 \rm , \it c\_0 \rm ,

\hspace*{1.00in}\it d0 \rm , \it e0 \rm , \it d\_0 \rm , \it e\_0 \rm ,

\hspace*{1.0in}\it h0 \rm , \it l0 \rm , \it h\_0 \rm , \it l\_0 \} ;

\hspace*{0.10in}\it id\_reg\_16 \rm = \rm \{ \it BC \rm , \it DE \rm , \it HL \rm , \it SP \rm , \it AF \rm \}
\end{sloppypar}

\subsection{Modelling registers and input and output ports} [I need review the english]

The Z80 CPU includes alternative set of accumulator, flag and general registers. The CPU contains a stack
pointer ($\mathit{sp}$), program counter ($\mathit{pc}$), two index registers ($\mathit{ix}$ and $\mathit{iy}$), an
interrupt register ($\mathit{i\_}$), a refresh register ($\mathit{r\_}$), two bits ($\mathit{iff1}$,
$\mathit{iff2}$) used to control the interruptions, a pair of bits to define the interruption mode ($\mathit{im}$)
and the input and output ports ($\mathit{i\_o\_ports}$). Below, its definitions are represented by
\textit{INVARIANT}.
  
\begin{sloppypar}
\bf INVARIANT


\hspace*{0.10in}\it rgs8  $\in$  \it id\_reg\_8  $\fun$  \it BYTE  $\land$ 

\hspace*{0.10in}\it pc  $\in$  \it INSTRUCTION  $\land$  \it sp  $\in$  \it BV16  $\land$  \it ix  $\in$  \it BV16  $\land$  \it iy  $\in$  \it BV16  $\land$ 

\hspace*{0.10in}\it i\_  $\in$  \it BYTE  $\land$  \it r\_\hspace*{0.10in} $\in$  \it BYTE  $\land$  

\hspace*{0.10in}\it iff1  $\in$  \it BIT  $\land$ \hspace*{0.10in}\it iff2  $\in$  \it BIT  $\land$ 

\hspace*{0.10in}\it im \rm : \rm (\it BIT $\times$ \it BIT\rm )  $\land$ 

\hspace*{0.10in}\it i\_o\_ports  $\in$  \it BYTE  $\fun$  \it BYTE
\end{sloppypar}

\subsection{Flag register} [I need review the english]
Another important element is the ``z'' register ($\mathit{rgs8(z0)}$),  that is used as a flag register. This
register uses only six bits to represent the result status of each instruction. 	
According to the official manual the bits 3 and 5 are not used and the others bits have the follow meaning:
\begin{description}
  \item[$\mathit{bv\_get(rgs8(z0),0)}$] - The Carry bit
  \item[$\mathit{bv\_get(rgs8(z0),1)}$] - The Add/Subtract bit
  \item[$\mathit{bv\_get(rgs8(z0),2)}$] - The Parity or Overflow bit
  \item[$\mathit{bv\_get(rgs8(z0),4)}$] - The Half Carry bit
  \item[$\mathit{bv\_get(rgs8(z0),6)}$] - The Zero bit
  \item[$\mathit{bv\_get(rgs8(z0),7)}$] - The Sign bit 
\end{description}

\begin{property}[Assuring the absence of Overflow]
 To assure that don´t happen overflow the developer can add this expression ($\mathit{bv\_get(rgs8(z0),0)} \neq 1
 \land \mathit{bv\_get(rgs8(z0),2) \neq 1}$)in the invariant. By default, the overflow can happen, but many times it
 can be dangerous. Then, the developer may prohibit its use. This restriction can also become the more dificult to
 specify.
\end{property}

\subsection{Manipulation data functions from Z80} [I need to review the english] There are some specific functions
from Z80 to manipulate the data. The $\mathit{bv\_ireg\_plus\_d}$ is  used to indexed address. It received the
value of register ($\mathit{ix}$ or $\mathit{iy}$) and displacement to return the sum, the result is the memory address dislocated, see
its the definition.

\hspace*{0.0in}\it bv\_ireg\_plus\_d \rm : \rm(\it BV16  $\times$  \it SCHAR  $\fun$  \it BV16\rm )  $\land$ 

\hspace*{0.0in}\it bv\_ireg\_plus\_d \rm =  $\lambda$  \rm ( \it ix\_iy \rm , \it disloc \rm ) \rm . \rm ( \it ix\_iy  $\in$  \it BV16  $\land$  \it disloc  $\in$  \it SCHAR   

\hspace*{0.20in}$\mid$ \it ushort\_bv16 \rm ( \rm (\it bv16\_ushort \rm ( \it ix\_iy \rm ) \rm + \it disloc \rm ) 
$\mod$ \rm 6\rm 5\rm 5\rm 3\rm 6 \rm ) \rm )

Another derived function is  $\mathit{bv\_9ireg\_plus\_d0}$ , this returns the value in the memory  address
returned by $\mathit{bv\_ireg\_plus\_d}$ function ands its definition is similar.

There is a specific function to refresh the flag register, it is named $\mathit{update\_reg\_flag}$. It is typed of
follow mode: \it update\_flag\_reg \rm $\in$ \rm (\it BIT  $\times$  \it BIT  $\times$  \it BIT  $\times$  \it
BIT $\times$  \it BIT  $\times$  \it BIT\rm) $\fun$  \rm (\rm \{\it f0\rm \}  $\times$  \it BYTE\rm ). 

\it update\_flag\_reg \rm =  $\lambda$  \rm (\it s7 \rm, \it z6 \rm,\it h4 \rm,\it pv2 \rm ,\it n1
\rm ,\it c0 \rm)$\bullet$

\rm ( \it s7 $\in$ \it BIT $\land$ \it z6 $\in$ \it BIT $\land$ \it h4 $\in$ \it
BIT $\land$ \it pv2 $\in$ \it BIT $\land$ \it n1 $\in$ \it BIT $\land$ \it c0 $\in$ \it BIT
  
\hspace*{0.20in}\rm $\mid$( \it f0  $\mapsto$  \rm \rm [\it c0\rm , \it n1\rm , \it pv2\rm , \rm 1\rm , \it
h4\rm , \rm 1\rm , \it z6\rm , \it s7\rm \rm ]\rm ) \rm )


\subsection{Program, stack and data memory}[I need review the english]

The Z80 uses a unique memory for storing program instructions, data stack and data work. The memory has 16-bits
addressing and each address represent a byte. Thus, the data from the memory module is very simple, as shown below,
but an additional care must be taken to preserve the consistency of memory.

\begin{sloppypar}
\bf INVARIANT \\
\hspace*{0.10in}\it mem  $\in$  \it BV16  $\fun$  \it BYTE 

\end{sloppypar}
  
In general, the instructions can access all memory address, but it is very dangerous. For add more security, is
importante that the program instructions has the access limited by region. Thus, the designer can specify address
regions to restrict the access from instructions. The address regions can be especified how shown below.

$
\begin{array}{l}
\mathit{PROGRAM\_R\_ADR} = 0..16384 \land \mathit{DATA\_R\_ADR} = 16385..49151 \land \\
\mathit{STACK\_R\_ADR} = 49152..65535
\end{array}
$

\begin{property}[Assuring the absence of overlapping of address regions]
 To assure that address regions are well defined, then the designer must to verify the below expression.
\end{property}

\begin{sloppypar}
\hspace*{0.10in}\it PROGRAM\_R\_ADR $\cap$ DATA\_R\_ADR $\cap$  STACK\_R\_ADR $=$ \{\}
\end{sloppypar}
 


\begin{property}[Preserving the consistency of the memory]
In general, the access to some address regions is dangerous. Then, in each instruction has a specific
pre-condition that verify if the new address memory, that will be updated, is member of its region. For example,
the $\mathit{PUSH}$ program instruction allow write only in the region of stack ($\mathit{STACK\_R\_ADR}$). 
%Thus,if the user try to write in incorrect region then the called of operation cannot be proved.
\end{property}


\subsection{Arithmetic logic unit}
 
There are many functions defined in the module \textit{ALU}. In general, these functions take basic definitions to build
new specific functions. The function $\mathit{half8UCHAR}$ is used to get the half part of $\mathit{UCHAR}$ value.
It is importante to know the half carry and it is used in the $\mathit{add8UCHAR}$. 

\hspace*{0.0in}

\hspace*{0.0in}\it half8UCHAR  $\in$  \it UCHAR  $\fun$  \it UCHAR  $\land$ 

\hspace*{0.0in}\it half8UCHAR \rm =  $\lambda$  \rm (\it ww\rm )\rm .\rm (\it ww  $\in$  \it UCHAR  $\mid$  \it ww  $\mod$  \it $2^{4}$\rm )

\hspace*{0.0in}

 
The function $\mathit{add8UCHAR}$ receive a bit carry and two $\mathit{UCHAR}$ values and return respectively the 
sum, the sign bit, the carry bit, the half carry bit and the zero bit. It is typed how follow: \it add8UCHAR \rm :
\rm (\it BIT $\times$ \it UCHAR $\times$ \it UCHAR\rm ) $\fun$ \rm (\it UCHAR $\times$  \it BIT  $\times$  \it BIT  $\times$  \it BIT  $\times$  \it BIT\rm ) and its definitions is:

\hspace*{0.20in}

\hspace*{0.0in}\it add8UCHAR\rm = $\lambda$ \rm(\it carry\rm,\it w1\rm \it w2\rm)\rm.\rm

\hspace*{0.0in}(\it carry $\in$  \it BIT  $\land$  \it w1  $\in$  \it UCHAR  $\land$  \it w2  $\in$  \it UCHAR
$\mid$

\hspace*{0.40in}\rm(\rm(\rm(\it carry \rm + \it w1 \rm + \it w2 \rm )  $\mod$  \it $2^{8}$ \rm ),

\hspace*{0.40in}\it bool\_bit\rm ( \it carry \rm + \it uchar\_schar\rm (\it w1\rm ) \rm + \it uchar\_schar \rm (\it
w2\rm ) $<$ \rm 0\rm ),

\hspace*{0.40in}\it bool\_bit\rm ( \it carry \rm + \it w1 \rm + \it w2 $>$ \it UCHAR\_MAX\rm )\rm ,

\hspace*{0.40in}\it bool\_bit\rm ( \it carry \rm + \it half8UCHAR\rm (\it w1\rm ) \rm + \it half8UCHAR\rm ( \it
w2\rm )  $\geq$  \it $2^{4}$\rm )\rm,

\hspace*{0.40in}\it bool\_bit\rm ( \rm ( \rm (\it carry \rm + \it w1 \rm + \it w2 \rm )  $\mod$  \it $2^{8}$ \rm
)\rm = \rm 0\rm )\rm )\hspace*{0.10in}\rm )

\hspace*{0.20in}

A similar function to subtract operation is $\mathit{substract8UCHAR}$. There are the same functions for the
$\mathit{SCHAR}$ type, they are respectively $\mathit{add8SCHAR}$ and $\mathit{substract8SCHAR}$, all these
functions are of 8 bits ($\mathit{BYTE}$) and defined similarly. In the same way, the arithmetic functions for 16
bits ($\mathit{BV16}$) are defined.

Other more simply functions also are typed and explained below:

\begin{itemize}
  \item \it inc  $\in$ \it BYTE $\fun$  \it BYTE \rm - It receives a byte and returns its decrement. There is a
  similar function named $\mathit{dec}$.

  \item \it instruction\_next  $\in$  USHORT  $\fun$  USHORT \rm - It receives the pc actual
  value and return its increment.

  \item \it is\_negative  $\in$  \it BYTE  $\fun$  \it BIT \rm - It returns 1 if the received
  byte is zero, otherwise returns 0.

  \item \it update\_refresh\_reg \rm - It receives a byte and returns its increment until the seventh bit.

\end{itemize}

Every logic functions are defined in the \textit{BYTE} and \textit{BV16} module are included in the \textit{ALU}
module. Then, it was not necessary rewrite these functions.

\subsection{Modelling the instructions}[I need review the english]
 
The main module (\textit{Z80}) has two types of operations, a type represent the external actions and the other
represent the instructions of microcontrollers. The external actions are shown in the section
~\ref{sec:externalactions} and the other type represents the instructions of microcontroller. A simple example from
instruction is a $\mathit{LD\_(nn)\_A}$ shown below. Many times to model a instruction is necessary to use the pre-defined functions,
this facilitates the construction of model. This instruction use the $\mathit{updateAddressMem}$ function from
\textit{Memory} module and it receives a address memory and its new memory value. After, it increments the programcounter ($\mathit{pc}$) and update the refresh register ($\mathit{r\_}$).
\hspace*{0.00in}\bf LD\_9nn0\_A \rm ( \it nn \rm ) \rm =

\hspace*{0.20in}\bf PRE \it nn $\in$ \it USHORT\hspace*{0.15in} $\land$ \hspace*{0.10in}\it nn\hspace*{0.10in} $\in$  \it DATA\_R\_ADR

\hspace*{0.20in}\bf THEN

\hspace*{0.20in}\bf updateAddressMem \rm ( \it ushort\_bv16 \rm ( \it nn \rm ) \rm , \it rgs8 \rm ( \it a0 \rm )
\rm )  $\para$

\hspace*{0.20in}\it pc \rm := \it instruction\_next \rm ( \it pc \rm )  $\para$  \it r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.00in}\bf END\rm ;

The other instructions have a similar structure.


\subsection{Modelling the external action}
\label{sec:externalactions}

The external actions change the state of microcontroller and they aren´t instructions, for example, the refreshing
of I/O port and the interruptions request. The extern action are also model by operations and they are prefixed
with ``$ext\_$'' and after the name of action. There are just four extern actions: $ext\_update\_io\_ports$,
$ext\_NMI$ and $ext\_INT$, $ext\_Reset$. The $ext\_update\_io\_ports$ just change the state of I/O port, see.
\hspace*{0.20in}\bf ext\_update\_io\_ports\rm (\it address\rm ,\it value\rm )\rm =

\hspace*{0.20in}\bf PRE \it address  $\in$  \it UCHAR  $\land$ \hspace*{0.10in}\it value  $\in$  \it SCHAR \bf THEN

\hspace*{0.40in}\it io\_ports \rm ( \it uchar\_byte \rm ( \it address \rm ) \rm ) \rm := \it schar\_byte \rm ( \it
value \rm )

\hspace*{0.20in}\bf END\rm 

The others are related to interrupts. The interrupts allows that the devices suspend a routine from CPU and start
another service routine. This service routine can exchange data or signals between CPU and external devices. When a
routine is finished, then the CPU come back to the last routine that was interrupted.
For the interrupts, the following things are important:  the interrupt flip-flops ($\mathit{iff1}$ and
$\mathit{iff2}$), the types of interrupts (maskable and non-maskable), the interrupt mode (set with the $\mathit{IM
0}$, $\mathit{IM 1}$, $\mathit{IM 2}$ instructions) and the $\mathit{i\_}$ register.

The $\mathit{iff1}$ and $\mathit{iff2}$ control the maskable interrupts ($\mathit{INT}$). When the $\mathit{iff1}$
is set, the interrupt is enable, otherwise it is disable. The $\mathit{iff2}$ is used only as a tempory storage
place for $\mathit{iff1}$. The $\mathit{iff1}$ is set or reset by instructions $\mathit{EI}$ and $\mathit{DI}$.


The interruptions and the \textit{reset} action change the state of
microcontroller. Theses actions are modeled by B operations and the its main
effects are shown below\footnote{Some definitions: $\mathit{sp\_minus\_two}$ =
$\mathit{dec\_BV16(dec\_BV16(sp))}$, $\mathit{sp\_minus\_one}$=
$\mathit{dec\_BV16(sp)}$, $\mathit{pc\_high}$ is the most significant 8 bits and
$\mathit{pc\_low}$ is the least significant. }.


 \textbf{NMI} - Non-maskable interrupts - The non-maskable cannot be disable
 by the programmer. Then, when a device makes a request, the $sp$ is pushed, the $pc$ receive
 $66H$ (102 in decimal), the $\mathit{iff1}$ is reset , $\mathit{iff2}$ stores
 $\mathit{iff1}$ and refresh register is updated.
  
\begin{sloppypar}
\bf updateStack\rm (\rm \{ \rm (\it sp\_minus\_two  $\mapsto$  \it pc\_low\rm )\rm ,\rm (\it sp\_minus\_one  $\mapsto$ \it pc\_high \rm ) \rm \}\rm )$\para$

\it sp \rm := \it sp\_minus\_two  $\para$ \it pc \rm := \rm 1\rm 0\rm 2 $\para$ \it iff1\rm :=\rm 0  $\para$  \it iff2\rm := \it iff1 $\para$

\it r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )\\
\end{sloppypar}

  \textbf{INT} - Maskable Interrupt -  This is usualy reserved to important functions that can be enabled and
  disabled by the programmer. When a maskable interrupt action happens, both $\mathit{iff1}$ and $\mathit{iff2}$ are
  cleared, disabling the interrupts, the $sp$ is pushed, the refresh register is updated  and the other effects
  depend on the interrupt mode.
 

 \begin{itemize}
   
  \item The mode 0 is compatible with 8080 and  \it im \rm = \rm ( \rm 0 $\mapsto$  \rm 0 \rm ). When a 
  non-maskable interruption happen , the CPU fetches an instruction of one byte from an external device, usually an
  RST instruction, and the CPU executes it. The instruction code is received from a external device by data bus and
  it is represented by integer parameter called $\mathit{byte\_bus}$ .

 
  \item The mode 1 is the easiest and \it im \rm = \rm ( \rm 0  $\mapsto$  \rm 1 \rm ). Simply, when a non-maskable
  interruption happens, the program counter receive $38H$ (56 in decimal).
  
  \item The mode 2 is the most powerfull and  \it im \rm = \rm ( \rm 1  $\mapsto$ \rm 1 \rm ). When a non-maskable
  interruption happens, an indirect call can be made to any address memory. The program counter receives in the
  part most significant the $\mathit{i\_}$ register and, in the  part least siginificant, the $\mathit{byte\_bus}$
  with the last bit reset.
 \end{itemize}

The essential part of maskable interrupt is shown below\footnote{ The
 $\mathit{byte\_bus}$ is parameter from  $\mathit{INT}$ operation }. 
 


\begin{sloppypar}

\hspace*{0.00in}\bf IF \it im \rm = \rm ( \rm 0  $\mapsto$  \rm 0 \rm ) \bf THEN  

\hspace*{0.10in}\bf IF\hspace*{0.10in}\it byte\_bus \rm $\in$  \it opcodes\_RST\_instruction

\hspace*{0.10in}\bf THEN\hspace*{1.05in}

\hspace*{0.40in}\it pc \rm := \it byte\_bus \rm - \rm 1\rm 9\rm
9\hspace*{0.10in} $\para$

\hspace*{0.40in}\bf updateStack\rm ( \rm \{ \it stack\rm ( \it
sp\_minus\_one\rm )  $\mapsto$  \it pc\_low\rm ,

\hspace*{0.40in}\it stack\rm (\it sp\_minus\_two\rm )  $\mapsto$  \it pc\_high
\rm \} \rm )  $\para$

\hspace*{0.40in}\it sp \rm := \it sp\_minus\_two  $\para$ \hspace*{0.10in}\it
r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.10in}\bf ELSIF \it byte\_bus \rm = \it opcode\_\ldots\_instruction

\hspace*{0.40in}\bf \ldots 

\hspace*{0.10in}\bf END

\hspace*{0.00in}\bf ELSIF\hspace*{0.10in}\it im \rm =\hspace*{0.10in}\rm ( \rm
0  $\mapsto$  \rm 1 \rm ) \bf THEN

\hspace*{0.10in}\it pc \rm :=\hspace*{0.10in}\rm 5\rm 6  \hspace*{0.80in}
$\para$

\hspace*{0.10in}\bf updateStack\rm ( \rm \{ \it stack\rm (\it
sp\_minus\_one\rm )  $\mapsto$  \it pc\_low\rm ,

\hspace*{0.10in}\it stack\rm (\it sp\_minus\_two\rm )  $\mapsto$  \it pc\_high
\rm \} \rm )  $\para$

\hspace*{0.10in}\it sp \rm := \it sp\_minus\_two  $\para$ \hspace*{0.10in}\it
r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )\hspace*{0.85in}

\hspace*{0.00in}\bf ELSIF\hspace*{0.10in}\it im \rm = \rm ( \rm 1  $\mapsto$ 
\rm 1 \rm ) \bf THEN  \hspace*{0.70in}

\hspace*{0.10in}\it pc \rm := \it bv16\_ushort\rm (\it byte\_bv16\rm ( \it i\_
\rm ,\it bv\_clear\rm (\it rotateleft\rm (\it uchar\_byte\rm (\it byte\_bus\rm )\rm )\rm ,\rm 0\rm )\rm )\rm )$\para$

\hspace*{0.10in}\bf updateStack\rm ( \rm \{ \it stack\rm ( \it
sp\_minus\_one\rm )  $\mapsto$  \it pc\_low\rm ,

\hspace*{0.10in}\it stack\rm (\it sp\_minus\_two\rm )  $\mapsto$  \it pc\_high
\rm \} \rm )  $\para$

\hspace*{0.10in}\it sp \rm := \it sp\_minus\_two  $\para$ \hspace*{0.10in}\it
r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.00in}\bf END\hspace*{0.10in}\\
\end{sloppypar}


\textbf{RESET}  - This just reset the registers related to the interruptions.

\begin{sloppypar}
\it iff1 \rm :=\rm 0 $\para$ \it iff2\rm :=\rm 0 $\para$  \it  im\rm := \rm (\rm 0 $\mapsto$ \rm 0\rm )  $\para$ 
\it pc\rm :=\rm 0 $\para$ \it i\_ \rm := [0,0,0,0,0,0,0,0] $\para$

\it rgs8 \rm := \it rgs8  $\lover$  \rm \{ \rm (\it a0  $\mapsto$ \rm [0,0,0,0,0,0,0,0] , \rm (\it
f0 $\mapsto$ \rm [0,0,0,0,0,0,0,0] \rm \} $\para$

\it r\_  \rm := [0,0,0,0,0,0,0,0] $\para$ \it sp \rm := [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
\end{sloppypar}


% 
%     Para controlar o registrador I, existem duas intrucoes:
% 
%     - LD A,I (carrega o acumulador com o valor contido em I);
%     - LD I,A (carrega I com o valor contido no acumulador).
% 
%     A instrucao LD A,I possui uma funcao extra, ja' discutida
% em outra aula: ela carrega na `flag' de paridade/sobrecarga o
% valor do IFF ("Interruption Flip-Flop"). Se IFF for 0, entao a
% interrupcao mascaravel esta' desativada. Se IFF for 1, entao
% ela esta' ativada.
% %%%% FIM - http://download.unesp.br/msx/asm/course_4.txt
% 
% 
% 
% 
% Instruções relacionadas com o sistema de interrupção:
%  HALT,EI,DI,M0,M1,M2 
%  
%  LD_A_R, LD_A_I\ldots,  
%  CALL, RET,  RETI,RETN
 

\section{Input and output ports}

The Z80 has an extensive set of input and output (I/O) instruction and 256 ports for
devices. This model can transfer data blocks and between the I/O devices and any
of the internal registers or memory address.

The $\mathit{IN\_r(C)}$ \footnote{The tools B don't allow use parenteses in identifiers, then the characteres
\{``('',``)''\} are replaced respectively by \{``9'',``0''\} in the real specification.} instruction is represented
by the follow B operation. It is from I/O group, then it reveives a identifier of register$\mathit{r}$ and, in this place, it stores the value of $\mathit{C}$ port address. Besides, it increments theprogram counter and updates the flag registers.
\hspace*{0.0in}\bf IN\_r\_9C0 \rm ( \it rr \rm ) \rm =

\hspace*{0.0in}\bf PRE \it rr  $\in$  \it id\_reg\_8  $\land$  \it rr  $\not =$  \it f0\hspace*{0.15in}\bf THEN

\hspace*{0.20in}\bf ANY

\hspace*{0.40in}\it negative \rm , \it zero \rm , \it half\_carry \rm , \it pv \rm , \it add\_sub \rm , \it carry

\hspace*{0.20in}\bf WHERE 

\hspace*{0.40in}\it negative $\in$ \it BIT $\land$ \it zero $\in$ \it BIT $\land$ \it half\_carry $\in$ \it BIT 
$\land$ \it pv $\in$ \it BIT $\land$

 \hspace*{0.40in}\it add\_sub $\in$ \it BIT $\land$ \it carry $\in$ \it BIT  $\land$

\hspace*{0.40in}\it negative \rm = \it is\_negative \rm ( \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm )  $\land$ 

\hspace*{0.40in}\it zero \rm = \it is\_zero \rm ( \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm )  $\land$ 

\hspace*{0.40in}\it half\_carry \rm = \rm 0  $\land$ 

\hspace*{0.40in}\it pv \rm = \it parity\_even \rm ( \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm ) $\land$

\hspace*{0.40in}\it add\_sub \rm =\hspace*{0.10in}\rm 0  $\land$ 

\hspace*{0.40in}\it carry \rm = \it z\_c

\hspace*{0.20in}\bf THEN

\hspace*{0.40in}\it rgs8 \rm := \it rgs8  $\lover$  \rm \{ \rm ( \it rr  $\mapsto$  \it io\_ports \rm ( \it rgs8 \rm ( \it c0 \rm ) \rm ) \rm ) \rm ,

\hspace*{0.40in}\it update\_flag\_reg\rm (\it negative\rm,\it zero\rm,\it half\_carry\rm,\it pv\rm,\it add\_sub\rm,\it carry)\rm\}$\para$

\hspace*{0.40in}\it pc \rm := \it instruction\_next \rm ( \it pc \rm )  $\para$  \it r\_ \rm := \it update\_refresh\_reg\rm (\it r\_\rm )

\hspace*{0.0in}\bf END \rm



% $
% \begin{array}{l} 
% \mathit{IN\_r\_9C0} ( rr ) = \\
% \quad   \PRE rr \in id\_reg\_8    \THEN\\
% \quad\quad \ANY data\_in, negative , zero , half\_carry , pv , add\_sub , carry\\ 
% \quad\quad \WHERE data\_in \in \mathit{BYTE} \land negative \in \mathit{BIT}\land\\
% \quad\quad\quad carry \in \mathit{BIT} \land half\_carry \in \mathit{BIT} \land zero \in \mathit{BIT} \land \\
% \quad\quad\quad negative = is\_negative (data\_in) \land zero = is\_zero(data\_in ) \land\\
% \quad\quad\quad half\_carry = 0 \land pv =parity\_even\_BYTE ( data\_in )    \land\\
% \quad\quad\quad add\_sub =  0 \land carry = z\_c \\
% \quad\quad  \THEN \\
% \quad\quad\quad i\_o\_ports ( rgs8 ( c0 ) ) := data\_in ||\\
% \quad\quad\quad rgs8 := rgs8 <+ \{ ( rr |-> data\_in ) ,\\
% \quad\quad\quad get\_new\_flag\_register\_SZ\_H\_PvNC ( rgs8 , negative , zero, half\_carry , pv , add\_sub , carry ) \} ||\\
% \quad\quad\quad pc := instruction\_next( pc )\\
% \quad\quad \END\\
% \quad \END\\
% \end{array}
% $

\section{Proofs }

[O que as provas garantem?]
 As obrigações de provas garante a verficação dos tipos de dados, das propriedades
estabelecidas no modelo e se as expressões são bem formadas \footnote{An expression is called "well-defined" (or
unambiguous) if its definition assigns it a unique interpretation or value.}. As propriedades oferecem garantias
adicionais ao projetista do software, pois é capaz de estabelecer uma série de critérios de segurança. Além disso,
como estas propriedades estão em nível de especificação, então é possível ajusta-las a necessidade de um determinado
sofwtare sem acarretar em mudanças no hardware, o que implica apenas em aumentar ou diminuir o número de
provas.
% O desenvolvedor poderia por exemplo aumentar a região de memória necessária para armazenar dados de trabalho.
A seguir tem-se os número de provas não obvias e WD do projeto Z80 separado em grupos. Esta tabela mostra a
distribuição do número de provas de cada grupo. Um dos grupos que contém mais provas é o de manipulação de bits.
Apesar da grande quantidade de provas, este grupo foi rapidamente provado, pois ele utiliza vários lemmas providos
pela Hardware Library, o que acontece também com o grupo Logic and Arithmetic e a Types Library.
 
[Groups]
\begin{center}
\begin{tabular}{llll}
\textbf{Group} &  \textbf{Proofs No Obvious} & \textbf{Proofs WD} & × \\ 
Input and Output & 54 & 296  \\ 
Logic and Arithmetic & 134 & 413  \\ 
Manipulation of Bits & 160 & 742  \\ 
Extern actions & 51 & 84  \\
General & 140 & 615  \\
Initialization, Properties and Assertions & 68 & 169  \\
 \textbf{Total} &  607 &  2319  &  %\textbf{Total} 2926 \\
\end{tabular}
\end{center}

% [Conclusao]
This project has many proof obligations and its process of verification is the step of the most time consumed. The
verification step of all the model spent about a month. This was hard, because was necessary to build, correct and
prove several expressions from basic projects, Hardware and Types Library. However, when the basic projects are
ready, the modelling and verification of new plataform \footnote{Actualy, the microprocessors M8051 and PIC16F432
are under construction} become more fast and easy. Thus, these basic projects were also built to re-use to other
platforms. When the basic projects are ready, then about 89\% proof non obvious and 55\% of Proofs WD was conclused
automaticly. 

The others were concluded through the use of proof commands\footnote{The proof commands are step that just indicate
a walk to prover make the proof, thus theses commands cannot introduce false hypotheses.} associated to
match pattern from proof obligations. The match pattern accelerates too much the prove process, because there are many
similar assembler instructions and the AtelierB can re-use the match pattern and its proof commands associated.
Therefore, few proof commands can be useful to many obrigações de prova. A good example is a set of 17 proof
commands that fastly helps to verify 99\% (2295) of proofs WD. To further reduce cost of proof process, a new feature
supported by AtelierB was used, the parallelization. To do this were used three computers each one with two cores,
the that theoretically increased by six times the capacity of processing.

A special care was taken to represent the model in way simple and accurate. This care also reduced the number of
proofs. Because, the simple act of optimizing the use of override operator ($\lover$) fell too the number of proof
obligations.

Finally, the techniques mentioned help the verification of all the 2926 proof obligations. The
modularization of projects difined basic lemmas that help to build a simple and full framework. The
automatic re-use of commands's proof directed to a resolution more eficiently of proofs. The
paralelization and the care in modeling accelerate the process's proof, because increase the
processing capacity and reduced the number of proof obligatiions.
 
 \section{Related Works}
 
 [ I need review the english]

There are in the literature of computer science some technics\cite{BHDL_2003,GEMPLUS_99} to model hardware and the
virtual machines using the B method. Then, the B method has been used successfully to model the operational
semantic, however the cost of modeling was still expensive and this paper describes some techniques to lower the
cost modeling. Although, the modeling of the Z80 is not yet represented some small aspects. 

%The objective of researchers

In general, the researchers are concetrated at model the Java Virtual Machine (JVM), but it is not easy to
specify it, because it very big and complex, and become more difficult to write good lemmas, to normalize
the functions and to verify its properties. Then, this work specify a model more simple to get fastly
better results , in the same time, stay near to model of actual processors.

% Re-uso  - modularization

The most of related works are specific to one plataform\cite{GEMPLUS_99,ammm} and its basic definitions
cannot be re-used at in other platforms. The used strategy created a good logic separation about the
concepts of modelling. Thus, the basic projects, the Hardware and Types Library, have functions with a low
coupling and high cohesion, that promove the re-use. Soon, these re-use better too the code generation,
the confiability and prove process.

% advantages

Others advantages of this work are the aplication of news and advanceds funcionalities of B method. These
advantages are the paralelization of prove proccess and the instensive use of math patterns associated
with proof commands. Normaly, the related works don`t enjoy this funcionalities, because these are news
and required advanced knowleadge about tools for B method.

% main problems

This work had as the main motivation the  verififcation in assembler level and consequently the
verification of harware model. Thus, the some aspects about hardware aren't modeled. For example, the time
of execution of instruction, the pipeline and others questions not directly related with the semantic of
software. However, there are several other specialized techinques to verify this questions. The care to
simplify the model also helps in the prove process.
    
 \section{Conclusitions}
[I need review the english]
% - Intro
% - Importancia do trabalho  -
% - Qual a grande vantagem - A automação
% - Trabalhos futuros  [O que almejamos citar o AAA] -> In the future, this works like  -> %- Refinar o  modelo  para gerar através dos  código e apartir deste código criar um  interpretador/simulador
 
%Intro
This work shown a approach to model formally a microprocessor using the B method. The applied approach
provide interesting results and had a great automatization in the prove proccess. Besides, this research
intend extend the works to verification in the assembly level.

This research is much interesting to design microcontroller. The formal model allow founnd some erros at
the oficial manual\cite{Zilog} and ambiguities. The Z80's B model can replace the documentation used by
assembler programmers, because the formal model represents the instructions effects and the B-method has a
easy language, that remembers the pascal language. Besides, the formal model restricts the defintions to
correct typing, use expressions well-defined and allow verify properties on the model.

The Atelierb supports code generation to programming languages and latex documents, this feature also
helps to build an interpreter or simulator through the formal model. In the future, this functionality can
be changed to genarate code of hardware description. Actually, the news and advanced features automate the
process even more.
%[Automação]
Actually, the mains attractions of B method to model microcontroolers are: the support the paralelization
of prove proccess and matching patterns associated to proof commands.
% Por outro lado, uma das qualidades de destaque do método B é relacionada com a
% boa capacidade de verificação automática das ferramentas, pois, na versão estável
% das modelagens, do total das $503$ provas dos módulos principais do \textit{PIC},
% \textit{8051} e \textit{Z80} apenas $3$ referentes ao \textit{Z80} foram provadas
% de forma semi-automática. Ou seja, desse total de provas menos de $1$\%
% necessitaram de uma simples intervenção do projetista para ser concluída.

% Adicionalmente, a aplicação das técnicas modularização e re-uso tornou o processo
% de especificação das plataformas mais padronizado e acelerado. Desse modo, é
% demonstrada a viabilidade dessas especificações, pois com a aquisição de
% maturidade das ferramentas e do projetista, o processo de modelagem ganhou
% agilidade e maior automação na fase de validação do projeto.
% 
% [maior vantagem]
% Enfim, a modelagem B dessas plataformas possibilitarão a verificação em um dos
% mais altos níveis de certificação de \textit{software}. Não somente, elas podem
% ser importantes no projeto de plataformas para a construção dos simuladores,
% documentação e sua própria verificação formal, permitindo identificar várias
% inconsistências delas em tempo de projeto. 
 
[Trabalhos futuros ]
 [O que almejamos citar o AAA]
  In the future, this works like  -> %- Refinar o  modelo  para gerar através dos  código e apartir deste código criar um  interpretador/simulador
% Exp. é possível verificar se o software satisfazer restrições temporais e para isso utiliza

[Fechamento das ideias]
% Desta forma, o suporte fornecido pelo método B é bastante adequado, maduro, extensivo e 
% eficiente no processo de verificação dos modelos das plataformas. Isso vem sendo
% perceptível, pois todas as características relevantes das plataformas foram
%  apropriadamente modeladas, principalmente as importantes para verificação em
%  nível de montagem (\textit{assembly}). 
  
 
\section{Acknowledges}

This work received supports from ANP (National Agency of Oil) and CNPq. 
%Besides, the researcher Bruno Gomes help in the revision.



\begin{thebibliography}{5}


% Paper about BHDL 


% O manual do Z80 

\bibitem {Abrial}
Abrial, J. R. The B Book: Assigning Programs to Meanings. Cambridge University Press, United States of
America, 1 edition, 1996.

\bibitem {BHDL_2003}    
   Aljer, P. Devienne, S. Tison and J-L. Boulanger andG. Mariano. Bhdl: Circuit Design in B. A. In
    ACSD, Third International Conference on Application of Concurrency to System Design, pages 241-242, 2003.

\bibitem {GEMPLUS_99}
Casset L.; Lanet J. L. A Formal Specification of the Java Bytecode Semantics using the B
method.Technical Report, Gemplus. 1999.

\bibitem {CLEARSY}
CLEARSY. Atelier B. http://www.atelierb.eu.


\bibitem {Dantas_Semish08}
Dantas, B; D\'{e}harbe, D; Galv\~{a}o, S; ET AL. Proposta e avalia\c{c}\~{a}o de uma abordagem de desenvolvimento de
 software fidedigno por constru\c{c}\~{a}o com o m\'{e}todo B. In: SEMISH, Bel\'{e}m, 2008. SBC.
 
\bibitem {Dantas_Report08}
Dantas, B; D\'{e}harbe, D; Galv\~{a}o, S; ET AL.Verified compilation based on the B method: initial
appraisal.Technical Report, UFRN - DIMAP, 2008.

\bibitem {Bell} 
 D. Bell, I. M. E. J. P. Software Engineering: A Programming Approach. Prentice Hall, New York, 2 edition, 1992.

\bibitem {HOARE}
HOARE, C. A. R. The verifying compiler, a grand challenge for computing research. In: VMCAI, p. 78-78, 2005.

\bibitem{Medeiros}
 Medeiros Jr, Val\'{e}rio; Galv\~{a}o, Stephenson; D\'{e}harbe, David; Modelagem de Microcontroladores em B. In: ERMAC, Natal, 2008. SBMAC.

\bibitem {WORDSWORTH}
WORDSWORTH, J. B. Software Engineering with B. Addison Wesley, Boston, 1996.


\end{thebibliography}

\end{document}
%
% \bibitem {clar:eke}
% Clarke, F., Ekeland, I.:
% Nonlinear oscillations and
% boundary-value problems for Hamiltonian systems.
% Arch. Rat. Mech. Anal. {\bf 78} (1982) 315--333
% %
% \bibitem {clar:eke:2}
% Clarke, F., Ekeland, I.:
% Solutions p\'{e}riodiques, du
% p\'{e}riode donn\'{e}e, des \'{e}quations hamiltoniennes.
% Note CRAS Paris {\bf 287} (1978) 1013--1015
% %
% \bibitem {mich:tar}
% Michalek, R., Tarantello, G.:
% Subharmonic solutions with prescribed minimal
% period for nonautonomous Hamiltonian systems.
% J. Diff. Eq. {\bf 72} (1988) 28--55
% %
% \bibitem {tar}
% Tarantello, G.:
% Subharmonic solutions for Hamiltonian
% systems via a $\bbbz_{p}$ pseudoindex theory.
% Annali di Matematica Pura (to appear)
% %
% \bibitem {rab}
% Rabinowitz, P.:
% On subharmonic solutions of a Hamiltonian system.
% Comm. Pure Appl. Math. {\bf 33} (1980) 609--633
% \end{thebibliography}
%

