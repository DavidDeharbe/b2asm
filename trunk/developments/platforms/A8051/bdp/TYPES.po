THEORY ProofList IS
  _f(1) & _f(2) & AssertionLemmas.19,(_f(39) => _f(40));
  _f(1) & _f(2) & AssertionLemmas.18,(_f(35) & _f(36) => _f(38));
  _f(1) & _f(2) & AssertionLemmas.17,(_f(35) & _f(36) => _f(37));
  _f(1) & _f(2) & AssertionLemmas.16,(_f(33) => _f(34));
  _f(1) & _f(2) & AssertionLemmas.15,(_f(31) => _f(32));
  _f(1) & _f(2) & AssertionLemmas.14,(_f(29) => _f(30));
  _f(1) & _f(2) & AssertionLemmas.13,(_f(27) => _f(28));
  _f(1) & _f(2) & AssertionLemmas.12,(_f(25) => _f(26));
  _f(1) & _f(2) & AssertionLemmas.11,(_f(23) => _f(24));
  _f(1) & _f(2) & AssertionLemmas.10,(_f(21) => _f(22));
  _f(1) & _f(2) & AssertionLemmas.9,(_f(19) => _f(20));
  _f(1) & _f(2) & AssertionLemmas.8,(_f(17) => _f(18));
  _f(1) & _f(2) & AssertionLemmas.7,(_f(15) => _f(16));
  _f(1) & _f(2) & AssertionLemmas.6,(_f(13) => _f(14));
  _f(1) & _f(2) & AssertionLemmas.5,(_f(11) => _f(12));
  _f(1) & _f(2) & AssertionLemmas.4,(_f(9) => _f(10));
  _f(1) & _f(2) & AssertionLemmas.3,(_f(7) => _f(8));
  _f(1) & _f(2) & AssertionLemmas.2,(_f(5) => _f(6));
  _f(1) & _f(2) & AssertionLemmas.1,(_f(3) => _f(4))
END
&
THEORY Formulas IS
  ("`Component properties'" & MAX_ADDR : INTEGER & 0<=MAX_ADDR & RAM_ADDR = 0..127 & SFR_ADDR = 128..MAX_ADDR & MAX_ADDR = 255 & MEM_ADDR = 0..MAX_ADDR & NB_WORD : INTEGER & 0<=NB_WORD & WORD_LEN : INTEGER & 0<=WORD_LEN & WORD_LEN = 8 & WORD_POSITION = 0..WORD_LEN-1 & NB_WORD = 2**WORD_LEN & WORD = 0..NB_WORD-1 & NB_INSTRUCTIONS = 256 & INSTRUCTION_MAX = NB_INSTRUCTIONS-1 & INSTRUCTION = 0..INSTRUCTION_MAX & INSTRUCTION_IJUMP : INSTRUCTION*INSTRUCTION +-> INSTRUCTION & dom(INSTRUCTION_IJUMP) = INSTRUCTION*INSTRUCTION & !(i,j).(i : INSTRUCTION & j : INSTRUCTION & (i+j : INTEGER & 0<=i+j) => (255<=i+j => INSTRUCTION_IJUMP(i,j) = 0) & (i+j+1<=255 => INSTRUCTION_IJUMP(i,j) = i+j+1)) & INSTRUCTION_NEXT : INSTRUCTION +-> INSTRUCTION & dom(INSTRUCTION_NEXT) = INSTRUCTION & ran(INSTRUCTION_NEXT) = INSTRUCTION & !i.(i : INSTRUCTION => (i = 255 => INSTRUCTION_NEXT(i) = 0) & (i+1<=255 => INSTRUCTION_NEXT(i) = i+1)) & WORD_TO_INT : WORD +-> INT & dom(WORD_TO_INT) = WORD & ran(WORD_TO_INT) = INT & !i.(i : WORD & (i+0 : INTEGER & 0<=i+0) & 1<=i & i<=255 & 1<=i+0 & i+0<=255 => WORD_TO_INT(i) = i+0) & BV_TO_WORD : BV8 +-> WORD & dom(BV_TO_WORD) = BV8 & WORD_TO_BV : WORD +-> BV8 & dom(WORD_TO_BV) = WORD & !(w,v).(w : WORD & v : BV8 => (v = WORD_TO_BV(w) => w = 128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0)) & (w = 128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0) => v = WORD_TO_BV(w))) & BV_TO_WORD = WORD_TO_BV~);
  ("`Included,imported and extended machines properties'" & BV8_INDEX = 0..7 & BV8 = BV8_INDEX --> BIT & BV8_SET_BIT : BV8*BV8_INDEX*BIT +-> BV8 & dom(BV8_SET_BIT) = BV8*BV8_INDEX*BIT & !(v,i,j,b).(v : BV8 & i : BV8_INDEX & j : BV8_INDEX & b : BIT & not(i = j) => BV8_SET_BIT(v,i,b)(j) = v(j)) & !(v,i,b).(v : BV8 & i : BV8_INDEX & b : BIT => BV8_SET_BIT(v,i,b)(i) = b) & BV8_COMPLEMENT : BV8 +-> BV8 & dom(BV8_COMPLEMENT) = BV8 & !(v,i).(v : BV8 & i : BV8_INDEX => BV8_COMPLEMENT(v)(i) = BIT_FLIP(v(i))) & BV8_ALL_ZEROES : BV8 & !i.(i : BV8_INDEX => BV8_ALL_ZEROES(i) = 0) & BV8_AND : BV8*BV8 +-> BV8 & dom(BV8_AND) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_AND(v1,v2)(i) = BIT_AND(v1(i),v2(i))) & BV8_IOR : BV8*BV8 +-> BV8 & dom(BV8_IOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_IOR(v1,v2)(i) = BIT_IOR(v1(i),v2(i))) & BV8_XOR : BV8*BV8 +-> BV8 & dom(BV8_XOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_XOR(v1,v2)(i) = BIT_XOR(v1(i),v2(i))) & BIT = 0..1 & BIT_FLIP : BIT +-> BIT & dom(BIT_FLIP) = BIT & !b.(b : BIT => BIT_FLIP(b) = 1-b) & BIT_AND : BIT*BIT +-> BIT & dom(BIT_AND) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_AND(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_AND(b1,b2) = 1) & b2 = 1) & BIT_IOR : BIT*BIT +-> BIT & dom(BIT_IOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_IOR(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_IOR(b1,b2) = 1) or b2 = 1) & BIT_XOR : BIT*BIT +-> BIT & dom(BIT_XOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_XOR(b1,b2) = 1 => b1 = 1 & b2 = 0 or (b1 = 0 & b2 = 1)) & ((b1 = 1 & b2 = 0 => BIT_XOR(b1,b2) = 1) & (b1 = 0 & b2 = 1 => BIT_XOR(b1,b2) = 1))) & "`Included,imported and extended machines assertions'" & BIT_FLIP(0) = 1 & BIT_FLIP(1) = 0 & BIT_AND(0,0) = 0 & BIT_AND(0,1) = 0 & BIT_AND(1,0) = 0 & BIT_AND(1,1) = 1 & BIT_IOR(0,0) = 0 & BIT_IOR(0,1) = 0 & BIT_IOR(1,0) = 0 & BIT_IOR(1,1) = 1 & BIT_XOR(0,0) = 0 & BIT_XOR(0,1) = 1 & BIT_XOR(1,0) = 1 & BIT_XOR(1,1) = 0);
  "`Check assertion (MEM_ADDR = RAM_ADDR\/SFR_ADDR) deduction - ref 3.2, 4.2, 5.3'";
  (MEM_ADDR = RAM_ADDR\/SFR_ADDR);
  "`Check assertion (SFR_ADDR <: WORD) deduction - ref 3.2, 4.2, 5.3'";
  (SFR_ADDR : POW(WORD));
  "`Check assertion (RAM_ADDR <: WORD) deduction - ref 3.2, 4.2, 5.3'";
  (RAM_ADDR : POW(WORD));
  "`Check assertion (MEM_ADDR <: WORD) deduction - ref 3.2, 4.2, 5.3'";
  (MEM_ADDR : POW(WORD));
  "`Check assertion (INSTRUCTION_IJUMP(3,3) = 7) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_IJUMP(3,3) = 7);
  "`Check assertion (INSTRUCTION_NEXT(6) = 7) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(6) = 7);
  "`Check assertion (INSTRUCTION_NEXT(5) = 6) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(5) = 6);
  "`Check assertion (INSTRUCTION_NEXT(4) = 5) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(4) = 5);
  "`Check assertion (INSTRUCTION_NEXT(3) = 4) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(3) = 4);
  "`Check assertion (INSTRUCTION_NEXT(2) = 3) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(2) = 3);
  "`Check assertion (INSTRUCTION_NEXT(1) = 2) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(1) = 2);
  "`Check assertion (INSTRUCTION_NEXT(0) = 1) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_NEXT(0) = 1);
  "`Check assertion (INSTRUCTION_IJUMP(3,2) = 6) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_IJUMP(3,2) = 6);
  "`Check assertion (INSTRUCTION_IJUMP(2,4) = 7) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_IJUMP(2,4) = 7);
  "`Check assertion (INSTRUCTION_IJUMP(0,2) = 3) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_IJUMP(0,2) = 3);
  "`Check assertion (INSTRUCTION_IJUMP(5,1) = 7) deduction - ref 3.2, 4.2, 5.3'";
  (INSTRUCTION_IJUMP(5,1) = 7);
  ("`Local hypotheses'" & n : WORD);
  "`Check assertion (!n.(n : WORD => 0<=n & n<=255)) deduction - ref 3.2, 4.2, 5.3'";
  (0<=n);
  (n<=255);
  "`Check assertion (NB_WORD = 256) deduction - ref 3.2, 4.2, 5.3'";
  (NB_WORD = 256);
  ("`Component assertions'" & NB_WORD = 256 & !n.(n : WORD => 0<=n & n<=255) & INSTRUCTION_IJUMP(5,1) = 7 & INSTRUCTION_IJUMP(0,2) = 3 & INSTRUCTION_IJUMP(2,4) = 7 & INSTRUCTION_IJUMP(3,2) = 6 & INSTRUCTION_NEXT(0) = 1 & INSTRUCTION_NEXT(1) = 2 & INSTRUCTION_NEXT(2) = 3 & INSTRUCTION_NEXT(3) = 4 & INSTRUCTION_NEXT(4) = 5 & INSTRUCTION_NEXT(5) = 6 & INSTRUCTION_NEXT(6) = 7 & INSTRUCTION_IJUMP(3,3) = 7 & MEM_ADDR : POW(WORD) & RAM_ADDR : POW(WORD) & SFR_ADDR : POW(WORD) & MEM_ADDR = RAM_ADDR\/SFR_ADDR)
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
