
THEORY ProofList IS
_f(5) & _f(4) & _f(3) & _f(2) & _f(1) & _f(8) & _f(7) & _f(11) & _f(10) & _f(6) & Assertions.4,(_f(46) => _f(47));
_f(5) & _f(4) & _f(3) & _f(2) & _f(1) & _f(8) & _f(7) & _f(11) & _f(10) & _f(6) & Assertions.3,(_f(44) => _f(45));
_f(5) & _f(4) & _f(3) & _f(2) & _f(1) & _f(8) & _f(7) & _f(11) & _f(10) & _f(6) & Assertions.2,(_f(42) => _f(43));
_f(5) & _f(4) & _f(3) & _f(2) & _f(1) & _f(8) & _f(7) & _f(11) & _f(10) & _f(6) & Assertions.1,(_f(40) => _f(41));
_f(5) & _f(4) & Properties.14,(_f(38) => _f(39));
_f(5) & _f(4) & Properties.13,(_f(36) => _f(37));
_f(5) & _f(4) & Properties.12,(_f(34) => _f(35));
_f(5) & _f(4) & Properties.11,(_f(32) => _f(33));
_f(5) & _f(4) & Properties.10,(_f(30) => _f(31));
_f(5) & _f(4) & Properties.9,(_f(28) => _f(29));
_f(5) & _f(4) & Properties.8,(_f(26) => _f(27));
_f(5) & _f(4) & Properties.7,(_f(24) => _f(25));
_f(5) & _f(4) & Properties.6,(_f(22) => _f(23));
_f(5) & _f(4) & Properties.5,(_f(20) => _f(21));
_f(5) & _f(4) & Properties.4,(_f(18) => _f(19));
_f(5) & _f(4) & Properties.3,(_f(16) => _f(17));
_f(5) & _f(4) & Properties.2,(_f(14) => _f(15));
_f(5) & _f(4) & Properties.1,(_f(12) => _f(13))

END
&

THEORY Formulas IS
("`Component constraints'" & btrue);
("`Used machines constraints'" & btrue);
("`Component properties'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv_to_int = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))-2*(2**bv_size(bv)*bv(bv_size(bv)))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv_par = %bv.(bv: BIT_VECTOR | size(bv|>{1}) mod 2) & parity_bit: BIT_VECTOR +-> BIT & dom(parity_bit) = BIT_VECTOR & parity_bit = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | bv(idx)) mod 2));
("`Seen and used machines properties'" & BIT = 0..1 & bit_not: BIT +-> BIT & dom(bit_not) = BIT & !bb.(bb: BIT => bit_not(bb) = 1-bb) & bit_and: BIT*BIT +-> BIT & dom(bit_and) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_and(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_and(b1,b2) = 1) & b2 = 1) & bit_or: BIT*BIT +-> BIT & dom(bit_or) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_or(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_or(b1,b2) = 1) or b2 = 1) & bit_xor: BIT*BIT +-> BIT & dom(bit_xor) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_xor(b1,b2) = 1 => not(b1 = b2)) & (not(b1 = b2) => bit_xor(b1,b2) = 1)) & bool_to_bit: BOOL +-> BIT & dom(bool_to_bit) = BOOL & bool_to_bit = {TRUE|->1}\/{FALSE|->0} & BIT_VECTOR = seq(BIT)-{{}} & bv_size: BIT_VECTOR +-> NATURAL-{0} & dom(bv_size) = BIT_VECTOR & bv_size = %bv.(bv: BIT_VECTOR | size(bv)) & bv_catenate: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_catenate) = BIT_VECTOR*BIT_VECTOR & bv_catenate = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR | v1^v2) & bv_sub: BIT_VECTOR*NATURAL*NATURAL +-> BIT_VECTOR & dom(bv_sub) = BIT_VECTOR*NATURAL*NATURAL & bv_sub = %(bv,low,high).(bv: BIT_VECTOR & low: 1..bv_size(bv) & high: 1..bv_size(bv) & low<=high | low..high<|bv) & bv_zero: NATURAL-{0} +-> BIT_VECTOR & dom(bv_zero) = NATURAL-{0} & bv_zero = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (1..sz)*{0}) & bv_one: NATURAL-{0} +-> BIT_VECTOR & dom(bv_one) = NATURAL-{0} & bv_one = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (1..sz)*{1}) & bv_not: BIT_VECTOR +-> BIT_VECTOR & dom(bv_not) = BIT_VECTOR & bv_not = %v1.(v1: BIT_VECTOR | %idx.(idx: 1..size(v1) | bit_not(v1(idx)))) & bv_and: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_and) = BIT_VECTOR*BIT_VECTOR & bv_and = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: 1..bv_size(v1) | bit_and(v1(idx),v2(idx)))) & bv_or: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_or) = BIT_VECTOR*BIT_VECTOR & bv_or = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: 1..bv_size(v1) | bit_or(v1(idx),v2(idx)))) & bv_xor: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_xor) = BIT_VECTOR*BIT_VECTOR & bv_xor = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) | %idx.(idx: 1..bv_size(v1) | bit_xor(v1(idx),v2(idx)))) & bv_at: BIT_VECTOR*NATURAL +-> BIT & dom(bv_at) = BIT_VECTOR*NATURAL & bv_at = %(v1,idx).(v1: BIT_VECTOR & idx: INTEGER & 0<=idx & idx+1<=bv_size(v1) | v1(idx+1)) & bv_set: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_set) = BIT_VECTOR*NATURAL & bv_set = %(v1,idx).(v1: BIT_VECTOR & idx: INTEGER & 0<=idx & idx+1<=bv_size(v1) | v1<+{idx+1|->1}) & bv_clear: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_clear) = BIT_VECTOR*NATURAL & bv_clear = %(v1,idx).(v1: BIT_VECTOR & idx: INTEGER & 0<=idx & idx+1<=bv_size(v1) | v1<+{idx+1|->0}) & bv_put: BIT_VECTOR*NATURAL*BIT +-> BIT_VECTOR & dom(bv_put) = BIT_VECTOR*NATURAL*BIT & bv_put = %(v1,idx,bit).(v1: BIT_VECTOR & idx: INTEGER & 0<=idx & idx+1<=bv_size(v1) & bit: BIT | v1<+{idx+1|->bit}));
("`Included,imported and extended machines properties'" & btrue);
("`Component invariant'" & btrue);
("`Seen and used machines invariants'" & btrue);
("`Included,imported and extended machines invariants'" & btrue);
("`Component assertions'" & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_to_nat(bv_zero(ss)) = 0) & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_par(bv_zero(ss)) = 0));
("`Seen and used machines assertions'" & bit_not(0) = 1 & bit_not(1) = 0 & !bb.(bb: BIT => bit_not(bit_not(bb)) = bb) & bit_and(0,0) = 0 & bit_and(0,1) = 0 & bit_and(1,0) = 0 & bit_and(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_and(b1,b2) = bit_and(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 1 => bit_and(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_and(b1,b2) = 0 => bit_and(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_and(b1,bit_and(b2,b3)) = bit_and(bit_and(b1,b2),b3)) & !b1.(b1: BIT => bit_and(b1,1) = b1) & !b1.(b1: BIT => bit_and(b1,0) = 0) & bit_or(0,0) = 0 & bit_or(0,1) = 1 & bit_or(1,0) = 1 & bit_or(1,1) = 1 & !(b1,b2).(b1: BIT & b2: BIT => bit_or(b1,b2) = bit_or(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 1 => bit_or(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,b2) = 0 => bit_or(b2,b1) = 0) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 1 => b1 = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_or(b1,0) = 0 => b1 = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_or(b1,bit_or(b2,b3)) = bit_or(bit_or(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_or(b1,b2) = 1 => bit_or(b1,bit_or(b2,b3)) = bit_or(1,b3)) & !b1.(b1: BIT => bit_or(b1,1) = 1) & !b1.(b1: BIT => bit_or(b1,0) = b1) & !b1.(b1: BIT => bit_or(1,b1) = 1) & !b1.(b1: BIT => bit_or(0,b1) = b1) & bit_xor(0,0) = 0 & bit_xor(0,1) = 1 & bit_xor(1,0) = 1 & bit_xor(1,1) = 0 & !(b1,b2).(b1: BIT & b2: BIT => bit_xor(b1,b2) = bit_xor(b2,b1)) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 1 => bit_xor(b2,b1) = 1) & !(b1,b2).(b1: BIT & b2: BIT & bit_xor(b1,b2) = 0 => bit_xor(b2,b1) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(bit_xor(b1,b2),b3)) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT & bit_xor(b1,b2) = 1 => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(1,b3)) & !bb.(bb: BIT => bit_xor(bb,bb) = 0) & bool_to_bit(TRUE) = 1 & bool_to_bit(FALSE) = 0 & !bv.(bv: BIT_VECTOR => bv_size(bv_not(bv)) = bv_size(bv)) & !(bv,indx).(bv: BIT_VECTOR & indx: 1..bv_size(bv) => bv_not(bv_not(bv))(indx) = bv(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR => bv_size(bv_catenate(v1,v2)) = bv_size(v1)+bv_size(v2)) & !(bv,low,high).(bv: BIT_VECTOR & low: INTEGER & 0<=low & high: INTEGER & 0<=high & low<=high => bv_size(bv_sub(bv,low,high)) = high-low) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_and(v1,v2)) = bv_size(v2)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: 1..bv_size(v1) => bv_and(v1,v2)(indx) = bv_and(v2,v1)(indx)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) & indx: 1..bv_size(v1) => bv_and(v1,bv_and(v2,v3))(indx) = bv_and(bv_and(v1,v2),v3)(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 1..bv_size(bv) => bv_and(bv,bv_zero(bv_size(bv)))(indx) = bv_zero(bv_size(bv))(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 1..bv_size(bv) => bv_and(bv,bv_one(bv_size(bv)))(indx) = bv(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v1)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: 1..bv_size(v1) => bv_or(v1,v2)(indx) = bv_or(v2,v1)(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v2)) & !(v1,v2,v3,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) & indx: 1..bv_size(v1) => bv_or(v1,bv_or(v2,v3))(indx) = bv_or(bv_or(v1,v2),v3)(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 1..bv_size(bv) => bv_or(bv,bv_one(bv_size(bv)))(indx) = bv_one(bv_size(bv))(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 1..bv_size(bv) => bv_or(bv,bv_zero(bv_size(bv)))(indx) = bv(indx)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v2)) & !(v1,v2,indx).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) & indx: 1..bv_size(v1) => bv_xor(v1,v2)(indx) = bv_xor(v2,v1)(indx)) & !(bv,indx).(bv: BIT_VECTOR & indx: 1..bv_size(bv) => bv_xor(bv,bv)(indx) = bv_zero(bv_size(bv))(indx)));
("`Included,imported and extended machines assertions'" & btrue);
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv: BIT_VECTOR);
(SET(idx).(idx: dom(bv)): FIN(SET(idx).(idx: dom(bv))));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv: BIT_VECTOR & idx: dom(bv));
(0<=idx);
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv: BIT_VECTOR & idx: dom(bv));
(bv: dom(bv) +-> ran(bv));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv: BIT_VECTOR);
(SET(idx).(idx: dom(bv)): FIN(SET(idx).(idx: dom(bv))));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv: BIT_VECTOR & idx: dom(bv));
(0<=idx);
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv: BIT_VECTOR & idx: dom(bv));
(bv: dom(bv) +-> ran(bv));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv: BIT_VECTOR);
(0<=bv_size(bv));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv: BIT_VECTOR);
(bv_size(bv): dom(bv));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv: BIT_VECTOR);
(bv: dom(bv) +-> ran(bv));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv_to_int = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))-2*(2**bv_size(bv)*bv(bv_size(bv)))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv: BIT_VECTOR);
(bv|>{1}: seq(ran(bv|>{1})));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv_to_int = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))-2*(2**bv_size(bv)*bv(bv_size(bv)))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv: BIT_VECTOR);
(0<=size(bv|>{1}));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv_to_int = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))-2*(2**bv_size(bv)*bv(bv_size(bv)))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv_par = %bv.(bv: BIT_VECTOR | size(bv|>{1}) mod 2) & parity_bit: BIT_VECTOR +-> BIT & dom(parity_bit) = BIT_VECTOR & bv: BIT_VECTOR);
(SET(idx).(idx: dom(bv)): FIN(SET(idx).(idx: dom(bv))));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv_to_int = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))-2*(2**bv_size(bv)*bv(bv_size(bv)))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv_par = %bv.(bv: BIT_VECTOR | size(bv|>{1}) mod 2) & parity_bit: BIT_VECTOR +-> BIT & dom(parity_bit) = BIT_VECTOR & bv: BIT_VECTOR & idx: dom(bv));
(bv: dom(bv) +-> ran(bv));
("`Local hypotheses'" & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & bv_to_int: BIT_VECTOR +-> NATURAL & dom(bv_to_int) = BIT_VECTOR & bv_to_int = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))-2*(2**bv_size(bv)*bv(bv_size(bv)))) & bv_par: BIT_VECTOR +-> BIT & dom(bv_par) = BIT_VECTOR & bv_par = %bv.(bv: BIT_VECTOR | size(bv|>{1}) mod 2) & parity_bit: BIT_VECTOR +-> BIT & dom(parity_bit) = BIT_VECTOR & bv: BIT_VECTOR);
(0<=SIGMA(idx).(idx: dom(bv) | bv(idx)));
("`Local hypotheses'" & ss: INTEGER & 0<=ss & not(ss = 0));
(ss: dom(bv_zero));
("`Local hypotheses'" & ss: INTEGER & 0<=ss & not(ss = 0));
(bv_zero(ss): dom(bv_to_nat));
("`Local hypotheses'" & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_to_nat(bv_zero(ss)) = 0) & ss: INTEGER & 0<=ss & not(ss = 0));
(ss: dom(bv_zero));
("`Local hypotheses'" & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_to_nat(bv_zero(ss)) = 0) & ss: INTEGER & 0<=ss & not(ss = 0));
(bv_zero(ss): dom(bv_par))

END
&

THEORY EnumerateX 

END
