THEORY ProofList IS
  _f(1) & _f(2) & _f(13) & _f(81) & INCS.5,(_f(82) & _f(22) => _f(86));
  _f(1) & _f(2) & _f(13) & _f(81) & INCS.4,(_f(82) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(81) & INCS.3,(_f(82) & _f(16) => _f(85));
  _f(1) & _f(2) & _f(13) & _f(81) & INCS.2,(_f(82) & _f(16) => _f(84));
  _f(1) & _f(2) & _f(13) & _f(81) & INCS.1,(_f(82) & _f(16) => _f(83));
  _f(1) & _f(2) & _f(13) & DEC.5,(_f(80) & _f(22) => _f(47));
  _f(1) & _f(2) & _f(13) & DEC.4,(_f(80) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & DEC.3,(_f(80) & _f(16) => _f(46));
  _f(1) & _f(2) & _f(13) & DEC.2,(_f(80) & _f(16) => _f(45));
  _f(1) & _f(2) & _f(13) & DEC.1,(_f(80) & _f(16) => _f(44));
  _f(1) & _f(2) & _f(13) & INC.5,(_f(79) & _f(22) => _f(47));
  _f(1) & _f(2) & _f(13) & INC.4,(_f(79) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & INC.3,(_f(79) & _f(16) => _f(46));
  _f(1) & _f(2) & _f(13) & INC.2,(_f(79) & _f(16) => _f(45));
  _f(1) & _f(2) & _f(13) & INC.1,(_f(79) & _f(16) => _f(44));
  _f(1) & _f(2) & _f(13) & _f(77) & SUBBD.5,(_f(78) & _f(22) => _f(47));
  _f(1) & _f(2) & _f(13) & _f(77) & SUBBD.4,(_f(78) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(77) & SUBBD.3,(_f(78) & _f(16) => _f(46));
  _f(1) & _f(2) & _f(13) & _f(77) & SUBBD.2,(_f(78) & _f(16) => _f(45));
  _f(1) & _f(2) & _f(13) & _f(77) & SUBBD.1,(_f(78) & _f(16) => _f(44));
  _f(1) & _f(2) & _f(13) & _f(75) & SUBBS.5,(_f(76) & _f(22) => _f(47));
  _f(1) & _f(2) & _f(13) & _f(75) & SUBBS.4,(_f(76) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(75) & SUBBS.3,(_f(76) & _f(16) => _f(46));
  _f(1) & _f(2) & _f(13) & _f(75) & SUBBS.2,(_f(76) & _f(16) => _f(45));
  _f(1) & _f(2) & _f(13) & _f(75) & SUBBS.1,(_f(76) & _f(16) => _f(44));
  _f(1) & _f(2) & _f(13) & _f(73) & ADDD.5,(_f(74) & _f(22) => _f(47));
  _f(1) & _f(2) & _f(13) & _f(73) & ADDD.4,(_f(74) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(73) & ADDD.3,(_f(74) & _f(16) => _f(46));
  _f(1) & _f(2) & _f(13) & _f(73) & ADDD.2,(_f(74) & _f(16) => _f(45));
  _f(1) & _f(2) & _f(13) & _f(73) & ADDD.1,(_f(74) & _f(16) => _f(44));
  _f(1) & _f(2) & _f(13) & _f(71) & ADDS.5,(_f(72) & _f(22) => _f(47));
  _f(1) & _f(2) & _f(13) & _f(71) & ADDS.4,(_f(72) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(71) & ADDS.3,(_f(72) & _f(16) => _f(46));
  _f(1) & _f(2) & _f(13) & _f(71) & ADDS.2,(_f(72) & _f(16) => _f(45));
  _f(1) & _f(2) & _f(13) & _f(71) & ADDS.1,(_f(72) & _f(16) => _f(44));
  _f(1) & _f(2) & _f(13) & _f(64) & CLR.5,(_f(65) & _f(22) => _f(69));
  _f(1) & _f(2) & _f(13) & _f(64) & CLR.4,(_f(65) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(64) & CLR.3,(_f(65) & _f(16) => _f(68));
  _f(1) & _f(2) & _f(13) & _f(64) & CLR.2,(_f(65) & _f(16) => _f(67));
  _f(1) & _f(2) & _f(13) & _f(64) & CLR.1,(_f(65) & _f(16) => _f(66));
  _f(1) & _f(2) & _f(13) & _f(61) & JNB.2,(_f(63) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(61) & JNB.1,(_f(62) & _f(20) => _f(21));
  _f(1) & _f(2) & _f(13) & _f(58) & JC.2,(_f(60) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(58) & JC.1,(_f(59) & _f(20) => _f(21));
  _f(1) & _f(2) & _f(13) & _f(57) & SJMP.1,(_f(20) => _f(21));
  _f(1) & _f(2) & _f(13) & _f(48) & ACALL.5,(_f(55) => _f(56));
  _f(1) & _f(2) & _f(13) & _f(48) & ACALL.4,(_f(52) => _f(54));
  _f(1) & _f(2) & _f(13) & _f(48) & ACALL.3,(_f(52) => _f(53));
  _f(1) & _f(2) & _f(13) & _f(48) & ACALL.2,(_f(49) => _f(51));
  _f(1) & _f(2) & _f(13) & _f(48) & ACALL.1,(_f(49) => _f(50));
  _f(1) & _f(2) & _f(13) & _f(42) & ANL.5,(_f(43) & _f(22) => _f(47));
  _f(1) & _f(2) & _f(13) & _f(42) & ANL.4,(_f(43) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(42) & ANL.3,(_f(43) & _f(16) => _f(46));
  _f(1) & _f(2) & _f(13) & _f(42) & ANL.2,(_f(43) & _f(16) => _f(45));
  _f(1) & _f(2) & _f(13) & _f(42) & ANL.1,(_f(43) & _f(16) => _f(44));
  _f(1) & _f(2) & _f(13) & _f(40) & MOVI.5,(_f(41) & _f(22) => _f(39));
  _f(1) & _f(2) & _f(13) & _f(40) & MOVI.4,(_f(41) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(40) & MOVI.3,(_f(41) & _f(16) => _f(38));
  _f(1) & _f(2) & _f(13) & _f(40) & MOVI.2,(_f(41) & _f(16) => _f(37));
  _f(1) & _f(2) & _f(13) & _f(40) & MOVI.1,(_f(41) & _f(16) => _f(36));
  _f(1) & _f(2) & _f(13) & _f(35) & MOV.5,(_f(22) => _f(39));
  _f(1) & _f(2) & _f(13) & _f(35) & MOV.4,(_f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(35) & MOV.3,(_f(16) => _f(38));
  _f(1) & _f(2) & _f(13) & _f(35) & MOV.2,(_f(16) => _f(37));
  _f(1) & _f(2) & _f(13) & _f(35) & MOV.1,(_f(16) => _f(36));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.11,(_f(34) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.10,(_f(33) & _f(22) => _f(28));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.9,(_f(33) & _f(20) => _f(21));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.8,(_f(33) & _f(16) => _f(27));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.7,(_f(33) & _f(16) => _f(26));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.6,(_f(33) & _f(16) => _f(25));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.5,(_f(32) & _f(22) => _f(23));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.4,(_f(32) & _f(20) => _f(21));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.3,(_f(32) & _f(16) => _f(19));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.2,(_f(32) & _f(16) => _f(18));
  _f(1) & _f(2) & _f(13) & _f(31) & CJNEI.1,(_f(32) & _f(16) => _f(17));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.11,(_f(29) & _f(20) => _f(30));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.10,(_f(24) & _f(22) => _f(28));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.9,(_f(24) & _f(20) => _f(21));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.8,(_f(24) & _f(16) => _f(27));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.7,(_f(24) & _f(16) => _f(26));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.6,(_f(24) & _f(16) => _f(25));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.5,(_f(15) & _f(22) => _f(23));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.4,(_f(15) & _f(20) => _f(21));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.3,(_f(15) & _f(16) => _f(19));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.2,(_f(15) & _f(16) => _f(18));
  _f(1) & _f(2) & _f(13) & _f(14) & CJNE.1,(_f(15) & _f(16) => _f(17));
  _f(1) & _f(2) & Initialisation.5,(_f(3) & _f(11) => _f(12));
  _f(1) & _f(2) & Initialisation.4,(_f(3) & _f(9) => _f(10));
  _f(1) & _f(2) & Initialisation.3,(_f(3) & _f(6) => _f(8));
  _f(1) & _f(2) & Initialisation.2,(_f(3) & _f(6) => _f(7));
  _f(1) & _f(2) & Initialisation.1,(_f(3) & _f(4) => _f(5))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & MAX_ADDR : INTEGER & 0<=MAX_ADDR & RAM_ADDR = 0..127 & SFR_ADDR = 128..MAX_ADDR & MAX_ADDR = 255 & MEM_ADDR = 0..MAX_ADDR & NB_WORD : INTEGER & 0<=NB_WORD & WORD_LEN : INTEGER & 0<=WORD_LEN & WORD_LEN = 8 & WORD_POSITION = 0..WORD_LEN-1 & NB_WORD = 2**WORD_LEN & WORD = 0..NB_WORD-1 & NB_INSTRUCTIONS = 256 & INSTRUCTION_MAX = NB_INSTRUCTIONS-1 & INSTRUCTION = 0..INSTRUCTION_MAX & INSTRUCTION_IJUMP : INSTRUCTION*INSTRUCTION +-> INSTRUCTION & dom(INSTRUCTION_IJUMP) = INSTRUCTION*INSTRUCTION & !(i,j).(i : INSTRUCTION & j : INSTRUCTION & (i+j : INTEGER & 0<=i+j) => (255<=i+j => INSTRUCTION_IJUMP(i,j) = 0) & (i+j+1<=255 => INSTRUCTION_IJUMP(i,j) = i+j+1)) & INSTRUCTION_NEXT : INSTRUCTION +-> INSTRUCTION & dom(INSTRUCTION_NEXT) = INSTRUCTION & ran(INSTRUCTION_NEXT) = INSTRUCTION & !i.(i : INSTRUCTION => (i = 255 => INSTRUCTION_NEXT(i) = 0) & (i+1<=255 => INSTRUCTION_NEXT(i) = i+1)) & WORD_TO_INT : WORD +-> INT & dom(WORD_TO_INT) = WORD & ran(WORD_TO_INT) = INT & !i.(i : WORD & (i+0 : INTEGER & 0<=i+0) & 1<=i & i<=255 & 1<=i+0 & i+0<=255 => WORD_TO_INT(i) = i+0) & BV_TO_WORD : BV8 +-> WORD & dom(BV_TO_WORD) = BV8 & WORD_TO_BV : WORD +-> BV8 & dom(WORD_TO_BV) = WORD & !(w,v).(w : WORD & v : BV8 => (v = WORD_TO_BV(w) => w = 128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0)) & (w = 128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0) => v = WORD_TO_BV(w))) & BV_TO_WORD = WORD_TO_BV~ & BIT_ADDRESS = WORD*WORD_POSITION & BV8_INDEX = 0..7 & BV8 = BV8_INDEX --> BIT & BV8_SET_BIT : BV8*BV8_INDEX*BIT +-> BV8 & dom(BV8_SET_BIT) = BV8*BV8_INDEX*BIT & !(v,i,j,b).(v : BV8 & i : BV8_INDEX & j : BV8_INDEX & b : BIT & not(i = j) => BV8_SET_BIT(v,i,b)(j) = v(j)) & !(v,i,b).(v : BV8 & i : BV8_INDEX & b : BIT => BV8_SET_BIT(v,i,b)(i) = b) & BV8_COMPLEMENT : BV8 +-> BV8 & dom(BV8_COMPLEMENT) = BV8 & !(v,i).(v : BV8 & i : BV8_INDEX => BV8_COMPLEMENT(v)(i) = BIT_FLIP(v(i))) & BV8_ALL_ZEROES : BV8 & !i.(i : BV8_INDEX => BV8_ALL_ZEROES(i) = 0) & BV8_AND : BV8*BV8 +-> BV8 & dom(BV8_AND) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_AND(v1,v2)(i) = BIT_AND(v1(i),v2(i))) & BV8_IOR : BV8*BV8 +-> BV8 & dom(BV8_IOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_IOR(v1,v2)(i) = BIT_IOR(v1(i),v2(i))) & BV8_XOR : BV8*BV8 +-> BV8 & dom(BV8_XOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_XOR(v1,v2)(i) = BIT_XOR(v1(i),v2(i))) & BV8_PAR : BV8 +-> BIT & dom(BV8_PAR) = BV8 & !v1.(v1 : BV8 & BIT_XOR(v1(7),v1(6)) : BIT & BIT_XOR(v1(5),v1(4)) : BIT & BIT_XOR(v1(3),v1(2)) : BIT & BIT_XOR(v1(1),v1(0)) : BIT => BV8_PAR(v1) = BIT_XOR(BIT_XOR(BIT_XOR(v1(7),v1(6)),BIT_XOR(v1(5),v1(4))),BIT_XOR(BIT_XOR(v1(3),v1(2)),BIT_XOR(v1(1),v1(0))))) & BIT = 0..1 & BIT_FLIP : BIT +-> BIT & dom(BIT_FLIP) = BIT & !b.(b : BIT => BIT_FLIP(b) = 1-b) & BIT_AND : BIT*BIT +-> BIT & dom(BIT_AND) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_AND(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_AND(b1,b2) = 1) & b2 = 1) & BIT_IOR : BIT*BIT +-> BIT & dom(BIT_IOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_IOR(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_IOR(b1,b2) = 1) or b2 = 1) & BIT_XOR : BIT*BIT +-> BIT & dom(BIT_XOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_XOR(b1,b2) = 1 => b1 = 1 & b2 = 0 or (b1 = 0 & b2 = 1)) & ((b1 = 1 & b2 = 0 => BIT_XOR(b1,b2) = 1) & (b1 = 0 & b2 = 1 => BIT_XOR(b1,b2) = 1))) & add : WORD*WORD +-> WORD*BOOL*BOOL & dom(add) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & (w1+w2 : INTEGER & 0<=w1+w2) => (w1+w2<=255 => add(w1,w2) = (w1+w2,bool(w1+w2 = 0))|->FALSE) & (256<=w1+w2 => add(w1,w2) = (w1+w2-256,bool(w1+w2 = 256))|->TRUE)) & substract : WORD*WORD +-> WORD*BOOL*BOOL & dom(substract) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & w1-w2 : INTEGER => (w1-w2+1<=0 => substract(w1,w2) = (w1-w2+256,FALSE)|->TRUE) & (0<=w1-w2 => substract(w1,w2) = (w1-w2,bool(w1-w2 = 0))|->FALSE)) & and : WORD*WORD +-> WORD*BOOL & dom(and) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & BV_TO_WORD(BV8_AND(WORD_TO_BV(w1),WORD_TO_BV(w2))) : WORD => and(w1,w2) = BV_TO_WORD(BV8_AND(WORD_TO_BV(w1),WORD_TO_BV(w2)))|->bool(BV_TO_WORD(BV8_AND(WORD_TO_BV(w1),WORD_TO_BV(w2))) = 0)) & ior : WORD*WORD +-> WORD*BOOL & dom(ior) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & BV_TO_WORD(BV8_IOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) : WORD => ior(w1,w2) = BV_TO_WORD(BV8_IOR(WORD_TO_BV(w1),WORD_TO_BV(w2)))|->bool(BV_TO_WORD(BV8_IOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) = 0)) & xor : WORD*WORD +-> WORD*BOOL & dom(xor) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & BV_TO_WORD(BV8_XOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) : WORD => xor(w1,w2) = BV_TO_WORD(BV8_XOR(WORD_TO_BV(w1),WORD_TO_BV(w2)))|->bool(BV_TO_WORD(BV8_XOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) = 0)) & par : WORD +-> BIT & dom(par) = WORD & !w1.(w1 : WORD => par(w1) = BV8_PAR(WORD_TO_BV(w1))) & bitget : WORD*WORD_POSITION +-> BIT & dom(bitget) = WORD*WORD_POSITION & !(w,i).(w : WORD & i : WORD_POSITION => bitget(w,i) = WORD_TO_BV(w)(i)) & bitset : WORD*WORD_POSITION +-> WORD & dom(bitset) = WORD*WORD_POSITION & !(w,i).(w : WORD & i : WORD_POSITION => bitset(w,i) = BV_TO_WORD(BV8_SET_BIT(WORD_TO_BV(w),i,1))) & bitclear : WORD*WORD_POSITION +-> WORD & dom(bitclear) = WORD*WORD_POSITION & !(w,i,b).(w : WORD & i : WORD_POSITION & b : BIT => bitclear(w,i) = BV_TO_WORD(BV8_SET_BIT(WORD_TO_BV(w),i,0))) & complement : WORD +-> WORD & dom(complement) = WORD & !w.(w : WORD => complement(w) = BV_TO_WORD(BV8_COMPLEMENT(WORD_TO_BV(w)))) & swap : WORD +-> WORD & dom(swap) = WORD & !w.(w : WORD & WORD_TO_BV(w) : BV8 => swap(w) = BV_TO_WORD({0|->WORD_TO_BV(w)(4)}\/{1|->WORD_TO_BV(w)(5)}\/{2|->WORD_TO_BV(w)(6)}\/{3|->WORD_TO_BV(w)(7)}\/{4|->WORD_TO_BV(w)(0)}\/{5|->WORD_TO_BV(w)(1)}\/{6|->WORD_TO_BV(w)(2)}\/{7|->WORD_TO_BV(w)(3)})) & rotateleft : WORD +-> WORD*BOOL & dom(rotateleft) = WORD & !w.(w : WORD & WORD_TO_BV(w) : BV8 => rotateleft(w) = BV_TO_WORD({0|->WORD_TO_BV(w)(7)}\/{1|->WORD_TO_BV(w)(0)}\/{2|->WORD_TO_BV(w)(1)}\/{3|->WORD_TO_BV(w)(2)}\/{4|->WORD_TO_BV(w)(3)}\/{5|->WORD_TO_BV(w)(4)}\/{6|->WORD_TO_BV(w)(5)}\/{7|->WORD_TO_BV(w)(6)})|->bool(WORD_TO_BV(w)(7) = 1)) & rotateright : WORD +-> WORD*BOOL & dom(rotateright) = WORD & !w.(w : WORD & WORD_TO_BV(w) : BV8 => rotateright(w) = BV_TO_WORD({0|->WORD_TO_BV(w)(1)}\/{1|->WORD_TO_BV(w)(2)}\/{2|->WORD_TO_BV(w)(3)}\/{3|->WORD_TO_BV(w)(4)}\/{4|->WORD_TO_BV(w)(5)}\/{5|->WORD_TO_BV(w)(6)}\/{6|->WORD_TO_BV(w)(7)}\/{7|->WORD_TO_BV(w)(0)})|->bool(WORD_TO_BV(w)(0) = 1)) & "`Component properties'" & sbuf = 153 & R0 = 0 & R1 = 1 & R2 = 2 & R3 = 3 & R4 = 4 & R5 = 5 & R6 = 6 & R7 = 7 & a = 240 & P0 = 128 & P1 = 144 & P2 = 160 & P3 = 176 & scon = 152 & psw = 208 & P : BIT_ADDRESS & P = psw|->0);
  ("`Seen and used machines assertions'" & NB_WORD = 256 & !n.(n : WORD => 0<=n & n<=255) & INSTRUCTION_IJUMP(5,1) = 7 & INSTRUCTION_IJUMP(0,2) = 3 & INSTRUCTION_IJUMP(2,4) = 7 & INSTRUCTION_IJUMP(3,2) = 6 & INSTRUCTION_NEXT(0) = 1 & INSTRUCTION_NEXT(1) = 2 & INSTRUCTION_NEXT(2) = 3 & INSTRUCTION_NEXT(3) = 4 & INSTRUCTION_NEXT(4) = 5 & INSTRUCTION_NEXT(5) = 6 & INSTRUCTION_NEXT(6) = 7 & INSTRUCTION_IJUMP(3,3) = 7 & MEM_ADDR : POW(WORD) & RAM_ADDR : POW(WORD) & SFR_ADDR : POW(WORD) & MEM_ADDR = RAM_ADDR\/SFR_ADDR & BIT_FLIP(0) = 1 & BIT_FLIP(1) = 0 & BIT_AND(0,0) = 0 & BIT_AND(0,1) = 0 & BIT_AND(1,0) = 0 & BIT_AND(1,1) = 1 & BIT_IOR(0,0) = 0 & BIT_IOR(0,1) = 0 & BIT_IOR(1,0) = 0 & BIT_IOR(1,1) = 1 & BIT_XOR(0,0) = 0 & BIT_XOR(0,1) = 1 & BIT_XOR(1,0) = 1 & BIT_XOR(1,1) = 0 & dom(add) = WORD*WORD & ran(add) : POW(WORD*BOOL*BOOL) & dom(substract) = WORD*WORD & ran(substract) : POW(WORD*BOOL*BOOL) & dom(and) = WORD*WORD & ran(and) : POW(WORD*BOOL) & dom(ior) = WORD*WORD & ran(ior) : POW(WORD*BOOL) & dom(xor) = WORD*WORD & ran(xor) : POW(WORD*BOOL) & dom(bitclear) = WORD*WORD_POSITION & ran(bitclear) : POW(WORD) & dom(bitset) = WORD*WORD_POSITION & ran(bitset) : POW(WORD) & dom(bitget) = WORD*WORD_POSITION & ran(bitget) : POW(BIT) & dom(complement) = WORD & ran(complement) : POW(WORD) & dom(swap) = WORD & ran(swap) : POW(WORD) & ran(rotateleft) : POW(WORD*BOOL) & dom(rotateleft) = WORD & dom(rotateright) = WORD & ran(rotateright) : POW(WORD*BOOL));
  ("`Local hypotheses'" & mem$0 : MEM_ADDR +-> WORD & dom(mem$0) = MEM_ADDR & ran(mem$0) = WORD);
  "`Check that the invariant (pc : INSTRUCTION) is established by the initialisation - ref 3.3'";
  (0 : INSTRUCTION);
  "`Check that the invariant (stack : NATURAL +->> INSTRUCTION) is established by the initialisation - ref 3.3'";
  ({} : NATURAL +-> INSTRUCTION);
  (ran({}) = INSTRUCTION);
  "`Check that the invariant (dom(stack) = 0..sp-1) is established by the initialisation - ref 3.3'";
  (dom({}) = 0.. -1);
  "`Check that the invariant (bitget(P) = par(mem(a))) is established by the initialisation - ref 3.3'";
  (bitget(P) = par(mem$0(a)));
  ("`Component invariant'" & mem : MEM_ADDR +-> WORD & dom(mem) = MEM_ADDR & ran(mem) = WORD & pc : INSTRUCTION & sp : INTEGER & 0<=sp & stack : NATURAL +-> INSTRUCTION & ran(stack) = INSTRUCTION & dom(stack) = 0..sp-1 & bitget(P) = par(mem(a)));
  ("`CJNE preconditions in this component'" & addr : MEM_ADDR & data : WORD & jump : INSTRUCTION);
  ("`Local hypotheses'" & not(mem(addr) = data) & mem(addr)+1<=data);
  "`Check that the invariant (mem : MEM_ADDR -->> WORD) is preserved by the operation - ref 3.4'";
  (mem<+{psw|->bitset(mem(psw),7)} : MEM_ADDR +-> WORD);
  (dom(mem<+{psw|->bitset(mem(psw),7)}) = MEM_ADDR);
  (ran(mem<+{psw|->bitset(mem(psw),7)}) = WORD);
  "`Check that the invariant (pc : INSTRUCTION) is preserved by the operation - ref 3.4'";
  (INSTRUCTION_IJUMP(pc,jump) : INSTRUCTION);
  "`Check that the invariant (bitget(P) = par(mem(a))) is preserved by the operation - ref 3.4'";
  (bitget(P) = par((mem<+{psw|->bitset(mem(psw),7)})(a)));
  ("`Local hypotheses'" & not(mem(addr) = data) & not(mem(addr)+1<=data));
  (mem<+{psw|->bitclear(mem(psw),7)} : MEM_ADDR +-> WORD);
  (dom(mem<+{psw|->bitclear(mem(psw),7)}) = MEM_ADDR);
  (ran(mem<+{psw|->bitclear(mem(psw),7)}) = WORD);
  (bitget(P) = par((mem<+{psw|->bitclear(mem(psw),7)})(a)));
  ("`Local hypotheses'" & mem(addr) = data);
  (INSTRUCTION_NEXT(pc) : INSTRUCTION);
  ("`CJNEI preconditions in this component'" & Rn : RAM_ADDR & (Rn = R1 or Rn = R2) & data : WORD & jump : INSTRUCTION & mem(Rn) : RAM_ADDR);
  ("`Local hypotheses'" & addr : RAM_ADDR & addr = mem(Rn) & not(mem(addr) = data) & mem(addr)+1<=data);
  ("`Local hypotheses'" & addr : RAM_ADDR & addr = mem(Rn) & not(mem(addr) = data) & not(mem(addr)+1<=data));
  ("`Local hypotheses'" & addr : RAM_ADDR & addr = mem(Rn) & mem(addr) = data);
  ("`MOV preconditions in this component'" & addr : MEM_ADDR & data : WORD);
  (mem<+{addr|->data} : MEM_ADDR +-> WORD);
  (dom(mem<+{addr|->data}) = MEM_ADDR);
  (ran(mem<+{addr|->data}) = WORD);
  (bitget(P) = par((mem<+{addr|->data})(a)));
  ("`MOVI preconditions in this component'" & Rn : RAM_ADDR & (Rn = R1 or Rn = R2) & data : WORD & mem(Rn) : RAM_ADDR);
  ("`Local hypotheses'" & addr : RAM_ADDR & addr = mem(Rn));
  ("`ANL preconditions in this component'" & addr : RAM_ADDR);
  ("`Local hypotheses'" & result : WORD & b : BOOL & result,b = and(a,addr));
  (mem<+{a|->result} : MEM_ADDR +-> WORD);
  (dom(mem<+{a|->result}) = MEM_ADDR);
  (ran(mem<+{a|->result}) = WORD);
  (bitget(P) = par((mem<+{a|->result})(a)));
  ("`ACALL preconditions in this component'" & inst : INSTRUCTION);
  "`Check that the invariant (sp : NATURAL) is preserved by the operation - ref 3.4'";
  (sp+1 : INTEGER);
  (0<=sp+1);
  "`Check that the invariant (stack : NATURAL +->> INSTRUCTION) is preserved by the operation - ref 3.4'";
  (stack<+{sp|->INSTRUCTION_NEXT(pc)} : NATURAL +-> INSTRUCTION);
  (ran(stack<+{sp|->INSTRUCTION_NEXT(pc)}) = INSTRUCTION);
  "`Check that the invariant (dom(stack) = 0..sp-1) is preserved by the operation - ref 3.4'";
  (dom(stack<+{sp|->INSTRUCTION_NEXT(pc)}) = 0..sp+1-1);
  ("`SJMP preconditions in this component'" & jump : INSTRUCTION);
  ("`JC preconditions in this component'" & jump : INSTRUCTION);
  ("`Local hypotheses'" & bitget(mem(psw),7) = 1);
  ("`Local hypotheses'" & not(bitget(mem(psw),7) = 1));
  ("`JNB preconditions in this component'" & bit : BIT & jump : INSTRUCTION);
  ("`Local hypotheses'" & bit = 0);
  ("`Local hypotheses'" & not(bit = 0));
  ("`CLR preconditions in this component'" & b : BIT_ADDRESS);
  ("`Local hypotheses'" & w : WORD & p : WORD_POSITION & w,p = b);
  (mem<+{w|->bitset(mem(w),p)} : MEM_ADDR +-> WORD);
  (dom(mem<+{w|->bitset(mem(w),p)}) = MEM_ADDR);
  (ran(mem<+{w|->bitset(mem(w),p)}) = WORD);
  (bitget(P) = par((mem<+{w|->bitset(mem(w),p)})(a)));
  ("`AJMP preconditions in this component'" & jump : INSTRUCTION);
  ("`ADDS preconditions in this component'" & acc : SFR_ADDR & acc = a & src : MEM_ADDR);
  ("`Local hypotheses'" & result : WORD & result,carry,zero = add(mem(a),mem(src)) & carry : BOOL & zero : BOOL);
  ("`ADDD preconditions in this component'" & acc : SFR_ADDR & acc = a & data : WORD);
  ("`Local hypotheses'" & result : WORD & result,carry,zero = add(mem(a),data) & carry : BOOL & zero : BOOL);
  ("`SUBBS preconditions in this component'" & acc : SFR_ADDR & acc = a & src : MEM_ADDR);
  ("`Local hypotheses'" & result : WORD & result,carry,zero = substract(mem(a),mem(src)) & carry : BOOL & zero : BOOL);
  ("`SUBBD preconditions in this component'" & acc : SFR_ADDR & acc = a & data : WORD);
  ("`Local hypotheses'" & result : WORD & result,carry,zero = substract(mem(a),data) & carry : BOOL & zero : BOOL);
  ("`Local hypotheses'" & result : WORD & result,carry,zero = add(mem(a),1) & carry : BOOL & zero : BOOL);
  ("`Local hypotheses'" & result : WORD & result,carry,zero = substract(a,1) & carry : BOOL & zero : BOOL);
  ("`INCS preconditions in this component'" & src : MEM_ADDR);
  ("`Local hypotheses'" & result : WORD & result,carry,zero = add(mem(src),1) & carry : BOOL & zero : BOOL);
  (mem<+{src|->result} : MEM_ADDR +-> WORD);
  (dom(mem<+{src|->result}) = MEM_ADDR);
  (ran(mem<+{src|->result}) = WORD);
  (bitget(P) = par((mem<+{src|->result})(a)))
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
