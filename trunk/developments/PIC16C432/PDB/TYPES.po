THEORY ProofList IS
  _f(1) & _f(2) & AssertionLemmas.5,(_f(14) & _f(15) => _f(16));
  _f(1) & _f(2) & AssertionLemmas.4,(_f(11) & _f(12) => _f(13));
  _f(1) & _f(2) & AssertionLemmas.3,(_f(8) & _f(9) => _f(10));
  _f(1) & _f(2) & AssertionLemmas.2,(_f(5) & _f(6) => _f(7));
  _f(1) & _f(2) & AssertionLemmas.1,(_f(3) => _f(4))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & BIT = 0..1 & bit_not: BIT +-> BIT & dom(bit_not) = BIT & !bb.(bb: BIT => bit_not(bb) = 1-bb) & bit_and: BIT*BIT +-> BIT & dom(bit_and) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_and(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_and(b1,b2) = 1) & b2 = 1) & bit_or: BIT*BIT +-> BIT & dom(bit_or) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_or(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_or(b1,b2) = 1) or b2 = 1) & bit_xor: BIT*BIT +-> BIT & dom(bit_xor) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_xor(b1,b2) = 1 => not(b1 = b2)) & (not(b1 = b2) => bit_xor(b1,b2) = 1)) & bool_to_bit: BOOL +-> BIT & dom(bool_to_bit) = BOOL & bool_to_bit = {TRUE|->1}\/{FALSE|->0} & BIT_VECTOR = seq(BIT)-{{}} & bv_size: BIT_VECTOR +-> NATURAL-{0} & dom(bv_size) = BIT_VECTOR & bv_size = %bv.(bv: BIT_VECTOR | size(bv)) & bv_zero: NATURAL-{0} +-> BIT_VECTOR & dom(bv_zero) = NATURAL-{0} & bv_zero = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (0..sz-1)*{0}) & bv_one: NATURAL-{0} +-> BIT_VECTOR & dom(bv_one) = NATURAL-{0} & bv_one = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (0..sz-1)*{1}) & bv_not: BIT_VECTOR +-> BIT_VECTOR & dom(bv_not) = BIT_VECTOR & bv_not = %v1.(v1: BIT_VECTOR | %idx.(idx: 0..size(v1)-1 | bit_not(v1(idx)))) & bv_and: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_and) = BIT_VECTOR*BIT_VECTOR & bv_and = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 0..size(v1)-1 | bit_and(v1(idx),v2(idx)))) & bv_or: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_or) = BIT_VECTOR*BIT_VECTOR & bv_or = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 0..size(v1)-1 | bit_or(v1(idx),v2(idx)))) & bv_xor: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_xor) = BIT_VECTOR*BIT_VECTOR & bv_xor = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 0..size(v1)-1 | bit_xor(v1(idx),v2(idx)))) & bv_set: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_set) = BIT_VECTOR*NATURAL & bv_set = %(v1,idx).(v1: BIT_VECTOR & (idx: INTEGER & 0<=idx) & idx+1<=size(v1) | v1<+{idx|->1}) & bv_clear: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_clear) = BIT_VECTOR*NATURAL & bv_clear = %(v1,idx).(v1: BIT_VECTOR & (idx: INTEGER & 0<=idx) & idx+1<=size(v1) | v1<+{idx|->0}) & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & BYTE_WIDTH = 8 & BYTE_INDEX = 0..BYTE_WIDTH-1 & BYTE: POW(BIT_VECTOR) & BYTE = SET(vv).(vv: BIT_VECTOR & bv_size(vv) = BYTE_WIDTH) & BYTE_ZERO: BYTE & BYTE_ZERO = BYTE_INDEX*{0} & "`Component properties'" & UCHAR_LENGTH: INTEGER & 0<=UCHAR_LENGTH & NB_UCHARS: INTEGER & 0<=NB_UCHARS & INST_SZ: INTEGER & 0<=INST_SZ & NB_INSTRUCTIONS: INTEGER & 0<=NB_INSTRUCTIONS & UCHAR_LENGTH = 8 & NB_UCHARS = 2**UCHAR_LENGTH & UCHAR = 0..NB_UCHARS-1 & NB_INSTRUCTIONS = 2**INST_SZ & INSTRUCTION_MAX = NB_INSTRUCTIONS-1 & INSTRUCTION = 0..INSTRUCTION_MAX & instruction_next: INSTRUCTION +-> INSTRUCTION & dom(instruction_next) = INSTRUCTION & instruction_next = SET(pp,qq).(pp: INSTRUCTION & qq: INSTRUCTION & 0<=pp & pp+1<=NB_INSTRUCTIONS-1 & qq = pp+1)\/{NB_INSTRUCTIONS-1|->0} & byte_to_uchar: BYTE +-> UCHAR & dom(byte_to_uchar) = BYTE & byte_to_uchar = %vv.(vv: BYTE | bv_to_nat(vv)) & uchar_to_byte: UCHAR +-> BYTE & dom(uchar_to_byte) = UCHAR & uchar_to_byte = byte_to_uchar~ & REGISTER = 0..255 & REGISTER0 = 0..127 & REGISTER1 = 128..255);
  ("`Seen and used machines assertions'" & bool_to_bit(FALSE) = 0 & bool_to_bit(TRUE) = 1 & !bb.(bb: BIT => bit_xor(bb,bb) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(bit_xor(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_xor(b1,b2) = bit_xor(b2,b1)) & bit_xor(1,1) = 0 & bit_xor(1,0) = 1 & bit_xor(0,1) = 1 & bit_xor(0,0) = 0 & !b1.(b1: BIT => bit_or(b1,0) = b1) & !b1.(b1: BIT => bit_or(b1,1) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_or(b1,bit_or(b2,b3)) = bit_or(bit_or(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_or(b1,b2) = bit_or(b2,b1)) & bit_or(1,1) = 1 & bit_or(1,0) = 0 & bit_or(0,1) = 0 & bit_or(0,0) = 0 & !b1.(b1: BIT => bit_and(b1,0) = 0) & !b1.(b1: BIT => bit_and(b1,1) = b1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_and(b1,bit_and(b2,b3)) = bit_and(bit_and(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_and(b1,b2) = bit_and(b2,b1)) & bit_and(1,1) = 1 & bit_and(1,0) = 0 & bit_and(0,1) = 0 & bit_and(0,0) = 0 & !bb.(bb: BIT => bit_not(bit_not(bb)) = bb) & bit_not(1) = 0 & bit_not(0) = 1 & !bv.(bv: BIT_VECTOR => bv_xor(bv,bv) = bv_zero(bv_size(bv))) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_xor(v1,v2) = bv_xor(v2,v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v2)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v1)) & !bv.(bv: BIT_VECTOR => bv_or(bv,bv_zero(bv_size(bv))) = bv) & !bv.(bv: BIT_VECTOR => bv_or(bv,bv_one(bv_size(bv))) = bv_one(bv_size(bv))) & !(v1,v2,v3).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) => bv_or(v1,bv_or(v2,v3)) = bv_or(bv_or(v1,v2),v3)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_or(v1,v2) = bv_or(v2,v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v2)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v1)) & !bv.(bv: BIT_VECTOR => bv_and(bv,bv_one(bv_size(bv))) = bv) & !bv.(bv: BIT_VECTOR => bv_and(bv,bv_zero(bv_size(bv))) = bv_zero(bv_size(bv))) & !(v1,v2,v3).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) => bv_and(v1,bv_and(v2,v3)) = bv_and(bv_and(v1,v2),v3)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_and(v1,v2) = bv_and(v2,v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_and(v1,v2)) = bv_size(v2)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_and(v1,v2)) = bv_size(v1)) & !bv.(bv: BIT_VECTOR => bv_not(bv_not(bv)) = bv) & !bv.(bv: BIT_VECTOR => bv_size(bv_not(bv)) = bv_size(bv)) & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_to_nat(bv_zero(ss)) = 0) & 2**16 = 65536 & 2**15 = 32768 & 2**14 = 16384 & 2**13 = 8192 & 2**12 = 4096 & 2**11 = 2048 & 2**10 = 1024 & 2**9 = 512 & 2**8 = 256 & 2**7 = 128 & 2**6 = 64 & 2**5 = 32 & 2**4 = 16 & 2**3 = 8 & 2**2 = 4 & 2**1 = 2 & 2**0 = 1);
  "`Check assertion (NB_UCHARS = 256) deduction - ref 3.2, 4.2, 5.3'";
  (NB_UCHARS = 256);
  ("`Local hypotheses'" & NB_UCHARS = 256 & nn: UCHAR);
  "`Check assertion (!nn.(nn: UCHAR => 0<=nn)) deduction - ref 3.2, 4.2, 5.3'";
  (0<=nn);
  ("`Local hypotheses'" & NB_UCHARS = 256 & !nn.(nn: UCHAR => 0<=nn) & nn: UCHAR);
  "`Check assertion (!nn.(nn: UCHAR => nn<=255)) deduction - ref 3.2, 4.2, 5.3'";
  (nn<=255);
  ("`Local hypotheses'" & NB_UCHARS = 256 & !nn.(nn: UCHAR => 0<=nn) & !nn.(nn: UCHAR => nn<=255));
  "`Check assertion (REGISTER = UCHAR) deduction - ref 3.2, 4.2, 5.3'";
  (REGISTER = UCHAR);
  ("`Local hypotheses'" & NB_UCHARS = 256 & !nn.(nn: UCHAR => 0<=nn) & !nn.(nn: UCHAR => nn<=255) & REGISTER = UCHAR);
  "`Check assertion (ran(byte_to_uchar) = UCHAR) deduction - ref 3.2, 4.2, 5.3'";
  (ran(byte_to_uchar) = UCHAR);
  ("`Component assertions'" & NB_UCHARS = 256 & !nn.(nn: UCHAR => 0<=nn) & !nn.(nn: UCHAR => nn<=255) & REGISTER = UCHAR & ran(byte_to_uchar) = UCHAR)
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
