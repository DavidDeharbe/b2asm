THEORY ProofList IS
  _f(1) & _f(2) & AssertionLemmas.15,(_f(45) & _f(46) => _f(47));
  _f(1) & _f(2) & AssertionLemmas.14,(_f(42) & _f(43) => _f(44));
  _f(1) & _f(2) & AssertionLemmas.13,(_f(39) & _f(40) => _f(41));
  _f(1) & _f(2) & AssertionLemmas.12,(_f(36) & _f(37) => _f(38));
  _f(1) & _f(2) & AssertionLemmas.11,(_f(33) & _f(34) => _f(35));
  _f(1) & _f(2) & AssertionLemmas.10,(_f(30) & _f(31) => _f(32));
  _f(1) & _f(2) & AssertionLemmas.9,(_f(27) & _f(28) => _f(29));
  _f(1) & _f(2) & AssertionLemmas.8,(_f(24) & _f(25) => _f(26));
  _f(1) & _f(2) & AssertionLemmas.7,(_f(21) & _f(22) => _f(23));
  _f(1) & _f(2) & AssertionLemmas.6,(_f(18) & _f(19) => _f(20));
  _f(1) & _f(2) & AssertionLemmas.5,(_f(15) & _f(16) => _f(17));
  _f(1) & _f(2) & AssertionLemmas.4,(_f(12) & _f(13) => _f(14));
  _f(1) & _f(2) & AssertionLemmas.3,(_f(9) & _f(10) => _f(11));
  _f(1) & _f(2) & AssertionLemmas.2,(_f(6) & _f(7) => _f(8));
  _f(1) & _f(2) & AssertionLemmas.1,(_f(3) & _f(4) => _f(5))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & UCHAR_LENGTH: INTEGER & 0<=UCHAR_LENGTH & NB_UCHARS: INTEGER & 0<=NB_UCHARS & INST_SZ: INTEGER & 0<=INST_SZ & NB_INSTRUCTIONS: INTEGER & 0<=NB_INSTRUCTIONS & UCHAR_LENGTH = 8 & NB_UCHARS = 2**UCHAR_LENGTH & UCHAR = 0..NB_UCHARS-1 & NB_INSTRUCTIONS = 2**INST_SZ & INSTRUCTION_MAX = NB_INSTRUCTIONS-1 & INSTRUCTION = 0..INSTRUCTION_MAX & instruction_next: INSTRUCTION +-> INSTRUCTION & dom(instruction_next) = INSTRUCTION & instruction_next = SET(pp,qq).(pp: INSTRUCTION & qq: INSTRUCTION & 0<=pp & pp+1<=NB_INSTRUCTIONS-1 & qq = pp+1)\/{NB_INSTRUCTIONS-1|->0} & byte_to_uchar: BYTE +-> UCHAR & dom(byte_to_uchar) = BYTE & byte_to_uchar = %vv.(vv: BYTE | bv_to_nat(vv)) & uchar_to_byte: UCHAR +-> BYTE & dom(uchar_to_byte) = UCHAR & uchar_to_byte = byte_to_uchar~ & REGISTER = 0..255 & REGISTER0 = 0..127 & REGISTER1 = 128..255 & BIT = 0..1 & bit_not: BIT +-> BIT & dom(bit_not) = BIT & !bb.(bb: BIT => bit_not(bb) = 1-bb) & bit_and: BIT*BIT +-> BIT & dom(bit_and) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_and(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_and(b1,b2) = 1) & b2 = 1) & bit_or: BIT*BIT +-> BIT & dom(bit_or) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_or(b1,b2) = 1 => b1 = 1) & (b1 = 1 => bit_or(b1,b2) = 1) or b2 = 1) & bit_xor: BIT*BIT +-> BIT & dom(bit_xor) = BIT*BIT & !(b1,b2).(b1: BIT & b2: BIT => (bit_xor(b1,b2) = 1 => not(b1 = b2)) & (not(b1 = b2) => bit_xor(b1,b2) = 1)) & bool_to_bit: BOOL +-> BIT & dom(bool_to_bit) = BOOL & bool_to_bit = {TRUE|->1}\/{FALSE|->0} & BIT_VECTOR = seq(BIT)-{{}} & bv_size: BIT_VECTOR +-> NATURAL-{0} & dom(bv_size) = BIT_VECTOR & bv_size = %bv.(bv: BIT_VECTOR | size(bv)) & bv_catenate: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_catenate) = BIT_VECTOR*BIT_VECTOR & bv_catenate = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR | v2^v1) & bv_sub: BIT_VECTOR*NATURAL*NATURAL +-> BIT_VECTOR & dom(bv_sub) = BIT_VECTOR*NATURAL*NATURAL & bv_sub = %(bv,low,high).(bv: BIT_VECTOR & (low: INTEGER & 0<=low) & (high: INTEGER & 0<=high) & low<=high | 0..high-low<|bv) & bv_zero: NATURAL-{0} +-> BIT_VECTOR & dom(bv_zero) = NATURAL-{0} & bv_zero = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (1..sz)*{0}) & bv_one: NATURAL-{0} +-> BIT_VECTOR & dom(bv_one) = NATURAL-{0} & bv_one = %sz.(sz: INTEGER & 0<=sz & not(sz = 0) | (1..sz)*{1}) & bv_not: BIT_VECTOR +-> BIT_VECTOR & dom(bv_not) = BIT_VECTOR & bv_not = %v1.(v1: BIT_VECTOR | %idx.(idx: 1..size(v1) | bit_not(v1(idx)))) & bv_and: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_and) = BIT_VECTOR*BIT_VECTOR & bv_and = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 1..size(v1) | bit_and(v1(idx),v2(idx)))) & bv_or: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_or) = BIT_VECTOR*BIT_VECTOR & bv_or = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 1..size(v1) | bit_or(v1(idx),v2(idx)))) & bv_xor: BIT_VECTOR*BIT_VECTOR +-> BIT_VECTOR & dom(bv_xor) = BIT_VECTOR*BIT_VECTOR & bv_xor = %(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & size(v1) = size(v2) | %idx.(idx: 1..size(v1) | bit_xor(v1(idx),v2(idx)))) & bv_at: BIT_VECTOR*NATURAL +-> BIT & dom(bv_at) = BIT_VECTOR*NATURAL & bv_at = %(v1,idx).(v1: BIT_VECTOR & (idx: INTEGER & 0<=idx) & idx+1<=size(v1) | v1(idx+1)) & bv_set: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_set) = BIT_VECTOR*NATURAL & bv_set = %(v1,idx).(v1: BIT_VECTOR & (idx: INTEGER & 0<=idx) & idx+1<=size(v1) | v1<+{idx+1|->1}) & bv_clear: BIT_VECTOR*NATURAL +-> BIT_VECTOR & dom(bv_clear) = BIT_VECTOR*NATURAL & bv_clear = %(v1,idx).(v1: BIT_VECTOR & (idx: INTEGER & 0<=idx) & idx+1<=size(v1) | v1<+{idx+1|->0}) & bv_to_nat: BIT_VECTOR +-> NATURAL & dom(bv_to_nat) = BIT_VECTOR & bv_to_nat = %bv.(bv: BIT_VECTOR | SIGMA(idx).(idx: dom(bv) | 2**idx*bv(idx))) & BYTE_WIDTH = 8 & BYTE_INDEX = 0..BYTE_WIDTH-1 & BYTE: POW(BIT_VECTOR) & BYTE = SET(vv).(vv: BIT_VECTOR & bv_size(vv) = BYTE_WIDTH) & BYTE_ZERO: BYTE & BYTE_ZERO = BYTE_INDEX*{0} & "`Component properties'" & half: UCHAR +-> UCHAR & dom(half) = UCHAR & half = %ww.(ww: UCHAR | ww mod 2**4) & add: UCHAR*UCHAR +-> UCHAR*BOOL*BOOL*BOOL & dom(add) = UCHAR*UCHAR & add = %(w1,w2).(w1: UCHAR & w2: UCHAR | (w1+w2) mod 2**8,bool(2**8<=w1+w2),bool(2**4<=half(w1)+half(w2)),bool(w1+w2: {0}\/{256})) & substract: UCHAR*UCHAR +-> UCHAR*BOOL*BOOL*BOOL & dom(substract) = UCHAR*UCHAR & substract = %(w1,w2).(w1: UCHAR & w2: UCHAR & w2<=w1 | w1-w2,TRUE,bool(half(w2)<=half(w1)),bool(w1 = w2))\/%(w1,w2).(w1: UCHAR & w2: UCHAR & w1+1<=w2 | 2**8+w1-w2,FALSE,bool(half(w2)<=half(w1)),FALSE) & and: BYTE*BYTE +-> BYTE*BOOL & dom(and) = BYTE*BYTE & !(w1,w2).(w1: BYTE & w2: BYTE & bv_and(w1,w2): BYTE => and(w1,w2) = bv_and(w1,w2)|->bool(bv_to_nat(bv_and(w1,w2)) = 0)) & ior: BYTE*BYTE +-> BYTE*BOOL & dom(ior) = BYTE*BYTE & !(w1,w2).(w1: BYTE & w2: BYTE & bv_or(w1,w2): BYTE => ior(w1,w2) = bv_or(w1,w2)|->bool(bv_to_nat(bv_or(w1,w2)) = 0)) & xor: BYTE*BYTE +-> BYTE*BOOL & dom(xor) = BYTE*BYTE & !(w1,w2).(w1: BYTE & w2: BYTE & bv_xor(w1,w2): BYTE => xor(w1,w2) = bv_xor(w1,w2)|->bool(bv_to_nat(bv_xor(w1,w2)) = 0)) & bitget: BYTE*BYTE_INDEX +-> BIT & dom(bitget) = BYTE*BYTE_INDEX & !(ww,ii).(ww: BYTE & ii: BYTE_INDEX => bitget(ww,ii) = ww(ii)) & bitset: BYTE*BYTE_INDEX +-> BYTE & dom(bitset) = BYTE*BYTE_INDEX & !(ww,ii).(ww: BYTE & ii: BYTE_INDEX => bitset(ww,ii) = bv_set(ww,ii)) & bitclear: BYTE*BYTE_INDEX +-> BYTE & dom(bitclear) = BYTE*BYTE_INDEX & !(ww,ii,bb).(ww: BYTE & ii: BYTE_INDEX & bb: BIT => bitclear(ww,ii) = bv_clear(ww,ii)) & complement: BYTE +-> BYTE & dom(complement) = BYTE & !ww.(ww: BYTE => complement(ww) = bv_not(ww)) & swap: BYTE +-> BYTE & dom(swap) = BYTE & !ww.(ww: BYTE => swap(ww) = {0|->ww(4)}\/{1|->ww(5)}\/{2|->ww(6)}\/{3|->ww(7)}\/{4|->ww(0)}\/{5|->ww(1)}\/{6|->ww(2)}\/{7|->ww(3)}) & rotateleft: BYTE +-> BYTE*BOOL & dom(rotateleft) = BYTE & !ww.(ww: BYTE => rotateleft(ww) = {0|->ww(7)}\/{1|->ww(0)}\/{2|->ww(1)}\/{3|->ww(2)}\/{4|->ww(3)}\/{5|->ww(4)}\/{6|->ww(5)}\/{7|->ww(6)}|->bool(ww(7) = 1)) & rotateright: BYTE +-> BYTE*BOOL & dom(rotateright) = BYTE & !ww.(ww: BYTE => rotateright(ww) = {0|->ww(1)}\/{1|->ww(2)}\/{2|->ww(3)}\/{3|->ww(4)}\/{4|->ww(5)}\/{5|->ww(6)}\/{6|->ww(7)}\/{7|->ww(0)}|->bool(ww(0) = 1)));
  ("`Seen and used machines assertions'" & ran(byte_to_uchar) = UCHAR & REGISTER = UCHAR & !nn.(nn: UCHAR => nn<=255) & !nn.(nn: UCHAR => 0<=nn) & NB_UCHARS = 256 & bool_to_bit(FALSE) = 0 & bool_to_bit(TRUE) = 1 & !bb.(bb: BIT => bit_xor(bb,bb) = 0) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_xor(b1,bit_xor(b2,b3)) = bit_xor(bit_xor(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_xor(b1,b2) = bit_xor(b2,b1)) & bit_xor(1,1) = 0 & bit_xor(1,0) = 1 & bit_xor(0,1) = 1 & bit_xor(0,0) = 0 & !b1.(b1: BIT => bit_or(b1,0) = b1) & !b1.(b1: BIT => bit_or(b1,1) = 1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_or(b1,bit_or(b2,b3)) = bit_or(bit_or(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_or(b1,b2) = bit_or(b2,b1)) & bit_or(1,1) = 1 & bit_or(1,0) = 0 & bit_or(0,1) = 0 & bit_or(0,0) = 0 & !b1.(b1: BIT => bit_and(b1,0) = 0) & !b1.(b1: BIT => bit_and(b1,1) = b1) & !(b1,b2,b3).(b1: BIT & b2: BIT & b3: BIT => bit_and(b1,bit_and(b2,b3)) = bit_and(bit_and(b1,b2),b3)) & !(b1,b2).(b1: BIT & b2: BIT => bit_and(b1,b2) = bit_and(b2,b1)) & bit_and(1,1) = 1 & bit_and(1,0) = 0 & bit_and(0,1) = 0 & bit_and(0,0) = 0 & !bb.(bb: BIT => bit_not(bit_not(bb)) = bb) & bit_not(1) = 0 & bit_not(0) = 1 & !bv.(bv: BIT_VECTOR => bv_xor(bv,bv) = bv_zero(bv_size(bv))) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_xor(v1,v2) = bv_xor(v2,v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v2)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_xor(v1,v2)) = bv_size(v1)) & !bv.(bv: BIT_VECTOR => bv_or(bv,bv_zero(bv_size(bv))) = bv) & !bv.(bv: BIT_VECTOR => bv_or(bv,bv_one(bv_size(bv))) = bv_one(bv_size(bv))) & !(v1,v2,v3).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) => bv_or(v1,bv_or(v2,v3)) = bv_or(bv_or(v1,v2),v3)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_or(v1,v2) = bv_or(v2,v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v2)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_or(v1,v2)) = bv_size(v1)) & !bv.(bv: BIT_VECTOR => bv_and(bv,bv_one(bv_size(bv))) = bv) & !bv.(bv: BIT_VECTOR => bv_and(bv,bv_zero(bv_size(bv))) = bv_zero(bv_size(bv))) & !(v1,v2,v3).(v1: BIT_VECTOR & v2: BIT_VECTOR & v3: BIT_VECTOR & bv_size(v1) = bv_size(v2) & bv_size(v1) = bv_size(v3) => bv_and(v1,bv_and(v2,v3)) = bv_and(bv_and(v1,v2),v3)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_and(v1,v2) = bv_and(v2,v1)) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR & bv_size(v1) = bv_size(v2) => bv_size(bv_and(v1,v2)) = bv_size(v2)) & !(bv,low,high).(bv: BIT_VECTOR & (low: INTEGER & 0<=low) & (high: INTEGER & 0<=high) & low<=high => bv_size(bv_sub(bv,low,high)) = 1+high-low) & !(v1,v2).(v1: BIT_VECTOR & v2: BIT_VECTOR => bv_size(bv_catenate(v1,v2)) = bv_size(v1)+bv_size(v2)) & !bv.(bv: BIT_VECTOR => bv_not(bv_not(bv)) = bv) & !bv.(bv: BIT_VECTOR => bv_size(bv_not(bv)) = bv_size(bv)) & !ss.(ss: INTEGER & 0<=ss & not(ss = 0) => bv_to_nat(bv_zero(ss)) = 0));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR);
  "`Check assertion (ran(add) <: UCHAR*BOOL*BOOL*BOOL) deduction - ref 3.2, 4.2, 5.3'";
  (ran(add): POW(UCHAR*BOOL*BOOL*BOOL));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR);
  "`Check assertion (ran(substract) <: UCHAR*BOOL*BOOL*BOOL) deduction - ref 3.2, 4.2, 5.3'";
  (ran(substract): POW(UCHAR*BOOL*BOOL*BOOL));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE);
  "`Check assertion (ran(and) <: BYTE*BOOL) deduction - ref 3.2, 4.2, 5.3'";
  (ran(and): POW(BYTE*BOOL));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE);
  "`Check assertion (ran(ior) <: BYTE*BOOL) deduction - ref 3.2, 4.2, 5.3'";
  (ran(ior): POW(BYTE*BOOL));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE);
  "`Check assertion (ran(xor) <: BYTE*BOOL) deduction - ref 3.2, 4.2, 5.3'";
  (ran(xor): POW(BYTE*BOOL));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX);
  "`Check assertion (ran(bitclear) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(bitclear): POW(BYTE));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX);
  "`Check assertion (ran(bitset) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(bitset): POW(BYTE));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX);
  "`Check assertion (ran(bitget) <: BIT) deduction - ref 3.2, 4.2, 5.3'";
  (ran(bitget): POW(BIT));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE);
  "`Check assertion (ran(complement) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(complement): POW(BYTE));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE);
  "`Check assertion (ran(swap) <: BYTE) deduction - ref 3.2, 4.2, 5.3'";
  (ran(swap): POW(BYTE));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE));
  "`Check assertion (ran(rotateleft) <: BYTE*BOOL) deduction - ref 3.2, 4.2, 5.3'";
  (ran(rotateleft): POW(BYTE*BOOL));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & ran(rotateleft): POW(BYTE*BOOL) & dom(rotateleft) = BYTE & dom(rotateright) = BYTE);
  "`Check assertion (ran(rotateright) <: BYTE*BOOL) deduction - ref 3.2, 4.2, 5.3'";
  (ran(rotateright): POW(BYTE*BOOL));
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & ran(rotateleft): POW(BYTE*BOOL) & dom(rotateleft) = BYTE & dom(rotateright) = BYTE & ran(rotateright): POW(BYTE*BOOL));
  "`Check assertion (add(0,0) = 0,TRUE,FALSE,FALSE) deduction - ref 3.2, 4.2, 5.3'";
  (add(0,0) = (0,TRUE,FALSE)|->FALSE);
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & ran(rotateleft): POW(BYTE*BOOL) & dom(rotateleft) = BYTE & dom(rotateright) = BYTE & ran(rotateright): POW(BYTE*BOOL) & add(0,0) = (0,TRUE,FALSE)|->FALSE);
  "`Check assertion (add(255,1) = 0,TRUE,FALSE,TRUE) deduction - ref 3.2, 4.2, 5.3'";
  (add(255,1) = (0,TRUE,FALSE)|->TRUE);
  ("`Local hypotheses'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & ran(rotateleft): POW(BYTE*BOOL) & dom(rotateleft) = BYTE & dom(rotateright) = BYTE & ran(rotateright): POW(BYTE*BOOL) & add(0,0) = (0,TRUE,FALSE)|->FALSE & add(255,1) = (0,TRUE,FALSE)|->TRUE);
  "`Check assertion (add(255,1) = 0,TRUE,TRUE,TRUE) deduction - ref 3.2, 4.2, 5.3'";
  (add(255,1) = (0,TRUE,TRUE)|->TRUE);
  ("`Component assertions'" & dom(add) = UCHAR*UCHAR & ran(add): POW(UCHAR*BOOL*BOOL*BOOL) & dom(substract) = UCHAR*UCHAR & ran(substract): POW(UCHAR*BOOL*BOOL*BOOL) & dom(and) = BYTE*BYTE & ran(and): POW(BYTE*BOOL) & dom(ior) = BYTE*BYTE & ran(ior): POW(BYTE*BOOL) & dom(xor) = BYTE*BYTE & ran(xor): POW(BYTE*BOOL) & dom(bitclear) = BYTE*BYTE_INDEX & ran(bitclear): POW(BYTE) & dom(bitset) = BYTE*BYTE_INDEX & ran(bitset): POW(BYTE) & dom(bitget) = BYTE*BYTE_INDEX & ran(bitget): POW(BIT) & dom(complement) = BYTE & ran(complement): POW(BYTE) & dom(swap) = BYTE & ran(swap): POW(BYTE) & ran(rotateleft): POW(BYTE*BOOL) & dom(rotateleft) = BYTE & dom(rotateright) = BYTE & ran(rotateright): POW(BYTE*BOOL) & add(0,0) = (0,TRUE,FALSE)|->FALSE & add(255,1) = (0,TRUE,FALSE)|->TRUE & add(255,1) = (0,TRUE,TRUE)|->TRUE)
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
