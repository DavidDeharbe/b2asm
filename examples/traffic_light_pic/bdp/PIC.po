THEORY ProofList IS
  _f(1) & _f(2) & _f(8) & _f(11) & _f(110) & SWAP.5,(_f(112) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(110) & SWAP.4,(_f(112) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(110) & SWAP.3,(_f(112) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(110) & SWAP.2,(_f(111) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(110) & SWAP.1,(_f(111) & _f(73) => _f(77));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(107) & RORF.4,(_f(109) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(107) & RORF.3,(_f(109) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(107) & RORF.2,(_f(109) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(107) & RORF.1,(_f(108) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(104) & ROLF.4,(_f(106) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(104) & ROLF.3,(_f(106) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(104) & ROLF.2,(_f(106) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(104) & ROLF.1,(_f(105) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & NOP.1,(_f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(101) & MOVWF.3,(_f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(101) & MOVWF.2,(_f(34) => _f(103));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(101) & MOVWF.1,(_f(34) => _f(102));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(97) & MOVF.3,(_f(100) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(97) & MOVF.2,(_f(98) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(97) & MOVF.1,(_f(98) & _f(73) => _f(99));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(96) & MOVLW.1,(_f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.8,(_f(95) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.7,(_f(95) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.6,(_f(95) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.5,(_f(94) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.4,(_f(93) & _f(21) => _f(65));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.3,(_f(93) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.2,(_f(93) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(91) & INCFSZ.1,(_f(92) & _f(21) => _f(65));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(88) & INCF.4,(_f(90) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(88) & INCF.3,(_f(90) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(88) & INCF.2,(_f(90) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(88) & INCF.1,(_f(89) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.8,(_f(86) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.7,(_f(86) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.6,(_f(86) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.5,(_f(85) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.4,(_f(84) & _f(21) => _f(65));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.3,(_f(84) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.2,(_f(84) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(82) & DECFSZ.1,(_f(83) & _f(21) => _f(65));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(79) & DECF.4,(_f(81) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(79) & DECF.3,(_f(81) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(79) & DECF.2,(_f(81) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(79) & DECF.1,(_f(80) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(75) & COMF.5,(_f(78) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(75) & COMF.4,(_f(78) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(75) & COMF.3,(_f(78) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(75) & COMF.2,(_f(76) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(75) & COMF.1,(_f(76) & _f(73) => _f(77));
  _f(1) & _f(2) & _f(8) & _f(11) & CLRW.2,(_f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & CLRW.1,(_f(73) => _f(74));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(70) & CLRF.3,(_f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(70) & CLRF.2,(_f(34) => _f(72));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(70) & CLRF.1,(_f(34) => _f(71));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(67) & BTFSS.2,(_f(69) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(67) & BTFSS.1,(_f(68) & _f(21) => _f(65));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(63) & BTFSC.2,(_f(66) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(63) & BTFSC.1,(_f(64) & _f(21) => _f(65));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(60) & BSF.3,(_f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(60) & BSF.2,(_f(34) => _f(62));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(60) & BSF.1,(_f(34) => _f(61));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(57) & BCF.3,(_f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(57) & BCF.2,(_f(34) => _f(59));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(57) & BCF.1,(_f(34) => _f(58));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(54) & XORLWF.4,(_f(56) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(54) & XORLWF.3,(_f(56) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(54) & XORLWF.2,(_f(56) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(54) & XORLWF.1,(_f(55) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(52) & XORLW.1,(_f(53) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(49) & IORLWF.4,(_f(51) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(49) & IORLWF.3,(_f(51) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(49) & IORLWF.2,(_f(51) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(49) & IORLWF.1,(_f(50) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(47) & IORLW.1,(_f(48) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(44) & ANDLWF.4,(_f(46) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(44) & ANDLWF.3,(_f(46) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(44) & ANDLWF.2,(_f(46) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(44) & ANDLWF.1,(_f(45) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(42) & ANDLW.1,(_f(43) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(39) & SUBWF.4,(_f(41) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(39) & SUBWF.3,(_f(41) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(39) & SUBWF.2,(_f(41) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(39) & SUBWF.1,(_f(40) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(37) & SUBLW.1,(_f(38) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(31) & ADDWF.4,(_f(33) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(31) & ADDWF.3,(_f(33) & _f(34) => _f(36));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(31) & ADDWF.2,(_f(33) & _f(34) => _f(35));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(31) & ADDWF.1,(_f(32) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(28) & ADDLW.1,(_f(29) & _f(21) => _f(30));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(27) & RETLW.1,(_f(21) => _f(22));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(20) & RETURN.5,(_f(18) => _f(26));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(20) & RETURN.4,(_f(16) => _f(25));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(20) & RETURN.3,(_f(13) => _f(24));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(20) & RETURN.2,(_f(13) => _f(23));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(20) & RETURN.1,(_f(21) => _f(22));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(12) & CALL.4,(_f(18) => _f(19));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(12) & CALL.3,(_f(16) => _f(17));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(12) & CALL.2,(_f(13) => _f(15));
  _f(1) & _f(2) & _f(8) & _f(11) & _f(12) & CALL.1,(_f(13) => _f(14));
  _f(1) & _f(2) & _f(8) & AssertionLemmas.1,(_f(9) => _f(10));
  _f(1) & _f(2) & Initialisation.2,(_f(3) & _f(6) => _f(7));
  _f(1) & _f(2) & Initialisation.1,(_f(3) & _f(4) => _f(5))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & WORD_LENGTH : INTEGER & 0<=WORD_LENGTH & INST_SZ : INTEGER & 0<=INST_SZ & NB_WORDS : INTEGER & 0<=NB_WORDS & NB_INSTRUCTIONS : INTEGER & 0<=NB_INSTRUCTIONS & WORD_LENGTH = 8 & NB_WORDS = 2**WORD_LENGTH & WORD = 0..NB_WORDS-1 & WORD_POSITION = 0..WORD_LENGTH-1 & NB_INSTRUCTIONS = 2**INST_SZ & INSTRUCTION_MAX = NB_INSTRUCTIONS-1 & INSTRUCTION = 0..INSTRUCTION_MAX & INSTRUCTION_NEXT : INSTRUCTION +-> INSTRUCTION & dom(INSTRUCTION_NEXT) = INSTRUCTION & INSTRUCTION_NEXT = SET(p,q).(p : INSTRUCTION & q : INSTRUCTION & 0<=p & p+1<=NB_INSTRUCTIONS-1 & q = p+1)\/{NB_INSTRUCTIONS-1|->0} & BV_TO_WORD : BV8 +-> WORD & dom(BV_TO_WORD) = BV8 & WORD_TO_BV : WORD +-> BV8 & dom(WORD_TO_BV) = WORD & !(w,v).(w : WORD & v : BV8 => (v = WORD_TO_BV(w) => w = 128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0)) & (w = 128*v(7)+64*v(6)+32*v(5)+16*v(4)+8*v(3)+4*v(2)+2*v(1)+v(0) => v = WORD_TO_BV(w))) & BV_TO_WORD = WORD_TO_BV~ & !n.(n : INTEGER & 0<=n & 1<=n => 2**n = 2*2**(n-1)) & 2**0 = 1 & REGISTER : POW(INTEGER) & REGISTER = 0..127 & BIT = 0..1 & BIT_FLIP : BIT +-> BIT & dom(BIT_FLIP) = BIT & !b.(b : BIT => BIT_FLIP(b) = 1-b) & BIT_AND : BIT*BIT +-> BIT & dom(BIT_AND) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_AND(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_AND(b1,b2) = 1) & b2 = 1) & BIT_IOR : BIT*BIT +-> BIT & dom(BIT_IOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_IOR(b1,b2) = 1 => b1 = 1) & (b1 = 1 => BIT_IOR(b1,b2) = 1) or b2 = 1) & BIT_XOR : BIT*BIT +-> BIT & dom(BIT_XOR) = BIT*BIT & !(b1,b2).(b1 : BIT & b2 : BIT => (BIT_XOR(b1,b2) = 1 => b1 = 1 & b2 = 0 or (b1 = 0 & b2 = 1)) & ((b1 = 1 & b2 = 0 => BIT_XOR(b1,b2) = 1) & (b1 = 0 & b2 = 1 => BIT_XOR(b1,b2) = 1))) & BV8_INDEX = 0..7 & BV8 = BV8_INDEX --> BIT & BV8_SET_BIT : BV8*BV8_INDEX*BIT +-> BV8 & dom(BV8_SET_BIT) = BV8*BV8_INDEX*BIT & !(v,i,j,b).(v : BV8 & i : BV8_INDEX & j : BV8_INDEX & b : BIT & not(i = j) => BV8_SET_BIT(v,i,b)(j) = v(j)) & !(v,i,b).(v : BV8 & i : BV8_INDEX & b : BIT => BV8_SET_BIT(v,i,b)(i) = b) & BV8_COMPLEMENT : BV8 +-> BV8 & dom(BV8_COMPLEMENT) = BV8 & !(v,i).(v : BV8 & i : BV8_INDEX => BV8_COMPLEMENT(v)(i) = BIT_FLIP(v(i))) & BV8_ALL_ZEROES : BV8 & !i.(i : BV8_INDEX => BV8_ALL_ZEROES(i) = 0) & BV8_AND : BV8*BV8 +-> BV8 & dom(BV8_AND) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_AND(v1,v2)(i) = BIT_AND(v1(i),v2(i))) & BV8_IOR : BV8*BV8 +-> BV8 & dom(BV8_IOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_IOR(v1,v2)(i) = BIT_IOR(v1(i),v2(i))) & BV8_XOR : BV8*BV8 +-> BV8 & dom(BV8_XOR) = BV8*BV8 & !(v1,v2,i).(v1 : BV8 & v2 : BV8 & i : BV8_INDEX => BV8_XOR(v1,v2)(i) = BIT_XOR(v1(i),v2(i))) & add : WORD*WORD +-> WORD*BOOL*BOOL & dom(add) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & (w1+w2 : INTEGER & 0<=w1+w2) => (w1+w2<=255 => add(w1,w2) = (w1+w2,bool(w1+w2 = 0))|->FALSE) & (256<=w1+w2 => add(w1,w2) = (w1+w2-256,bool(w1+w2 = 256))|->TRUE)) & substract : WORD*WORD +-> WORD*BOOL*BOOL & dom(substract) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & w1-w2 : INTEGER => (w1-w2+1<=0 => substract(w1,w2) = (w1-w2+256,FALSE)|->TRUE) & (0<=w1-w2 => substract(w1,w2) = (w1-w2,bool(w1-w2 = 0))|->FALSE)) & and : WORD*WORD +-> WORD*BOOL & dom(and) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & BV_TO_WORD(BV8_AND(WORD_TO_BV(w1),WORD_TO_BV(w2))) : WORD => and(w1,w2) = BV_TO_WORD(BV8_AND(WORD_TO_BV(w1),WORD_TO_BV(w2)))|->bool(BV_TO_WORD(BV8_AND(WORD_TO_BV(w1),WORD_TO_BV(w2))) = 0)) & ior : WORD*WORD +-> WORD*BOOL & dom(ior) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & BV_TO_WORD(BV8_IOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) : WORD => ior(w1,w2) = BV_TO_WORD(BV8_IOR(WORD_TO_BV(w1),WORD_TO_BV(w2)))|->bool(BV_TO_WORD(BV8_IOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) = 0)) & xor : WORD*WORD +-> WORD*BOOL & dom(xor) = WORD*WORD & !(w1,w2).(w1 : WORD & w2 : WORD & BV_TO_WORD(BV8_XOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) : WORD => xor(w1,w2) = BV_TO_WORD(BV8_XOR(WORD_TO_BV(w1),WORD_TO_BV(w2)))|->bool(BV_TO_WORD(BV8_XOR(WORD_TO_BV(w1),WORD_TO_BV(w2))) = 0)) & bitget : WORD*WORD_POSITION +-> BIT & dom(bitget) = WORD*WORD_POSITION & !(w,i).(w : WORD & i : WORD_POSITION => bitget(w,i) = WORD_TO_BV(w)(i)) & bitset : WORD*WORD_POSITION +-> WORD & dom(bitset) = WORD*WORD_POSITION & !(w,i).(w : WORD & i : WORD_POSITION => bitset(w,i) = BV_TO_WORD(BV8_SET_BIT(WORD_TO_BV(w),i,1))) & bitclear : WORD*WORD_POSITION +-> WORD & dom(bitclear) = WORD*WORD_POSITION & !(w,i,b).(w : WORD & i : WORD_POSITION & b : BIT => bitclear(w,i) = BV_TO_WORD(BV8_SET_BIT(WORD_TO_BV(w),i,0))) & complement : WORD +-> WORD & dom(complement) = WORD & !w.(w : WORD => complement(w) = BV_TO_WORD(BV8_COMPLEMENT(WORD_TO_BV(w)))) & swap : WORD +-> WORD & dom(swap) = WORD & !w.(w : WORD & WORD_TO_BV(w) : BV8 => swap(w) = BV_TO_WORD({0|->WORD_TO_BV(w)(4)}\/{1|->WORD_TO_BV(w)(5)}\/{2|->WORD_TO_BV(w)(6)}\/{3|->WORD_TO_BV(w)(7)}\/{4|->WORD_TO_BV(w)(0)}\/{5|->WORD_TO_BV(w)(1)}\/{6|->WORD_TO_BV(w)(2)}\/{7|->WORD_TO_BV(w)(3)})) & rotateleft : WORD +-> WORD*BOOL & dom(rotateleft) = WORD & !w.(w : WORD & WORD_TO_BV(w) : BV8 => rotateleft(w) = BV_TO_WORD({0|->WORD_TO_BV(w)(7)}\/{1|->WORD_TO_BV(w)(0)}\/{2|->WORD_TO_BV(w)(1)}\/{3|->WORD_TO_BV(w)(2)}\/{4|->WORD_TO_BV(w)(3)}\/{5|->WORD_TO_BV(w)(4)}\/{6|->WORD_TO_BV(w)(5)}\/{7|->WORD_TO_BV(w)(6)})|->bool(WORD_TO_BV(w)(7) = 1)) & rotateright : WORD +-> WORD*BOOL & dom(rotateright) = WORD & !w.(w : WORD & WORD_TO_BV(w) : BV8 => rotateright(w) = BV_TO_WORD({0|->WORD_TO_BV(w)(1)}\/{1|->WORD_TO_BV(w)(2)}\/{2|->WORD_TO_BV(w)(3)}\/{3|->WORD_TO_BV(w)(4)}\/{4|->WORD_TO_BV(w)(5)}\/{5|->WORD_TO_BV(w)(6)}\/{6|->WORD_TO_BV(w)(7)}\/{7|->WORD_TO_BV(w)(0)})|->bool(WORD_TO_BV(w)(0) = 1)));
  ("`Seen and used machines assertions'" & 2**8 = 256 & NB_WORDS = 256 & !n.(n : WORD => 0<=n) & !n.(n : WORD => n<=255) & WORD_POSITION = BV8_INDEX & BIT_FLIP(0) = 1 & BIT_FLIP(1) = 0 & BIT_AND(0,0) = 0 & BIT_AND(0,1) = 0 & BIT_AND(1,0) = 0 & BIT_AND(1,1) = 1 & BIT_IOR(0,0) = 0 & BIT_IOR(0,1) = 0 & BIT_IOR(1,0) = 0 & BIT_IOR(1,1) = 1 & BIT_XOR(0,0) = 0 & BIT_XOR(0,1) = 1 & BIT_XOR(1,0) = 1 & BIT_XOR(1,1) = 0 & dom(add) = WORD*WORD & ran(add) : POW(WORD*BOOL*BOOL) & dom(substract) = WORD*WORD & ran(substract) : POW(WORD*BOOL*BOOL) & dom(and) = WORD*WORD & ran(and) : POW(WORD*BOOL) & dom(ior) = WORD*WORD & ran(ior) : POW(WORD*BOOL) & dom(xor) = WORD*WORD & ran(xor) : POW(WORD*BOOL) & dom(bitclear) = WORD*WORD_POSITION & ran(bitclear) : POW(WORD) & dom(bitset) = WORD*WORD_POSITION & ran(bitset) : POW(WORD) & dom(bitget) = WORD*WORD_POSITION & ran(bitget) : POW(BIT) & dom(complement) = WORD & ran(complement) : POW(WORD) & dom(swap) = WORD & ran(swap) : POW(WORD) & ran(rotateleft) : POW(WORD*BOOL) & dom(rotateleft) = WORD & dom(rotateright) = WORD & ran(rotateright) : POW(WORD*BOOL));
  ("`Local hypotheses'" & pc$0 : INSTRUCTION & c$0 : BOOL & z$0 : BOOL & mem$0 : REGISTER +-> WORD & dom(mem$0) = REGISTER & w$0 : WORD);
  "`Check that the invariant (stack : NATURAL +-> INSTRUCTION) is established by the initialisation - ref 3.3'";
  ({} : NATURAL +-> INSTRUCTION);
  "`Check that the invariant (dom(stack) = 0..sp-1) is established by the initialisation - ref 3.3'";
  (dom({}) = 0.. -1);
  ("`Component invariant'" & mem : REGISTER +-> WORD & dom(mem) = REGISTER & w : WORD & z : BOOL & c : BOOL & pc : INSTRUCTION & sp : INTEGER & 0<=sp & stack : NATURAL +-> INSTRUCTION & dom(stack) = 0..sp-1);
  "`Check assertion (ran(mem) <: WORD) deduction - ref 3.2, 4.2, 5.3'";
  (ran(mem) : POW(WORD));
  ("`Component assertions'" & ran(mem) : POW(WORD) & dom(mem) = REGISTER);
  ("`CALL preconditions in this component'" & k : INSTRUCTION);
  "`Check that the invariant (sp : NATURAL) is preserved by the operation - ref 3.4'";
  (sp+1 : INTEGER);
  (0<=sp+1);
  "`Check that the invariant (stack : NATURAL +-> INSTRUCTION) is preserved by the operation - ref 3.4'";
  (stack<+{sp|->INSTRUCTION_NEXT(pc)} : NATURAL +-> INSTRUCTION);
  "`Check that the invariant (dom(stack) = 0..sp-1) is preserved by the operation - ref 3.4'";
  (dom(stack<+{sp|->INSTRUCTION_NEXT(pc)}) = 0..sp+1-1);
  ("`RETURN preconditions in this component'" & 1<=sp);
  "`Check that the invariant (pc : INSTRUCTION) is preserved by the operation - ref 3.4'";
  (stack(sp-1) : INSTRUCTION);
  (sp-1 : INTEGER);
  (0<=sp-1);
  ({sp-1}<<|stack : NATURAL +-> INSTRUCTION);
  (dom({sp-1}<<|stack) = 0..sp-1-1);
  ("`RETLW preconditions in this component'" & k : WORD & 1<=sp);
  ("`ADDLW preconditions in this component'" & k : WORD);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(k,w));
  (INSTRUCTION_NEXT(pc) : INSTRUCTION);
  ("`ADDWF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),w) & d = 0);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),w) & not(d = 0));
  "`Check that the invariant (mem : REGISTER --> WORD) is preserved by the operation - ref 3.4'";
  (mem<+{f|->result} : REGISTER +-> WORD);
  (dom(mem<+{f|->result}) = REGISTER);
  ("`SUBLW preconditions in this component'" & k : WORD);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(k,w));
  ("`SUBWF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),w) & d = 0);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),w) & not(d = 0));
  ("`ANDLW preconditions in this component'" & k : WORD);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = and(k,w));
  ("`ANDLWF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = and(mem(f),w) & d = 0);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = and(mem(f),w) & not(d = 0));
  ("`IORLW preconditions in this component'" & k : WORD);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = ior(k,w));
  ("`IORLWF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = ior(mem(f),w) & d = 0);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = ior(mem(f),w) & not(d = 0));
  ("`XORLW preconditions in this component'" & k : WORD);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = xor(k,w));
  ("`XORLWF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = xor(mem(f),w) & d = 0);
  ("`Local hypotheses'" & result : WORD & zero : BOOL & result,zero = xor(mem(f),w) & not(d = 0));
  ("`BCF preconditions in this component'" & f : REGISTER & b : WORD_POSITION);
  (mem<+{f|->bitclear(mem(f),b)} : REGISTER +-> WORD);
  (dom(mem<+{f|->bitclear(mem(f),b)}) = REGISTER);
  ("`BSF preconditions in this component'" & f : REGISTER & b : WORD_POSITION);
  (mem<+{f|->bitset(mem(f),b)} : REGISTER +-> WORD);
  (dom(mem<+{f|->bitset(mem(f),b)}) = REGISTER);
  ("`BTFSC preconditions in this component'" & f : REGISTER & b : WORD_POSITION);
  ("`Local hypotheses'" & bitget(mem(f),b) = 0);
  (INSTRUCTION_NEXT(INSTRUCTION_NEXT(pc)) : INSTRUCTION);
  ("`Local hypotheses'" & not(bitget(mem(f),b) = 0));
  ("`BTFSS preconditions in this component'" & f : REGISTER & b : WORD_POSITION);
  ("`Local hypotheses'" & bitget(mem(f),b) = 1);
  ("`Local hypotheses'" & not(bitget(mem(f),b) = 1));
  ("`CLRF preconditions in this component'" & f : REGISTER);
  (mem<+{f|->0} : REGISTER +-> WORD);
  (dom(mem<+{f|->0}) = REGISTER);
  "`Check that the invariant (w : WORD) is preserved by the operation - ref 3.4'";
  (0 : WORD);
  ("`COMF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result = complement(mem(f)) & d = 0);
  (result : WORD);
  ("`Local hypotheses'" & result = complement(mem(f)) & not(d = 0));
  ("`DECF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),1) & d = 0);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),1) & not(d = 0));
  ("`DECFSZ preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),1) & result = 0 & d = 0);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),1) & result = 0 & not(d = 0));
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),1) & not(result = 0) & d = 0);
  ("`Local hypotheses'" & result : WORD & borrow : BOOL & zero : BOOL & result,borrow,zero = substract(mem(f),1) & not(result = 0) & not(d = 0));
  ("`GOTO preconditions in this component'" & k : INSTRUCTION);
  ("`INCF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),1) & d = 0);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),1) & not(d = 0));
  ("`INCFSZ preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),1) & result = 0 & d = 0);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),1) & result = 0 & not(d = 0));
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),1) & not(result = 0) & d = 0);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & zero : BOOL & result,carry,zero = add(mem(f),1) & not(result = 0) & not(d = 0));
  ("`MOVLW preconditions in this component'" & k : WORD);
  ("`MOVF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & d = 0);
  (mem(f) : WORD);
  ("`Local hypotheses'" & not(d = 0));
  ("`MOVWF preconditions in this component'" & f : REGISTER);
  (mem<+{f|->w} : REGISTER +-> WORD);
  (dom(mem<+{f|->w}) = REGISTER);
  ("`ROLF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & result,carry = rotateleft(mem(f)) & d = 0);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & result,carry = rotateleft(mem(f)) & not(d = 0));
  ("`RORF preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & result,carry = rotateright(mem(f)) & d = 0);
  ("`Local hypotheses'" & result : WORD & carry : BOOL & result,carry = rotateright(mem(f)) & not(d = 0));
  ("`SWAP preconditions in this component'" & f : REGISTER & d : BIT);
  ("`Local hypotheses'" & result = swap(mem(f)) & d = 0);
  ("`Local hypotheses'" & result = swap(mem(f)) & not(d = 0))
END
&
THEORY EnumerateX 
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(local_op == OK)
END
